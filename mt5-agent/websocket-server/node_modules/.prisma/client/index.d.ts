
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model MT5Account
 * 
 */
export type MT5Account = $Result.DefaultSelection<Prisma.$MT5AccountPayload>
/**
 * Model EA
 * 
 */
export type EA = $Result.DefaultSelection<Prisma.$EAPayload>
/**
 * Model Trade
 * 
 */
export type Trade = $Result.DefaultSelection<Prisma.$TradePayload>
/**
 * Model Automation
 * 
 */
export type Automation = $Result.DefaultSelection<Prisma.$AutomationPayload>
/**
 * Model NotificationLog
 * 
 */
export type NotificationLog = $Result.DefaultSelection<Prisma.$NotificationLogPayload>
/**
 * Model UserInsight
 * 
 */
export type UserInsight = $Result.DefaultSelection<Prisma.$UserInsightPayload>
/**
 * Model SystemLog
 * 
 */
export type SystemLog = $Result.DefaultSelection<Prisma.$SystemLogPayload>
/**
 * Model MarketCondition
 * 
 */
export type MarketCondition = $Result.DefaultSelection<Prisma.$MarketConditionPayload>
/**
 * Model LeaderboardEntry
 * 
 */
export type LeaderboardEntry = $Result.DefaultSelection<Prisma.$LeaderboardEntryPayload>
/**
 * Model IBPartner
 * 
 */
export type IBPartner = $Result.DefaultSelection<Prisma.$IBPartnerPayload>
/**
 * Model Agent
 * 
 */
export type Agent = $Result.DefaultSelection<Prisma.$AgentPayload>
/**
 * Model MT5AccountAssignment
 * 
 */
export type MT5AccountAssignment = $Result.DefaultSelection<Prisma.$MT5AccountAssignmentPayload>
/**
 * Model Prize
 * 
 */
export type Prize = $Result.DefaultSelection<Prisma.$PrizePayload>
/**
 * Model GlobalSettings
 * 
 */
export type GlobalSettings = $Result.DefaultSelection<Prisma.$GlobalSettingsPayload>
/**
 * Model AnonymousAccount
 * 
 */
export type AnonymousAccount = $Result.DefaultSelection<Prisma.$AnonymousAccountPayload>
/**
 * Model IBCommission
 * 
 */
export type IBCommission = $Result.DefaultSelection<Prisma.$IBCommissionPayload>
/**
 * Model IBCommissionRate
 * 
 */
export type IBCommissionRate = $Result.DefaultSelection<Prisma.$IBCommissionRatePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  ADMIN: 'ADMIN',
  TRADER: 'TRADER',
  IB: 'IB',
  SUPER_ADMIN: 'SUPER_ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const SubscriptionTier: {
  FREE: 'FREE',
  TRIAL: 'TRIAL',
  BASIC: 'BASIC',
  PREMIUM: 'PREMIUM',
  VIP: 'VIP'
};

export type SubscriptionTier = (typeof SubscriptionTier)[keyof typeof SubscriptionTier]


export const AccountStatus: {
  PENDING: 'PENDING',
  ACTIVE: 'ACTIVE',
  SUSPENDED: 'SUSPENDED',
  CLOSED: 'CLOSED'
};

export type AccountStatus = (typeof AccountStatus)[keyof typeof AccountStatus]


export const EAStatus: {
  STOPPED: 'STOPPED',
  RUNNING: 'RUNNING',
  PAUSED: 'PAUSED',
  ERROR: 'ERROR'
};

export type EAStatus = (typeof EAStatus)[keyof typeof EAStatus]


export const SafetyIndicator: {
  RED: 'RED',
  ORANGE: 'ORANGE',
  GREEN: 'GREEN'
};

export type SafetyIndicator = (typeof SafetyIndicator)[keyof typeof SafetyIndicator]


export const AutomationTriggerType: {
  LEAD_OPTIN: 'LEAD_OPTIN',
  MT5_REGISTRATION: 'MT5_REGISTRATION',
  WINNING_TRADES: 'WINNING_TRADES',
  LOSING_TRADES: 'LOSING_TRADES',
  SUBSCRIPTION_UPGRADE: 'SUBSCRIPTION_UPGRADE',
  SUBSCRIPTION_EXPIRED: 'SUBSCRIPTION_EXPIRED',
  HIGH_PROFIT_ACHIEVED: 'HIGH_PROFIT_ACHIEVED',
  CONSECUTIVE_LOSSES: 'CONSECUTIVE_LOSSES',
  ACCOUNT_INACTIVE: 'ACCOUNT_INACTIVE',
  TRIAL_ENDING: 'TRIAL_ENDING'
};

export type AutomationTriggerType = (typeof AutomationTriggerType)[keyof typeof AutomationTriggerType]


export const AutomationStatus: {
  ACTIVE: 'ACTIVE',
  PAUSED: 'PAUSED',
  ARCHIVED: 'ARCHIVED'
};

export type AutomationStatus = (typeof AutomationStatus)[keyof typeof AutomationStatus]


export const AutomationActionType: {
  EMAIL: 'EMAIL',
  SMS: 'SMS',
  WHATSAPP: 'WHATSAPP',
  PUSH_NOTIFICATION: 'PUSH_NOTIFICATION',
  IN_APP_MESSAGE: 'IN_APP_MESSAGE'
};

export type AutomationActionType = (typeof AutomationActionType)[keyof typeof AutomationActionType]


export const NotificationStatus: {
  PENDING: 'PENDING',
  SENT: 'SENT',
  FAILED: 'FAILED',
  DELIVERED: 'DELIVERED'
};

export type NotificationStatus = (typeof NotificationStatus)[keyof typeof NotificationStatus]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type SubscriptionTier = $Enums.SubscriptionTier

export const SubscriptionTier: typeof $Enums.SubscriptionTier

export type AccountStatus = $Enums.AccountStatus

export const AccountStatus: typeof $Enums.AccountStatus

export type EAStatus = $Enums.EAStatus

export const EAStatus: typeof $Enums.EAStatus

export type SafetyIndicator = $Enums.SafetyIndicator

export const SafetyIndicator: typeof $Enums.SafetyIndicator

export type AutomationTriggerType = $Enums.AutomationTriggerType

export const AutomationTriggerType: typeof $Enums.AutomationTriggerType

export type AutomationStatus = $Enums.AutomationStatus

export const AutomationStatus: typeof $Enums.AutomationStatus

export type AutomationActionType = $Enums.AutomationActionType

export const AutomationActionType: typeof $Enums.AutomationActionType

export type NotificationStatus = $Enums.NotificationStatus

export const NotificationStatus: typeof $Enums.NotificationStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.mT5Account`: Exposes CRUD operations for the **MT5Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MT5Accounts
    * const mT5Accounts = await prisma.mT5Account.findMany()
    * ```
    */
  get mT5Account(): Prisma.MT5AccountDelegate<ExtArgs>;

  /**
   * `prisma.eA`: Exposes CRUD operations for the **EA** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EAS
    * const eAS = await prisma.eA.findMany()
    * ```
    */
  get eA(): Prisma.EADelegate<ExtArgs>;

  /**
   * `prisma.trade`: Exposes CRUD operations for the **Trade** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Trades
    * const trades = await prisma.trade.findMany()
    * ```
    */
  get trade(): Prisma.TradeDelegate<ExtArgs>;

  /**
   * `prisma.automation`: Exposes CRUD operations for the **Automation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Automations
    * const automations = await prisma.automation.findMany()
    * ```
    */
  get automation(): Prisma.AutomationDelegate<ExtArgs>;

  /**
   * `prisma.notificationLog`: Exposes CRUD operations for the **NotificationLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationLogs
    * const notificationLogs = await prisma.notificationLog.findMany()
    * ```
    */
  get notificationLog(): Prisma.NotificationLogDelegate<ExtArgs>;

  /**
   * `prisma.userInsight`: Exposes CRUD operations for the **UserInsight** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserInsights
    * const userInsights = await prisma.userInsight.findMany()
    * ```
    */
  get userInsight(): Prisma.UserInsightDelegate<ExtArgs>;

  /**
   * `prisma.systemLog`: Exposes CRUD operations for the **SystemLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemLogs
    * const systemLogs = await prisma.systemLog.findMany()
    * ```
    */
  get systemLog(): Prisma.SystemLogDelegate<ExtArgs>;

  /**
   * `prisma.marketCondition`: Exposes CRUD operations for the **MarketCondition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MarketConditions
    * const marketConditions = await prisma.marketCondition.findMany()
    * ```
    */
  get marketCondition(): Prisma.MarketConditionDelegate<ExtArgs>;

  /**
   * `prisma.leaderboardEntry`: Exposes CRUD operations for the **LeaderboardEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeaderboardEntries
    * const leaderboardEntries = await prisma.leaderboardEntry.findMany()
    * ```
    */
  get leaderboardEntry(): Prisma.LeaderboardEntryDelegate<ExtArgs>;

  /**
   * `prisma.iBPartner`: Exposes CRUD operations for the **IBPartner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IBPartners
    * const iBPartners = await prisma.iBPartner.findMany()
    * ```
    */
  get iBPartner(): Prisma.IBPartnerDelegate<ExtArgs>;

  /**
   * `prisma.agent`: Exposes CRUD operations for the **Agent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Agents
    * const agents = await prisma.agent.findMany()
    * ```
    */
  get agent(): Prisma.AgentDelegate<ExtArgs>;

  /**
   * `prisma.mT5AccountAssignment`: Exposes CRUD operations for the **MT5AccountAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MT5AccountAssignments
    * const mT5AccountAssignments = await prisma.mT5AccountAssignment.findMany()
    * ```
    */
  get mT5AccountAssignment(): Prisma.MT5AccountAssignmentDelegate<ExtArgs>;

  /**
   * `prisma.prize`: Exposes CRUD operations for the **Prize** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prizes
    * const prizes = await prisma.prize.findMany()
    * ```
    */
  get prize(): Prisma.PrizeDelegate<ExtArgs>;

  /**
   * `prisma.globalSettings`: Exposes CRUD operations for the **GlobalSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GlobalSettings
    * const globalSettings = await prisma.globalSettings.findMany()
    * ```
    */
  get globalSettings(): Prisma.GlobalSettingsDelegate<ExtArgs>;

  /**
   * `prisma.anonymousAccount`: Exposes CRUD operations for the **AnonymousAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnonymousAccounts
    * const anonymousAccounts = await prisma.anonymousAccount.findMany()
    * ```
    */
  get anonymousAccount(): Prisma.AnonymousAccountDelegate<ExtArgs>;

  /**
   * `prisma.iBCommission`: Exposes CRUD operations for the **IBCommission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IBCommissions
    * const iBCommissions = await prisma.iBCommission.findMany()
    * ```
    */
  get iBCommission(): Prisma.IBCommissionDelegate<ExtArgs>;

  /**
   * `prisma.iBCommissionRate`: Exposes CRUD operations for the **IBCommissionRate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IBCommissionRates
    * const iBCommissionRates = await prisma.iBCommissionRate.findMany()
    * ```
    */
  get iBCommissionRate(): Prisma.IBCommissionRateDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    MT5Account: 'MT5Account',
    EA: 'EA',
    Trade: 'Trade',
    Automation: 'Automation',
    NotificationLog: 'NotificationLog',
    UserInsight: 'UserInsight',
    SystemLog: 'SystemLog',
    MarketCondition: 'MarketCondition',
    LeaderboardEntry: 'LeaderboardEntry',
    IBPartner: 'IBPartner',
    Agent: 'Agent',
    MT5AccountAssignment: 'MT5AccountAssignment',
    Prize: 'Prize',
    GlobalSettings: 'GlobalSettings',
    AnonymousAccount: 'AnonymousAccount',
    IBCommission: 'IBCommission',
    IBCommissionRate: 'IBCommissionRate'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "mT5Account" | "eA" | "trade" | "automation" | "notificationLog" | "userInsight" | "systemLog" | "marketCondition" | "leaderboardEntry" | "iBPartner" | "agent" | "mT5AccountAssignment" | "prize" | "globalSettings" | "anonymousAccount" | "iBCommission" | "iBCommissionRate"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      MT5Account: {
        payload: Prisma.$MT5AccountPayload<ExtArgs>
        fields: Prisma.MT5AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MT5AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MT5AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5AccountPayload>
          }
          findFirst: {
            args: Prisma.MT5AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MT5AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5AccountPayload>
          }
          findMany: {
            args: Prisma.MT5AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5AccountPayload>[]
          }
          create: {
            args: Prisma.MT5AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5AccountPayload>
          }
          createMany: {
            args: Prisma.MT5AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MT5AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5AccountPayload>[]
          }
          delete: {
            args: Prisma.MT5AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5AccountPayload>
          }
          update: {
            args: Prisma.MT5AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5AccountPayload>
          }
          deleteMany: {
            args: Prisma.MT5AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MT5AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MT5AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5AccountPayload>
          }
          aggregate: {
            args: Prisma.MT5AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMT5Account>
          }
          groupBy: {
            args: Prisma.MT5AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<MT5AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.MT5AccountCountArgs<ExtArgs>
            result: $Utils.Optional<MT5AccountCountAggregateOutputType> | number
          }
        }
      }
      EA: {
        payload: Prisma.$EAPayload<ExtArgs>
        fields: Prisma.EAFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EAFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EAPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EAFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EAPayload>
          }
          findFirst: {
            args: Prisma.EAFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EAPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EAFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EAPayload>
          }
          findMany: {
            args: Prisma.EAFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EAPayload>[]
          }
          create: {
            args: Prisma.EACreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EAPayload>
          }
          createMany: {
            args: Prisma.EACreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EACreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EAPayload>[]
          }
          delete: {
            args: Prisma.EADeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EAPayload>
          }
          update: {
            args: Prisma.EAUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EAPayload>
          }
          deleteMany: {
            args: Prisma.EADeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EAUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EAUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EAPayload>
          }
          aggregate: {
            args: Prisma.EAAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEA>
          }
          groupBy: {
            args: Prisma.EAGroupByArgs<ExtArgs>
            result: $Utils.Optional<EAGroupByOutputType>[]
          }
          count: {
            args: Prisma.EACountArgs<ExtArgs>
            result: $Utils.Optional<EACountAggregateOutputType> | number
          }
        }
      }
      Trade: {
        payload: Prisma.$TradePayload<ExtArgs>
        fields: Prisma.TradeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TradeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TradeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradePayload>
          }
          findFirst: {
            args: Prisma.TradeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TradeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradePayload>
          }
          findMany: {
            args: Prisma.TradeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradePayload>[]
          }
          create: {
            args: Prisma.TradeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradePayload>
          }
          createMany: {
            args: Prisma.TradeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TradeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradePayload>[]
          }
          delete: {
            args: Prisma.TradeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradePayload>
          }
          update: {
            args: Prisma.TradeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradePayload>
          }
          deleteMany: {
            args: Prisma.TradeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TradeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TradeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradePayload>
          }
          aggregate: {
            args: Prisma.TradeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrade>
          }
          groupBy: {
            args: Prisma.TradeGroupByArgs<ExtArgs>
            result: $Utils.Optional<TradeGroupByOutputType>[]
          }
          count: {
            args: Prisma.TradeCountArgs<ExtArgs>
            result: $Utils.Optional<TradeCountAggregateOutputType> | number
          }
        }
      }
      Automation: {
        payload: Prisma.$AutomationPayload<ExtArgs>
        fields: Prisma.AutomationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AutomationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AutomationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>
          }
          findFirst: {
            args: Prisma.AutomationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AutomationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>
          }
          findMany: {
            args: Prisma.AutomationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>[]
          }
          create: {
            args: Prisma.AutomationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>
          }
          createMany: {
            args: Prisma.AutomationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AutomationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>[]
          }
          delete: {
            args: Prisma.AutomationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>
          }
          update: {
            args: Prisma.AutomationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>
          }
          deleteMany: {
            args: Prisma.AutomationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AutomationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AutomationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>
          }
          aggregate: {
            args: Prisma.AutomationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAutomation>
          }
          groupBy: {
            args: Prisma.AutomationGroupByArgs<ExtArgs>
            result: $Utils.Optional<AutomationGroupByOutputType>[]
          }
          count: {
            args: Prisma.AutomationCountArgs<ExtArgs>
            result: $Utils.Optional<AutomationCountAggregateOutputType> | number
          }
        }
      }
      NotificationLog: {
        payload: Prisma.$NotificationLogPayload<ExtArgs>
        fields: Prisma.NotificationLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          findFirst: {
            args: Prisma.NotificationLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          findMany: {
            args: Prisma.NotificationLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>[]
          }
          create: {
            args: Prisma.NotificationLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          createMany: {
            args: Prisma.NotificationLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>[]
          }
          delete: {
            args: Prisma.NotificationLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          update: {
            args: Prisma.NotificationLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          deleteMany: {
            args: Prisma.NotificationLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          aggregate: {
            args: Prisma.NotificationLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationLog>
          }
          groupBy: {
            args: Prisma.NotificationLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationLogCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationLogCountAggregateOutputType> | number
          }
        }
      }
      UserInsight: {
        payload: Prisma.$UserInsightPayload<ExtArgs>
        fields: Prisma.UserInsightFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserInsightFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInsightPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserInsightFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInsightPayload>
          }
          findFirst: {
            args: Prisma.UserInsightFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInsightPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserInsightFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInsightPayload>
          }
          findMany: {
            args: Prisma.UserInsightFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInsightPayload>[]
          }
          create: {
            args: Prisma.UserInsightCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInsightPayload>
          }
          createMany: {
            args: Prisma.UserInsightCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserInsightCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInsightPayload>[]
          }
          delete: {
            args: Prisma.UserInsightDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInsightPayload>
          }
          update: {
            args: Prisma.UserInsightUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInsightPayload>
          }
          deleteMany: {
            args: Prisma.UserInsightDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserInsightUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserInsightUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInsightPayload>
          }
          aggregate: {
            args: Prisma.UserInsightAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserInsight>
          }
          groupBy: {
            args: Prisma.UserInsightGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserInsightGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserInsightCountArgs<ExtArgs>
            result: $Utils.Optional<UserInsightCountAggregateOutputType> | number
          }
        }
      }
      SystemLog: {
        payload: Prisma.$SystemLogPayload<ExtArgs>
        fields: Prisma.SystemLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>
          }
          findFirst: {
            args: Prisma.SystemLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>
          }
          findMany: {
            args: Prisma.SystemLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>[]
          }
          create: {
            args: Prisma.SystemLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>
          }
          createMany: {
            args: Prisma.SystemLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>[]
          }
          delete: {
            args: Prisma.SystemLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>
          }
          update: {
            args: Prisma.SystemLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>
          }
          deleteMany: {
            args: Prisma.SystemLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SystemLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>
          }
          aggregate: {
            args: Prisma.SystemLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemLog>
          }
          groupBy: {
            args: Prisma.SystemLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemLogCountArgs<ExtArgs>
            result: $Utils.Optional<SystemLogCountAggregateOutputType> | number
          }
        }
      }
      MarketCondition: {
        payload: Prisma.$MarketConditionPayload<ExtArgs>
        fields: Prisma.MarketConditionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MarketConditionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketConditionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MarketConditionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketConditionPayload>
          }
          findFirst: {
            args: Prisma.MarketConditionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketConditionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MarketConditionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketConditionPayload>
          }
          findMany: {
            args: Prisma.MarketConditionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketConditionPayload>[]
          }
          create: {
            args: Prisma.MarketConditionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketConditionPayload>
          }
          createMany: {
            args: Prisma.MarketConditionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MarketConditionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketConditionPayload>[]
          }
          delete: {
            args: Prisma.MarketConditionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketConditionPayload>
          }
          update: {
            args: Prisma.MarketConditionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketConditionPayload>
          }
          deleteMany: {
            args: Prisma.MarketConditionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MarketConditionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MarketConditionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketConditionPayload>
          }
          aggregate: {
            args: Prisma.MarketConditionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMarketCondition>
          }
          groupBy: {
            args: Prisma.MarketConditionGroupByArgs<ExtArgs>
            result: $Utils.Optional<MarketConditionGroupByOutputType>[]
          }
          count: {
            args: Prisma.MarketConditionCountArgs<ExtArgs>
            result: $Utils.Optional<MarketConditionCountAggregateOutputType> | number
          }
        }
      }
      LeaderboardEntry: {
        payload: Prisma.$LeaderboardEntryPayload<ExtArgs>
        fields: Prisma.LeaderboardEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaderboardEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaderboardEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>
          }
          findFirst: {
            args: Prisma.LeaderboardEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaderboardEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>
          }
          findMany: {
            args: Prisma.LeaderboardEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>[]
          }
          create: {
            args: Prisma.LeaderboardEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>
          }
          createMany: {
            args: Prisma.LeaderboardEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeaderboardEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>[]
          }
          delete: {
            args: Prisma.LeaderboardEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>
          }
          update: {
            args: Prisma.LeaderboardEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>
          }
          deleteMany: {
            args: Prisma.LeaderboardEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeaderboardEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LeaderboardEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>
          }
          aggregate: {
            args: Prisma.LeaderboardEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeaderboardEntry>
          }
          groupBy: {
            args: Prisma.LeaderboardEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeaderboardEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaderboardEntryCountArgs<ExtArgs>
            result: $Utils.Optional<LeaderboardEntryCountAggregateOutputType> | number
          }
        }
      }
      IBPartner: {
        payload: Prisma.$IBPartnerPayload<ExtArgs>
        fields: Prisma.IBPartnerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IBPartnerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IBPartnerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IBPartnerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IBPartnerPayload>
          }
          findFirst: {
            args: Prisma.IBPartnerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IBPartnerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IBPartnerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IBPartnerPayload>
          }
          findMany: {
            args: Prisma.IBPartnerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IBPartnerPayload>[]
          }
          create: {
            args: Prisma.IBPartnerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IBPartnerPayload>
          }
          createMany: {
            args: Prisma.IBPartnerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IBPartnerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IBPartnerPayload>[]
          }
          delete: {
            args: Prisma.IBPartnerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IBPartnerPayload>
          }
          update: {
            args: Prisma.IBPartnerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IBPartnerPayload>
          }
          deleteMany: {
            args: Prisma.IBPartnerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IBPartnerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IBPartnerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IBPartnerPayload>
          }
          aggregate: {
            args: Prisma.IBPartnerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIBPartner>
          }
          groupBy: {
            args: Prisma.IBPartnerGroupByArgs<ExtArgs>
            result: $Utils.Optional<IBPartnerGroupByOutputType>[]
          }
          count: {
            args: Prisma.IBPartnerCountArgs<ExtArgs>
            result: $Utils.Optional<IBPartnerCountAggregateOutputType> | number
          }
        }
      }
      Agent: {
        payload: Prisma.$AgentPayload<ExtArgs>
        fields: Prisma.AgentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          findFirst: {
            args: Prisma.AgentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          findMany: {
            args: Prisma.AgentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>[]
          }
          create: {
            args: Prisma.AgentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          createMany: {
            args: Prisma.AgentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>[]
          }
          delete: {
            args: Prisma.AgentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          update: {
            args: Prisma.AgentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          deleteMany: {
            args: Prisma.AgentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AgentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          aggregate: {
            args: Prisma.AgentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgent>
          }
          groupBy: {
            args: Prisma.AgentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgentCountArgs<ExtArgs>
            result: $Utils.Optional<AgentCountAggregateOutputType> | number
          }
        }
      }
      MT5AccountAssignment: {
        payload: Prisma.$MT5AccountAssignmentPayload<ExtArgs>
        fields: Prisma.MT5AccountAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MT5AccountAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5AccountAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MT5AccountAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5AccountAssignmentPayload>
          }
          findFirst: {
            args: Prisma.MT5AccountAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5AccountAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MT5AccountAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5AccountAssignmentPayload>
          }
          findMany: {
            args: Prisma.MT5AccountAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5AccountAssignmentPayload>[]
          }
          create: {
            args: Prisma.MT5AccountAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5AccountAssignmentPayload>
          }
          createMany: {
            args: Prisma.MT5AccountAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MT5AccountAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5AccountAssignmentPayload>[]
          }
          delete: {
            args: Prisma.MT5AccountAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5AccountAssignmentPayload>
          }
          update: {
            args: Prisma.MT5AccountAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5AccountAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.MT5AccountAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MT5AccountAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MT5AccountAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5AccountAssignmentPayload>
          }
          aggregate: {
            args: Prisma.MT5AccountAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMT5AccountAssignment>
          }
          groupBy: {
            args: Prisma.MT5AccountAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<MT5AccountAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.MT5AccountAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<MT5AccountAssignmentCountAggregateOutputType> | number
          }
        }
      }
      Prize: {
        payload: Prisma.$PrizePayload<ExtArgs>
        fields: Prisma.PrizeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrizeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrizePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrizeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrizePayload>
          }
          findFirst: {
            args: Prisma.PrizeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrizePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrizeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrizePayload>
          }
          findMany: {
            args: Prisma.PrizeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrizePayload>[]
          }
          create: {
            args: Prisma.PrizeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrizePayload>
          }
          createMany: {
            args: Prisma.PrizeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PrizeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrizePayload>[]
          }
          delete: {
            args: Prisma.PrizeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrizePayload>
          }
          update: {
            args: Prisma.PrizeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrizePayload>
          }
          deleteMany: {
            args: Prisma.PrizeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrizeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PrizeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrizePayload>
          }
          aggregate: {
            args: Prisma.PrizeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrize>
          }
          groupBy: {
            args: Prisma.PrizeGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrizeGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrizeCountArgs<ExtArgs>
            result: $Utils.Optional<PrizeCountAggregateOutputType> | number
          }
        }
      }
      GlobalSettings: {
        payload: Prisma.$GlobalSettingsPayload<ExtArgs>
        fields: Prisma.GlobalSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GlobalSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GlobalSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalSettingsPayload>
          }
          findFirst: {
            args: Prisma.GlobalSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GlobalSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalSettingsPayload>
          }
          findMany: {
            args: Prisma.GlobalSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalSettingsPayload>[]
          }
          create: {
            args: Prisma.GlobalSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalSettingsPayload>
          }
          createMany: {
            args: Prisma.GlobalSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GlobalSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalSettingsPayload>[]
          }
          delete: {
            args: Prisma.GlobalSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalSettingsPayload>
          }
          update: {
            args: Prisma.GlobalSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalSettingsPayload>
          }
          deleteMany: {
            args: Prisma.GlobalSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GlobalSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GlobalSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalSettingsPayload>
          }
          aggregate: {
            args: Prisma.GlobalSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGlobalSettings>
          }
          groupBy: {
            args: Prisma.GlobalSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<GlobalSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.GlobalSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<GlobalSettingsCountAggregateOutputType> | number
          }
        }
      }
      AnonymousAccount: {
        payload: Prisma.$AnonymousAccountPayload<ExtArgs>
        fields: Prisma.AnonymousAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnonymousAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnonymousAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnonymousAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnonymousAccountPayload>
          }
          findFirst: {
            args: Prisma.AnonymousAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnonymousAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnonymousAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnonymousAccountPayload>
          }
          findMany: {
            args: Prisma.AnonymousAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnonymousAccountPayload>[]
          }
          create: {
            args: Prisma.AnonymousAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnonymousAccountPayload>
          }
          createMany: {
            args: Prisma.AnonymousAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnonymousAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnonymousAccountPayload>[]
          }
          delete: {
            args: Prisma.AnonymousAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnonymousAccountPayload>
          }
          update: {
            args: Prisma.AnonymousAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnonymousAccountPayload>
          }
          deleteMany: {
            args: Prisma.AnonymousAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnonymousAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AnonymousAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnonymousAccountPayload>
          }
          aggregate: {
            args: Prisma.AnonymousAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnonymousAccount>
          }
          groupBy: {
            args: Prisma.AnonymousAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnonymousAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnonymousAccountCountArgs<ExtArgs>
            result: $Utils.Optional<AnonymousAccountCountAggregateOutputType> | number
          }
        }
      }
      IBCommission: {
        payload: Prisma.$IBCommissionPayload<ExtArgs>
        fields: Prisma.IBCommissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IBCommissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IBCommissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IBCommissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IBCommissionPayload>
          }
          findFirst: {
            args: Prisma.IBCommissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IBCommissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IBCommissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IBCommissionPayload>
          }
          findMany: {
            args: Prisma.IBCommissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IBCommissionPayload>[]
          }
          create: {
            args: Prisma.IBCommissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IBCommissionPayload>
          }
          createMany: {
            args: Prisma.IBCommissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IBCommissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IBCommissionPayload>[]
          }
          delete: {
            args: Prisma.IBCommissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IBCommissionPayload>
          }
          update: {
            args: Prisma.IBCommissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IBCommissionPayload>
          }
          deleteMany: {
            args: Prisma.IBCommissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IBCommissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IBCommissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IBCommissionPayload>
          }
          aggregate: {
            args: Prisma.IBCommissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIBCommission>
          }
          groupBy: {
            args: Prisma.IBCommissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<IBCommissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.IBCommissionCountArgs<ExtArgs>
            result: $Utils.Optional<IBCommissionCountAggregateOutputType> | number
          }
        }
      }
      IBCommissionRate: {
        payload: Prisma.$IBCommissionRatePayload<ExtArgs>
        fields: Prisma.IBCommissionRateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IBCommissionRateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IBCommissionRatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IBCommissionRateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IBCommissionRatePayload>
          }
          findFirst: {
            args: Prisma.IBCommissionRateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IBCommissionRatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IBCommissionRateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IBCommissionRatePayload>
          }
          findMany: {
            args: Prisma.IBCommissionRateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IBCommissionRatePayload>[]
          }
          create: {
            args: Prisma.IBCommissionRateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IBCommissionRatePayload>
          }
          createMany: {
            args: Prisma.IBCommissionRateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IBCommissionRateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IBCommissionRatePayload>[]
          }
          delete: {
            args: Prisma.IBCommissionRateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IBCommissionRatePayload>
          }
          update: {
            args: Prisma.IBCommissionRateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IBCommissionRatePayload>
          }
          deleteMany: {
            args: Prisma.IBCommissionRateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IBCommissionRateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IBCommissionRateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IBCommissionRatePayload>
          }
          aggregate: {
            args: Prisma.IBCommissionRateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIBCommissionRate>
          }
          groupBy: {
            args: Prisma.IBCommissionRateGroupByArgs<ExtArgs>
            result: $Utils.Optional<IBCommissionRateGroupByOutputType>[]
          }
          count: {
            args: Prisma.IBCommissionRateCountArgs<ExtArgs>
            result: $Utils.Optional<IBCommissionRateCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    mt5Accounts: number
    eas: number
    trades: number
    notifications: number
    automations: number
    leaderboardStats: number
    agents: number
    accountAssignments: number
    anonymousAccounts: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mt5Accounts?: boolean | UserCountOutputTypeCountMt5AccountsArgs
    eas?: boolean | UserCountOutputTypeCountEasArgs
    trades?: boolean | UserCountOutputTypeCountTradesArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    automations?: boolean | UserCountOutputTypeCountAutomationsArgs
    leaderboardStats?: boolean | UserCountOutputTypeCountLeaderboardStatsArgs
    agents?: boolean | UserCountOutputTypeCountAgentsArgs
    accountAssignments?: boolean | UserCountOutputTypeCountAccountAssignmentsArgs
    anonymousAccounts?: boolean | UserCountOutputTypeCountAnonymousAccountsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMt5AccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MT5AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EAWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TradeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAutomationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutomationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLeaderboardStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaderboardEntryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAgentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MT5AccountAssignmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAnonymousAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnonymousAccountWhereInput
  }


  /**
   * Count Type MT5AccountCountOutputType
   */

  export type MT5AccountCountOutputType = {
    eas: number
    trades: number
  }

  export type MT5AccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    eas?: boolean | MT5AccountCountOutputTypeCountEasArgs
    trades?: boolean | MT5AccountCountOutputTypeCountTradesArgs
  }

  // Custom InputTypes
  /**
   * MT5AccountCountOutputType without action
   */
  export type MT5AccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5AccountCountOutputType
     */
    select?: MT5AccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MT5AccountCountOutputType without action
   */
  export type MT5AccountCountOutputTypeCountEasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EAWhereInput
  }

  /**
   * MT5AccountCountOutputType without action
   */
  export type MT5AccountCountOutputTypeCountTradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TradeWhereInput
  }


  /**
   * Count Type AutomationCountOutputType
   */

  export type AutomationCountOutputType = {
    logs: number
  }

  export type AutomationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    logs?: boolean | AutomationCountOutputTypeCountLogsArgs
  }

  // Custom InputTypes
  /**
   * AutomationCountOutputType without action
   */
  export type AutomationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationCountOutputType
     */
    select?: AutomationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AutomationCountOutputType without action
   */
  export type AutomationCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationLogWhereInput
  }


  /**
   * Count Type IBPartnerCountOutputType
   */

  export type IBPartnerCountOutputType = {
    users: number
    anonymousAccounts: number
    commissions: number
    commissionRates: number
  }

  export type IBPartnerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | IBPartnerCountOutputTypeCountUsersArgs
    anonymousAccounts?: boolean | IBPartnerCountOutputTypeCountAnonymousAccountsArgs
    commissions?: boolean | IBPartnerCountOutputTypeCountCommissionsArgs
    commissionRates?: boolean | IBPartnerCountOutputTypeCountCommissionRatesArgs
  }

  // Custom InputTypes
  /**
   * IBPartnerCountOutputType without action
   */
  export type IBPartnerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IBPartnerCountOutputType
     */
    select?: IBPartnerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * IBPartnerCountOutputType without action
   */
  export type IBPartnerCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * IBPartnerCountOutputType without action
   */
  export type IBPartnerCountOutputTypeCountAnonymousAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnonymousAccountWhereInput
  }

  /**
   * IBPartnerCountOutputType without action
   */
  export type IBPartnerCountOutputTypeCountCommissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IBCommissionWhereInput
  }

  /**
   * IBPartnerCountOutputType without action
   */
  export type IBPartnerCountOutputTypeCountCommissionRatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IBCommissionRateWhereInput
  }


  /**
   * Count Type AgentCountOutputType
   */

  export type AgentCountOutputType = {
    slaveAgents: number
    accountAssignments: number
  }

  export type AgentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    slaveAgents?: boolean | AgentCountOutputTypeCountSlaveAgentsArgs
    accountAssignments?: boolean | AgentCountOutputTypeCountAccountAssignmentsArgs
  }

  // Custom InputTypes
  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentCountOutputType
     */
    select?: AgentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountSlaveAgentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountAccountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MT5AccountAssignmentWhereInput
  }


  /**
   * Count Type AnonymousAccountCountOutputType
   */

  export type AnonymousAccountCountOutputType = {
    commissions: number
  }

  export type AnonymousAccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    commissions?: boolean | AnonymousAccountCountOutputTypeCountCommissionsArgs
  }

  // Custom InputTypes
  /**
   * AnonymousAccountCountOutputType without action
   */
  export type AnonymousAccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousAccountCountOutputType
     */
    select?: AnonymousAccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AnonymousAccountCountOutputType without action
   */
  export type AnonymousAccountCountOutputTypeCountCommissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IBCommissionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    monthlyFee: number | null
    totalTrades: number | null
    winningTrades: number | null
    losingTrades: number | null
    totalProfit: number | null
    totalVolume: number | null
  }

  export type UserSumAggregateOutputType = {
    monthlyFee: number | null
    totalTrades: number | null
    winningTrades: number | null
    losingTrades: number | null
    totalProfit: number | null
    totalVolume: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    firstName: string | null
    lastName: string | null
    role: $Enums.UserRole | null
    phone: string | null
    ibCode: string | null
    ibPartnerId: string | null
    subscriptionTier: $Enums.SubscriptionTier | null
    subscriptionStart: Date | null
    subscriptionEnd: Date | null
    monthlyFee: number | null
    totalTrades: number | null
    winningTrades: number | null
    losingTrades: number | null
    totalProfit: number | null
    totalVolume: number | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLoginAt: Date | null
    lastActiveAt: Date | null
    isActive: boolean | null
    status: $Enums.AccountStatus | null
    emailVerified: boolean | null
    verificationCode: string | null
    verificationExpiry: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    firstName: string | null
    lastName: string | null
    role: $Enums.UserRole | null
    phone: string | null
    ibCode: string | null
    ibPartnerId: string | null
    subscriptionTier: $Enums.SubscriptionTier | null
    subscriptionStart: Date | null
    subscriptionEnd: Date | null
    monthlyFee: number | null
    totalTrades: number | null
    winningTrades: number | null
    losingTrades: number | null
    totalProfit: number | null
    totalVolume: number | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLoginAt: Date | null
    lastActiveAt: Date | null
    isActive: boolean | null
    status: $Enums.AccountStatus | null
    emailVerified: boolean | null
    verificationCode: string | null
    verificationExpiry: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    firstName: number
    lastName: number
    role: number
    phone: number
    ibCode: number
    ibPartnerId: number
    subscriptionTier: number
    subscriptionStart: number
    subscriptionEnd: number
    monthlyFee: number
    totalTrades: number
    winningTrades: number
    losingTrades: number
    totalProfit: number
    totalVolume: number
    createdAt: number
    updatedAt: number
    lastLoginAt: number
    lastActiveAt: number
    isActive: number
    status: number
    emailVerified: number
    verificationCode: number
    verificationExpiry: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    monthlyFee?: true
    totalTrades?: true
    winningTrades?: true
    losingTrades?: true
    totalProfit?: true
    totalVolume?: true
  }

  export type UserSumAggregateInputType = {
    monthlyFee?: true
    totalTrades?: true
    winningTrades?: true
    losingTrades?: true
    totalProfit?: true
    totalVolume?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    role?: true
    phone?: true
    ibCode?: true
    ibPartnerId?: true
    subscriptionTier?: true
    subscriptionStart?: true
    subscriptionEnd?: true
    monthlyFee?: true
    totalTrades?: true
    winningTrades?: true
    losingTrades?: true
    totalProfit?: true
    totalVolume?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
    lastActiveAt?: true
    isActive?: true
    status?: true
    emailVerified?: true
    verificationCode?: true
    verificationExpiry?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    role?: true
    phone?: true
    ibCode?: true
    ibPartnerId?: true
    subscriptionTier?: true
    subscriptionStart?: true
    subscriptionEnd?: true
    monthlyFee?: true
    totalTrades?: true
    winningTrades?: true
    losingTrades?: true
    totalProfit?: true
    totalVolume?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
    lastActiveAt?: true
    isActive?: true
    status?: true
    emailVerified?: true
    verificationCode?: true
    verificationExpiry?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    role?: true
    phone?: true
    ibCode?: true
    ibPartnerId?: true
    subscriptionTier?: true
    subscriptionStart?: true
    subscriptionEnd?: true
    monthlyFee?: true
    totalTrades?: true
    winningTrades?: true
    losingTrades?: true
    totalProfit?: true
    totalVolume?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
    lastActiveAt?: true
    isActive?: true
    status?: true
    emailVerified?: true
    verificationCode?: true
    verificationExpiry?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    phone: string | null
    ibCode: string | null
    ibPartnerId: string | null
    subscriptionTier: $Enums.SubscriptionTier
    subscriptionStart: Date | null
    subscriptionEnd: Date | null
    monthlyFee: number
    totalTrades: number
    winningTrades: number
    losingTrades: number
    totalProfit: number
    totalVolume: number
    createdAt: Date
    updatedAt: Date
    lastLoginAt: Date | null
    lastActiveAt: Date | null
    isActive: boolean
    status: $Enums.AccountStatus
    emailVerified: boolean
    verificationCode: string | null
    verificationExpiry: Date | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    phone?: boolean
    ibCode?: boolean
    ibPartnerId?: boolean
    subscriptionTier?: boolean
    subscriptionStart?: boolean
    subscriptionEnd?: boolean
    monthlyFee?: boolean
    totalTrades?: boolean
    winningTrades?: boolean
    losingTrades?: boolean
    totalProfit?: boolean
    totalVolume?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
    lastActiveAt?: boolean
    isActive?: boolean
    status?: boolean
    emailVerified?: boolean
    verificationCode?: boolean
    verificationExpiry?: boolean
    ibPartner?: boolean | User$ibPartnerArgs<ExtArgs>
    mt5Accounts?: boolean | User$mt5AccountsArgs<ExtArgs>
    eas?: boolean | User$easArgs<ExtArgs>
    trades?: boolean | User$tradesArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    insights?: boolean | User$insightsArgs<ExtArgs>
    automations?: boolean | User$automationsArgs<ExtArgs>
    leaderboardStats?: boolean | User$leaderboardStatsArgs<ExtArgs>
    agents?: boolean | User$agentsArgs<ExtArgs>
    accountAssignments?: boolean | User$accountAssignmentsArgs<ExtArgs>
    anonymousAccounts?: boolean | User$anonymousAccountsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    phone?: boolean
    ibCode?: boolean
    ibPartnerId?: boolean
    subscriptionTier?: boolean
    subscriptionStart?: boolean
    subscriptionEnd?: boolean
    monthlyFee?: boolean
    totalTrades?: boolean
    winningTrades?: boolean
    losingTrades?: boolean
    totalProfit?: boolean
    totalVolume?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
    lastActiveAt?: boolean
    isActive?: boolean
    status?: boolean
    emailVerified?: boolean
    verificationCode?: boolean
    verificationExpiry?: boolean
    ibPartner?: boolean | User$ibPartnerArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    phone?: boolean
    ibCode?: boolean
    ibPartnerId?: boolean
    subscriptionTier?: boolean
    subscriptionStart?: boolean
    subscriptionEnd?: boolean
    monthlyFee?: boolean
    totalTrades?: boolean
    winningTrades?: boolean
    losingTrades?: boolean
    totalProfit?: boolean
    totalVolume?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
    lastActiveAt?: boolean
    isActive?: boolean
    status?: boolean
    emailVerified?: boolean
    verificationCode?: boolean
    verificationExpiry?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ibPartner?: boolean | User$ibPartnerArgs<ExtArgs>
    mt5Accounts?: boolean | User$mt5AccountsArgs<ExtArgs>
    eas?: boolean | User$easArgs<ExtArgs>
    trades?: boolean | User$tradesArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    insights?: boolean | User$insightsArgs<ExtArgs>
    automations?: boolean | User$automationsArgs<ExtArgs>
    leaderboardStats?: boolean | User$leaderboardStatsArgs<ExtArgs>
    agents?: boolean | User$agentsArgs<ExtArgs>
    accountAssignments?: boolean | User$accountAssignmentsArgs<ExtArgs>
    anonymousAccounts?: boolean | User$anonymousAccountsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ibPartner?: boolean | User$ibPartnerArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      ibPartner: Prisma.$IBPartnerPayload<ExtArgs> | null
      mt5Accounts: Prisma.$MT5AccountPayload<ExtArgs>[]
      eas: Prisma.$EAPayload<ExtArgs>[]
      trades: Prisma.$TradePayload<ExtArgs>[]
      notifications: Prisma.$NotificationLogPayload<ExtArgs>[]
      insights: Prisma.$UserInsightPayload<ExtArgs> | null
      automations: Prisma.$AutomationPayload<ExtArgs>[]
      leaderboardStats: Prisma.$LeaderboardEntryPayload<ExtArgs>[]
      agents: Prisma.$AgentPayload<ExtArgs>[]
      accountAssignments: Prisma.$MT5AccountAssignmentPayload<ExtArgs>[]
      anonymousAccounts: Prisma.$AnonymousAccountPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string
      firstName: string
      lastName: string
      role: $Enums.UserRole
      phone: string | null
      ibCode: string | null
      ibPartnerId: string | null
      subscriptionTier: $Enums.SubscriptionTier
      subscriptionStart: Date | null
      subscriptionEnd: Date | null
      monthlyFee: number
      totalTrades: number
      winningTrades: number
      losingTrades: number
      totalProfit: number
      totalVolume: number
      createdAt: Date
      updatedAt: Date
      lastLoginAt: Date | null
      lastActiveAt: Date | null
      isActive: boolean
      status: $Enums.AccountStatus
      emailVerified: boolean
      verificationCode: string | null
      verificationExpiry: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ibPartner<T extends User$ibPartnerArgs<ExtArgs> = {}>(args?: Subset<T, User$ibPartnerArgs<ExtArgs>>): Prisma__IBPartnerClient<$Result.GetResult<Prisma.$IBPartnerPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    mt5Accounts<T extends User$mt5AccountsArgs<ExtArgs> = {}>(args?: Subset<T, User$mt5AccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MT5AccountPayload<ExtArgs>, T, "findMany"> | Null>
    eas<T extends User$easArgs<ExtArgs> = {}>(args?: Subset<T, User$easArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EAPayload<ExtArgs>, T, "findMany"> | Null>
    trades<T extends User$tradesArgs<ExtArgs> = {}>(args?: Subset<T, User$tradesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradePayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findMany"> | Null>
    insights<T extends User$insightsArgs<ExtArgs> = {}>(args?: Subset<T, User$insightsArgs<ExtArgs>>): Prisma__UserInsightClient<$Result.GetResult<Prisma.$UserInsightPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    automations<T extends User$automationsArgs<ExtArgs> = {}>(args?: Subset<T, User$automationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "findMany"> | Null>
    leaderboardStats<T extends User$leaderboardStatsArgs<ExtArgs> = {}>(args?: Subset<T, User$leaderboardStatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, "findMany"> | Null>
    agents<T extends User$agentsArgs<ExtArgs> = {}>(args?: Subset<T, User$agentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findMany"> | Null>
    accountAssignments<T extends User$accountAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MT5AccountAssignmentPayload<ExtArgs>, T, "findMany"> | Null>
    anonymousAccounts<T extends User$anonymousAccountsArgs<ExtArgs> = {}>(args?: Subset<T, User$anonymousAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnonymousAccountPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly phone: FieldRef<"User", 'String'>
    readonly ibCode: FieldRef<"User", 'String'>
    readonly ibPartnerId: FieldRef<"User", 'String'>
    readonly subscriptionTier: FieldRef<"User", 'SubscriptionTier'>
    readonly subscriptionStart: FieldRef<"User", 'DateTime'>
    readonly subscriptionEnd: FieldRef<"User", 'DateTime'>
    readonly monthlyFee: FieldRef<"User", 'Float'>
    readonly totalTrades: FieldRef<"User", 'Int'>
    readonly winningTrades: FieldRef<"User", 'Int'>
    readonly losingTrades: FieldRef<"User", 'Int'>
    readonly totalProfit: FieldRef<"User", 'Float'>
    readonly totalVolume: FieldRef<"User", 'Float'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly lastActiveAt: FieldRef<"User", 'DateTime'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly status: FieldRef<"User", 'AccountStatus'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly verificationCode: FieldRef<"User", 'String'>
    readonly verificationExpiry: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.ibPartner
   */
  export type User$ibPartnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IBPartner
     */
    select?: IBPartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IBPartnerInclude<ExtArgs> | null
    where?: IBPartnerWhereInput
  }

  /**
   * User.mt5Accounts
   */
  export type User$mt5AccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Account
     */
    select?: MT5AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5AccountInclude<ExtArgs> | null
    where?: MT5AccountWhereInput
    orderBy?: MT5AccountOrderByWithRelationInput | MT5AccountOrderByWithRelationInput[]
    cursor?: MT5AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MT5AccountScalarFieldEnum | MT5AccountScalarFieldEnum[]
  }

  /**
   * User.eas
   */
  export type User$easArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EA
     */
    select?: EASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EAInclude<ExtArgs> | null
    where?: EAWhereInput
    orderBy?: EAOrderByWithRelationInput | EAOrderByWithRelationInput[]
    cursor?: EAWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EAScalarFieldEnum | EAScalarFieldEnum[]
  }

  /**
   * User.trades
   */
  export type User$tradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trade
     */
    select?: TradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeInclude<ExtArgs> | null
    where?: TradeWhereInput
    orderBy?: TradeOrderByWithRelationInput | TradeOrderByWithRelationInput[]
    cursor?: TradeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TradeScalarFieldEnum | TradeScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    where?: NotificationLogWhereInput
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    cursor?: NotificationLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationLogScalarFieldEnum | NotificationLogScalarFieldEnum[]
  }

  /**
   * User.insights
   */
  export type User$insightsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInsight
     */
    select?: UserInsightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInsightInclude<ExtArgs> | null
    where?: UserInsightWhereInput
  }

  /**
   * User.automations
   */
  export type User$automationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    where?: AutomationWhereInput
    orderBy?: AutomationOrderByWithRelationInput | AutomationOrderByWithRelationInput[]
    cursor?: AutomationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AutomationScalarFieldEnum | AutomationScalarFieldEnum[]
  }

  /**
   * User.leaderboardStats
   */
  export type User$leaderboardStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
    where?: LeaderboardEntryWhereInput
    orderBy?: LeaderboardEntryOrderByWithRelationInput | LeaderboardEntryOrderByWithRelationInput[]
    cursor?: LeaderboardEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaderboardEntryScalarFieldEnum | LeaderboardEntryScalarFieldEnum[]
  }

  /**
   * User.agents
   */
  export type User$agentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    where?: AgentWhereInput
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    cursor?: AgentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * User.accountAssignments
   */
  export type User$accountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5AccountAssignment
     */
    select?: MT5AccountAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5AccountAssignmentInclude<ExtArgs> | null
    where?: MT5AccountAssignmentWhereInput
    orderBy?: MT5AccountAssignmentOrderByWithRelationInput | MT5AccountAssignmentOrderByWithRelationInput[]
    cursor?: MT5AccountAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MT5AccountAssignmentScalarFieldEnum | MT5AccountAssignmentScalarFieldEnum[]
  }

  /**
   * User.anonymousAccounts
   */
  export type User$anonymousAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousAccount
     */
    select?: AnonymousAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnonymousAccountInclude<ExtArgs> | null
    where?: AnonymousAccountWhereInput
    orderBy?: AnonymousAccountOrderByWithRelationInput | AnonymousAccountOrderByWithRelationInput[]
    cursor?: AnonymousAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnonymousAccountScalarFieldEnum | AnonymousAccountScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model MT5Account
   */

  export type AggregateMT5Account = {
    _count: MT5AccountCountAggregateOutputType | null
    _avg: MT5AccountAvgAggregateOutputType | null
    _sum: MT5AccountSumAggregateOutputType | null
    _min: MT5AccountMinAggregateOutputType | null
    _max: MT5AccountMaxAggregateOutputType | null
  }

  export type MT5AccountAvgAggregateOutputType = {
    vpsPort: number | null
    balance: number | null
    equity: number | null
    margin: number | null
    freeMargin: number | null
  }

  export type MT5AccountSumAggregateOutputType = {
    vpsPort: number | null
    balance: number | null
    equity: number | null
    margin: number | null
    freeMargin: number | null
  }

  export type MT5AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    accountNumber: string | null
    broker: string | null
    serverName: string | null
    login: string | null
    password: string | null
    vpsIp: string | null
    vpsPort: number | null
    status: $Enums.AccountStatus | null
    balance: number | null
    equity: number | null
    margin: number | null
    freeMargin: number | null
    isEnabledForTrading: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    lastSyncAt: Date | null
  }

  export type MT5AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    accountNumber: string | null
    broker: string | null
    serverName: string | null
    login: string | null
    password: string | null
    vpsIp: string | null
    vpsPort: number | null
    status: $Enums.AccountStatus | null
    balance: number | null
    equity: number | null
    margin: number | null
    freeMargin: number | null
    isEnabledForTrading: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    lastSyncAt: Date | null
  }

  export type MT5AccountCountAggregateOutputType = {
    id: number
    userId: number
    accountNumber: number
    broker: number
    serverName: number
    login: number
    password: number
    vpsIp: number
    vpsPort: number
    status: number
    balance: number
    equity: number
    margin: number
    freeMargin: number
    isEnabledForTrading: number
    createdAt: number
    updatedAt: number
    lastSyncAt: number
    _all: number
  }


  export type MT5AccountAvgAggregateInputType = {
    vpsPort?: true
    balance?: true
    equity?: true
    margin?: true
    freeMargin?: true
  }

  export type MT5AccountSumAggregateInputType = {
    vpsPort?: true
    balance?: true
    equity?: true
    margin?: true
    freeMargin?: true
  }

  export type MT5AccountMinAggregateInputType = {
    id?: true
    userId?: true
    accountNumber?: true
    broker?: true
    serverName?: true
    login?: true
    password?: true
    vpsIp?: true
    vpsPort?: true
    status?: true
    balance?: true
    equity?: true
    margin?: true
    freeMargin?: true
    isEnabledForTrading?: true
    createdAt?: true
    updatedAt?: true
    lastSyncAt?: true
  }

  export type MT5AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    accountNumber?: true
    broker?: true
    serverName?: true
    login?: true
    password?: true
    vpsIp?: true
    vpsPort?: true
    status?: true
    balance?: true
    equity?: true
    margin?: true
    freeMargin?: true
    isEnabledForTrading?: true
    createdAt?: true
    updatedAt?: true
    lastSyncAt?: true
  }

  export type MT5AccountCountAggregateInputType = {
    id?: true
    userId?: true
    accountNumber?: true
    broker?: true
    serverName?: true
    login?: true
    password?: true
    vpsIp?: true
    vpsPort?: true
    status?: true
    balance?: true
    equity?: true
    margin?: true
    freeMargin?: true
    isEnabledForTrading?: true
    createdAt?: true
    updatedAt?: true
    lastSyncAt?: true
    _all?: true
  }

  export type MT5AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MT5Account to aggregate.
     */
    where?: MT5AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MT5Accounts to fetch.
     */
    orderBy?: MT5AccountOrderByWithRelationInput | MT5AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MT5AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MT5Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MT5Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MT5Accounts
    **/
    _count?: true | MT5AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MT5AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MT5AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MT5AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MT5AccountMaxAggregateInputType
  }

  export type GetMT5AccountAggregateType<T extends MT5AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateMT5Account]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMT5Account[P]>
      : GetScalarType<T[P], AggregateMT5Account[P]>
  }




  export type MT5AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MT5AccountWhereInput
    orderBy?: MT5AccountOrderByWithAggregationInput | MT5AccountOrderByWithAggregationInput[]
    by: MT5AccountScalarFieldEnum[] | MT5AccountScalarFieldEnum
    having?: MT5AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MT5AccountCountAggregateInputType | true
    _avg?: MT5AccountAvgAggregateInputType
    _sum?: MT5AccountSumAggregateInputType
    _min?: MT5AccountMinAggregateInputType
    _max?: MT5AccountMaxAggregateInputType
  }

  export type MT5AccountGroupByOutputType = {
    id: string
    userId: string
    accountNumber: string
    broker: string
    serverName: string
    login: string
    password: string | null
    vpsIp: string | null
    vpsPort: number | null
    status: $Enums.AccountStatus
    balance: number
    equity: number
    margin: number
    freeMargin: number
    isEnabledForTrading: boolean
    createdAt: Date
    updatedAt: Date
    lastSyncAt: Date | null
    _count: MT5AccountCountAggregateOutputType | null
    _avg: MT5AccountAvgAggregateOutputType | null
    _sum: MT5AccountSumAggregateOutputType | null
    _min: MT5AccountMinAggregateOutputType | null
    _max: MT5AccountMaxAggregateOutputType | null
  }

  type GetMT5AccountGroupByPayload<T extends MT5AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MT5AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MT5AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MT5AccountGroupByOutputType[P]>
            : GetScalarType<T[P], MT5AccountGroupByOutputType[P]>
        }
      >
    >


  export type MT5AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountNumber?: boolean
    broker?: boolean
    serverName?: boolean
    login?: boolean
    password?: boolean
    vpsIp?: boolean
    vpsPort?: boolean
    status?: boolean
    balance?: boolean
    equity?: boolean
    margin?: boolean
    freeMargin?: boolean
    isEnabledForTrading?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastSyncAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    eas?: boolean | MT5Account$easArgs<ExtArgs>
    trades?: boolean | MT5Account$tradesArgs<ExtArgs>
    _count?: boolean | MT5AccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mT5Account"]>

  export type MT5AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountNumber?: boolean
    broker?: boolean
    serverName?: boolean
    login?: boolean
    password?: boolean
    vpsIp?: boolean
    vpsPort?: boolean
    status?: boolean
    balance?: boolean
    equity?: boolean
    margin?: boolean
    freeMargin?: boolean
    isEnabledForTrading?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastSyncAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mT5Account"]>

  export type MT5AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    accountNumber?: boolean
    broker?: boolean
    serverName?: boolean
    login?: boolean
    password?: boolean
    vpsIp?: boolean
    vpsPort?: boolean
    status?: boolean
    balance?: boolean
    equity?: boolean
    margin?: boolean
    freeMargin?: boolean
    isEnabledForTrading?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastSyncAt?: boolean
  }

  export type MT5AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    eas?: boolean | MT5Account$easArgs<ExtArgs>
    trades?: boolean | MT5Account$tradesArgs<ExtArgs>
    _count?: boolean | MT5AccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MT5AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MT5AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MT5Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      eas: Prisma.$EAPayload<ExtArgs>[]
      trades: Prisma.$TradePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      accountNumber: string
      broker: string
      serverName: string
      login: string
      password: string | null
      vpsIp: string | null
      vpsPort: number | null
      status: $Enums.AccountStatus
      balance: number
      equity: number
      margin: number
      freeMargin: number
      isEnabledForTrading: boolean
      createdAt: Date
      updatedAt: Date
      lastSyncAt: Date | null
    }, ExtArgs["result"]["mT5Account"]>
    composites: {}
  }

  type MT5AccountGetPayload<S extends boolean | null | undefined | MT5AccountDefaultArgs> = $Result.GetResult<Prisma.$MT5AccountPayload, S>

  type MT5AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MT5AccountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MT5AccountCountAggregateInputType | true
    }

  export interface MT5AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MT5Account'], meta: { name: 'MT5Account' } }
    /**
     * Find zero or one MT5Account that matches the filter.
     * @param {MT5AccountFindUniqueArgs} args - Arguments to find a MT5Account
     * @example
     * // Get one MT5Account
     * const mT5Account = await prisma.mT5Account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MT5AccountFindUniqueArgs>(args: SelectSubset<T, MT5AccountFindUniqueArgs<ExtArgs>>): Prisma__MT5AccountClient<$Result.GetResult<Prisma.$MT5AccountPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MT5Account that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MT5AccountFindUniqueOrThrowArgs} args - Arguments to find a MT5Account
     * @example
     * // Get one MT5Account
     * const mT5Account = await prisma.mT5Account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MT5AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, MT5AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MT5AccountClient<$Result.GetResult<Prisma.$MT5AccountPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MT5Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MT5AccountFindFirstArgs} args - Arguments to find a MT5Account
     * @example
     * // Get one MT5Account
     * const mT5Account = await prisma.mT5Account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MT5AccountFindFirstArgs>(args?: SelectSubset<T, MT5AccountFindFirstArgs<ExtArgs>>): Prisma__MT5AccountClient<$Result.GetResult<Prisma.$MT5AccountPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MT5Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MT5AccountFindFirstOrThrowArgs} args - Arguments to find a MT5Account
     * @example
     * // Get one MT5Account
     * const mT5Account = await prisma.mT5Account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MT5AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, MT5AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__MT5AccountClient<$Result.GetResult<Prisma.$MT5AccountPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MT5Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MT5AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MT5Accounts
     * const mT5Accounts = await prisma.mT5Account.findMany()
     * 
     * // Get first 10 MT5Accounts
     * const mT5Accounts = await prisma.mT5Account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mT5AccountWithIdOnly = await prisma.mT5Account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MT5AccountFindManyArgs>(args?: SelectSubset<T, MT5AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MT5AccountPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MT5Account.
     * @param {MT5AccountCreateArgs} args - Arguments to create a MT5Account.
     * @example
     * // Create one MT5Account
     * const MT5Account = await prisma.mT5Account.create({
     *   data: {
     *     // ... data to create a MT5Account
     *   }
     * })
     * 
     */
    create<T extends MT5AccountCreateArgs>(args: SelectSubset<T, MT5AccountCreateArgs<ExtArgs>>): Prisma__MT5AccountClient<$Result.GetResult<Prisma.$MT5AccountPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MT5Accounts.
     * @param {MT5AccountCreateManyArgs} args - Arguments to create many MT5Accounts.
     * @example
     * // Create many MT5Accounts
     * const mT5Account = await prisma.mT5Account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MT5AccountCreateManyArgs>(args?: SelectSubset<T, MT5AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MT5Accounts and returns the data saved in the database.
     * @param {MT5AccountCreateManyAndReturnArgs} args - Arguments to create many MT5Accounts.
     * @example
     * // Create many MT5Accounts
     * const mT5Account = await prisma.mT5Account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MT5Accounts and only return the `id`
     * const mT5AccountWithIdOnly = await prisma.mT5Account.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MT5AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, MT5AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MT5AccountPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MT5Account.
     * @param {MT5AccountDeleteArgs} args - Arguments to delete one MT5Account.
     * @example
     * // Delete one MT5Account
     * const MT5Account = await prisma.mT5Account.delete({
     *   where: {
     *     // ... filter to delete one MT5Account
     *   }
     * })
     * 
     */
    delete<T extends MT5AccountDeleteArgs>(args: SelectSubset<T, MT5AccountDeleteArgs<ExtArgs>>): Prisma__MT5AccountClient<$Result.GetResult<Prisma.$MT5AccountPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MT5Account.
     * @param {MT5AccountUpdateArgs} args - Arguments to update one MT5Account.
     * @example
     * // Update one MT5Account
     * const mT5Account = await prisma.mT5Account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MT5AccountUpdateArgs>(args: SelectSubset<T, MT5AccountUpdateArgs<ExtArgs>>): Prisma__MT5AccountClient<$Result.GetResult<Prisma.$MT5AccountPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MT5Accounts.
     * @param {MT5AccountDeleteManyArgs} args - Arguments to filter MT5Accounts to delete.
     * @example
     * // Delete a few MT5Accounts
     * const { count } = await prisma.mT5Account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MT5AccountDeleteManyArgs>(args?: SelectSubset<T, MT5AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MT5Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MT5AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MT5Accounts
     * const mT5Account = await prisma.mT5Account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MT5AccountUpdateManyArgs>(args: SelectSubset<T, MT5AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MT5Account.
     * @param {MT5AccountUpsertArgs} args - Arguments to update or create a MT5Account.
     * @example
     * // Update or create a MT5Account
     * const mT5Account = await prisma.mT5Account.upsert({
     *   create: {
     *     // ... data to create a MT5Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MT5Account we want to update
     *   }
     * })
     */
    upsert<T extends MT5AccountUpsertArgs>(args: SelectSubset<T, MT5AccountUpsertArgs<ExtArgs>>): Prisma__MT5AccountClient<$Result.GetResult<Prisma.$MT5AccountPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MT5Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MT5AccountCountArgs} args - Arguments to filter MT5Accounts to count.
     * @example
     * // Count the number of MT5Accounts
     * const count = await prisma.mT5Account.count({
     *   where: {
     *     // ... the filter for the MT5Accounts we want to count
     *   }
     * })
    **/
    count<T extends MT5AccountCountArgs>(
      args?: Subset<T, MT5AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MT5AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MT5Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MT5AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MT5AccountAggregateArgs>(args: Subset<T, MT5AccountAggregateArgs>): Prisma.PrismaPromise<GetMT5AccountAggregateType<T>>

    /**
     * Group by MT5Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MT5AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MT5AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MT5AccountGroupByArgs['orderBy'] }
        : { orderBy?: MT5AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MT5AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMT5AccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MT5Account model
   */
  readonly fields: MT5AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MT5Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MT5AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    eas<T extends MT5Account$easArgs<ExtArgs> = {}>(args?: Subset<T, MT5Account$easArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EAPayload<ExtArgs>, T, "findMany"> | Null>
    trades<T extends MT5Account$tradesArgs<ExtArgs> = {}>(args?: Subset<T, MT5Account$tradesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MT5Account model
   */ 
  interface MT5AccountFieldRefs {
    readonly id: FieldRef<"MT5Account", 'String'>
    readonly userId: FieldRef<"MT5Account", 'String'>
    readonly accountNumber: FieldRef<"MT5Account", 'String'>
    readonly broker: FieldRef<"MT5Account", 'String'>
    readonly serverName: FieldRef<"MT5Account", 'String'>
    readonly login: FieldRef<"MT5Account", 'String'>
    readonly password: FieldRef<"MT5Account", 'String'>
    readonly vpsIp: FieldRef<"MT5Account", 'String'>
    readonly vpsPort: FieldRef<"MT5Account", 'Int'>
    readonly status: FieldRef<"MT5Account", 'AccountStatus'>
    readonly balance: FieldRef<"MT5Account", 'Float'>
    readonly equity: FieldRef<"MT5Account", 'Float'>
    readonly margin: FieldRef<"MT5Account", 'Float'>
    readonly freeMargin: FieldRef<"MT5Account", 'Float'>
    readonly isEnabledForTrading: FieldRef<"MT5Account", 'Boolean'>
    readonly createdAt: FieldRef<"MT5Account", 'DateTime'>
    readonly updatedAt: FieldRef<"MT5Account", 'DateTime'>
    readonly lastSyncAt: FieldRef<"MT5Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MT5Account findUnique
   */
  export type MT5AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Account
     */
    select?: MT5AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5AccountInclude<ExtArgs> | null
    /**
     * Filter, which MT5Account to fetch.
     */
    where: MT5AccountWhereUniqueInput
  }

  /**
   * MT5Account findUniqueOrThrow
   */
  export type MT5AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Account
     */
    select?: MT5AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5AccountInclude<ExtArgs> | null
    /**
     * Filter, which MT5Account to fetch.
     */
    where: MT5AccountWhereUniqueInput
  }

  /**
   * MT5Account findFirst
   */
  export type MT5AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Account
     */
    select?: MT5AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5AccountInclude<ExtArgs> | null
    /**
     * Filter, which MT5Account to fetch.
     */
    where?: MT5AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MT5Accounts to fetch.
     */
    orderBy?: MT5AccountOrderByWithRelationInput | MT5AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MT5Accounts.
     */
    cursor?: MT5AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MT5Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MT5Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MT5Accounts.
     */
    distinct?: MT5AccountScalarFieldEnum | MT5AccountScalarFieldEnum[]
  }

  /**
   * MT5Account findFirstOrThrow
   */
  export type MT5AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Account
     */
    select?: MT5AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5AccountInclude<ExtArgs> | null
    /**
     * Filter, which MT5Account to fetch.
     */
    where?: MT5AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MT5Accounts to fetch.
     */
    orderBy?: MT5AccountOrderByWithRelationInput | MT5AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MT5Accounts.
     */
    cursor?: MT5AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MT5Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MT5Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MT5Accounts.
     */
    distinct?: MT5AccountScalarFieldEnum | MT5AccountScalarFieldEnum[]
  }

  /**
   * MT5Account findMany
   */
  export type MT5AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Account
     */
    select?: MT5AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5AccountInclude<ExtArgs> | null
    /**
     * Filter, which MT5Accounts to fetch.
     */
    where?: MT5AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MT5Accounts to fetch.
     */
    orderBy?: MT5AccountOrderByWithRelationInput | MT5AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MT5Accounts.
     */
    cursor?: MT5AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MT5Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MT5Accounts.
     */
    skip?: number
    distinct?: MT5AccountScalarFieldEnum | MT5AccountScalarFieldEnum[]
  }

  /**
   * MT5Account create
   */
  export type MT5AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Account
     */
    select?: MT5AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a MT5Account.
     */
    data: XOR<MT5AccountCreateInput, MT5AccountUncheckedCreateInput>
  }

  /**
   * MT5Account createMany
   */
  export type MT5AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MT5Accounts.
     */
    data: MT5AccountCreateManyInput | MT5AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MT5Account createManyAndReturn
   */
  export type MT5AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Account
     */
    select?: MT5AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MT5Accounts.
     */
    data: MT5AccountCreateManyInput | MT5AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MT5Account update
   */
  export type MT5AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Account
     */
    select?: MT5AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a MT5Account.
     */
    data: XOR<MT5AccountUpdateInput, MT5AccountUncheckedUpdateInput>
    /**
     * Choose, which MT5Account to update.
     */
    where: MT5AccountWhereUniqueInput
  }

  /**
   * MT5Account updateMany
   */
  export type MT5AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MT5Accounts.
     */
    data: XOR<MT5AccountUpdateManyMutationInput, MT5AccountUncheckedUpdateManyInput>
    /**
     * Filter which MT5Accounts to update
     */
    where?: MT5AccountWhereInput
  }

  /**
   * MT5Account upsert
   */
  export type MT5AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Account
     */
    select?: MT5AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the MT5Account to update in case it exists.
     */
    where: MT5AccountWhereUniqueInput
    /**
     * In case the MT5Account found by the `where` argument doesn't exist, create a new MT5Account with this data.
     */
    create: XOR<MT5AccountCreateInput, MT5AccountUncheckedCreateInput>
    /**
     * In case the MT5Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MT5AccountUpdateInput, MT5AccountUncheckedUpdateInput>
  }

  /**
   * MT5Account delete
   */
  export type MT5AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Account
     */
    select?: MT5AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5AccountInclude<ExtArgs> | null
    /**
     * Filter which MT5Account to delete.
     */
    where: MT5AccountWhereUniqueInput
  }

  /**
   * MT5Account deleteMany
   */
  export type MT5AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MT5Accounts to delete
     */
    where?: MT5AccountWhereInput
  }

  /**
   * MT5Account.eas
   */
  export type MT5Account$easArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EA
     */
    select?: EASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EAInclude<ExtArgs> | null
    where?: EAWhereInput
    orderBy?: EAOrderByWithRelationInput | EAOrderByWithRelationInput[]
    cursor?: EAWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EAScalarFieldEnum | EAScalarFieldEnum[]
  }

  /**
   * MT5Account.trades
   */
  export type MT5Account$tradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trade
     */
    select?: TradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeInclude<ExtArgs> | null
    where?: TradeWhereInput
    orderBy?: TradeOrderByWithRelationInput | TradeOrderByWithRelationInput[]
    cursor?: TradeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TradeScalarFieldEnum | TradeScalarFieldEnum[]
  }

  /**
   * MT5Account without action
   */
  export type MT5AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Account
     */
    select?: MT5AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5AccountInclude<ExtArgs> | null
  }


  /**
   * Model EA
   */

  export type AggregateEA = {
    _count: EACountAggregateOutputType | null
    _avg: EAAvgAggregateOutputType | null
    _sum: EASumAggregateOutputType | null
    _min: EAMinAggregateOutputType | null
    _max: EAMaxAggregateOutputType | null
  }

  export type EAAvgAggregateOutputType = {
    magicNumber: number | null
    indicatorScore: number | null
    maxLotSize: number | null
    riskPercent: number | null
    uptime: number | null
    totalTrades: number | null
    winningTrades: number | null
    totalProfit: number | null
  }

  export type EASumAggregateOutputType = {
    magicNumber: number | null
    indicatorScore: number | null
    maxLotSize: number | null
    riskPercent: number | null
    uptime: number | null
    totalTrades: number | null
    winningTrades: number | null
    totalProfit: number | null
  }

  export type EAMinAggregateOutputType = {
    id: string | null
    userId: string | null
    mt5AccountId: string | null
    name: string | null
    version: string | null
    magicNumber: number | null
    status: $Enums.EAStatus | null
    safetyIndicator: $Enums.SafetyIndicator | null
    indicatorScore: number | null
    stoppedByIndicator: boolean | null
    stoppedByIndicatorAt: Date | null
    maxLotSize: number | null
    riskPercent: number | null
    lastStartAt: Date | null
    lastStopAt: Date | null
    uptime: number | null
    totalTrades: number | null
    winningTrades: number | null
    totalProfit: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EAMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    mt5AccountId: string | null
    name: string | null
    version: string | null
    magicNumber: number | null
    status: $Enums.EAStatus | null
    safetyIndicator: $Enums.SafetyIndicator | null
    indicatorScore: number | null
    stoppedByIndicator: boolean | null
    stoppedByIndicatorAt: Date | null
    maxLotSize: number | null
    riskPercent: number | null
    lastStartAt: Date | null
    lastStopAt: Date | null
    uptime: number | null
    totalTrades: number | null
    winningTrades: number | null
    totalProfit: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EACountAggregateOutputType = {
    id: number
    userId: number
    mt5AccountId: number
    name: number
    version: number
    magicNumber: number
    status: number
    safetyIndicator: number
    indicatorScore: number
    stoppedByIndicator: number
    stoppedByIndicatorAt: number
    maxLotSize: number
    riskPercent: number
    settings: number
    lastStartAt: number
    lastStopAt: number
    uptime: number
    totalTrades: number
    winningTrades: number
    totalProfit: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EAAvgAggregateInputType = {
    magicNumber?: true
    indicatorScore?: true
    maxLotSize?: true
    riskPercent?: true
    uptime?: true
    totalTrades?: true
    winningTrades?: true
    totalProfit?: true
  }

  export type EASumAggregateInputType = {
    magicNumber?: true
    indicatorScore?: true
    maxLotSize?: true
    riskPercent?: true
    uptime?: true
    totalTrades?: true
    winningTrades?: true
    totalProfit?: true
  }

  export type EAMinAggregateInputType = {
    id?: true
    userId?: true
    mt5AccountId?: true
    name?: true
    version?: true
    magicNumber?: true
    status?: true
    safetyIndicator?: true
    indicatorScore?: true
    stoppedByIndicator?: true
    stoppedByIndicatorAt?: true
    maxLotSize?: true
    riskPercent?: true
    lastStartAt?: true
    lastStopAt?: true
    uptime?: true
    totalTrades?: true
    winningTrades?: true
    totalProfit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EAMaxAggregateInputType = {
    id?: true
    userId?: true
    mt5AccountId?: true
    name?: true
    version?: true
    magicNumber?: true
    status?: true
    safetyIndicator?: true
    indicatorScore?: true
    stoppedByIndicator?: true
    stoppedByIndicatorAt?: true
    maxLotSize?: true
    riskPercent?: true
    lastStartAt?: true
    lastStopAt?: true
    uptime?: true
    totalTrades?: true
    winningTrades?: true
    totalProfit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EACountAggregateInputType = {
    id?: true
    userId?: true
    mt5AccountId?: true
    name?: true
    version?: true
    magicNumber?: true
    status?: true
    safetyIndicator?: true
    indicatorScore?: true
    stoppedByIndicator?: true
    stoppedByIndicatorAt?: true
    maxLotSize?: true
    riskPercent?: true
    settings?: true
    lastStartAt?: true
    lastStopAt?: true
    uptime?: true
    totalTrades?: true
    winningTrades?: true
    totalProfit?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EAAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EA to aggregate.
     */
    where?: EAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EAS to fetch.
     */
    orderBy?: EAOrderByWithRelationInput | EAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EAS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EAS
    **/
    _count?: true | EACountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EAAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EASumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EAMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EAMaxAggregateInputType
  }

  export type GetEAAggregateType<T extends EAAggregateArgs> = {
        [P in keyof T & keyof AggregateEA]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEA[P]>
      : GetScalarType<T[P], AggregateEA[P]>
  }




  export type EAGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EAWhereInput
    orderBy?: EAOrderByWithAggregationInput | EAOrderByWithAggregationInput[]
    by: EAScalarFieldEnum[] | EAScalarFieldEnum
    having?: EAScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EACountAggregateInputType | true
    _avg?: EAAvgAggregateInputType
    _sum?: EASumAggregateInputType
    _min?: EAMinAggregateInputType
    _max?: EAMaxAggregateInputType
  }

  export type EAGroupByOutputType = {
    id: string
    userId: string
    mt5AccountId: string
    name: string
    version: string | null
    magicNumber: number | null
    status: $Enums.EAStatus
    safetyIndicator: $Enums.SafetyIndicator
    indicatorScore: number
    stoppedByIndicator: boolean
    stoppedByIndicatorAt: Date | null
    maxLotSize: number
    riskPercent: number
    settings: JsonValue | null
    lastStartAt: Date | null
    lastStopAt: Date | null
    uptime: number
    totalTrades: number
    winningTrades: number
    totalProfit: number
    createdAt: Date
    updatedAt: Date
    _count: EACountAggregateOutputType | null
    _avg: EAAvgAggregateOutputType | null
    _sum: EASumAggregateOutputType | null
    _min: EAMinAggregateOutputType | null
    _max: EAMaxAggregateOutputType | null
  }

  type GetEAGroupByPayload<T extends EAGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EAGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EAGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EAGroupByOutputType[P]>
            : GetScalarType<T[P], EAGroupByOutputType[P]>
        }
      >
    >


  export type EASelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    mt5AccountId?: boolean
    name?: boolean
    version?: boolean
    magicNumber?: boolean
    status?: boolean
    safetyIndicator?: boolean
    indicatorScore?: boolean
    stoppedByIndicator?: boolean
    stoppedByIndicatorAt?: boolean
    maxLotSize?: boolean
    riskPercent?: boolean
    settings?: boolean
    lastStartAt?: boolean
    lastStopAt?: boolean
    uptime?: boolean
    totalTrades?: boolean
    winningTrades?: boolean
    totalProfit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    mt5Account?: boolean | MT5AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eA"]>

  export type EASelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    mt5AccountId?: boolean
    name?: boolean
    version?: boolean
    magicNumber?: boolean
    status?: boolean
    safetyIndicator?: boolean
    indicatorScore?: boolean
    stoppedByIndicator?: boolean
    stoppedByIndicatorAt?: boolean
    maxLotSize?: boolean
    riskPercent?: boolean
    settings?: boolean
    lastStartAt?: boolean
    lastStopAt?: boolean
    uptime?: boolean
    totalTrades?: boolean
    winningTrades?: boolean
    totalProfit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    mt5Account?: boolean | MT5AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eA"]>

  export type EASelectScalar = {
    id?: boolean
    userId?: boolean
    mt5AccountId?: boolean
    name?: boolean
    version?: boolean
    magicNumber?: boolean
    status?: boolean
    safetyIndicator?: boolean
    indicatorScore?: boolean
    stoppedByIndicator?: boolean
    stoppedByIndicatorAt?: boolean
    maxLotSize?: boolean
    riskPercent?: boolean
    settings?: boolean
    lastStartAt?: boolean
    lastStopAt?: boolean
    uptime?: boolean
    totalTrades?: boolean
    winningTrades?: boolean
    totalProfit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EAInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    mt5Account?: boolean | MT5AccountDefaultArgs<ExtArgs>
  }
  export type EAIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    mt5Account?: boolean | MT5AccountDefaultArgs<ExtArgs>
  }

  export type $EAPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EA"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      mt5Account: Prisma.$MT5AccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      mt5AccountId: string
      name: string
      version: string | null
      magicNumber: number | null
      status: $Enums.EAStatus
      safetyIndicator: $Enums.SafetyIndicator
      indicatorScore: number
      stoppedByIndicator: boolean
      stoppedByIndicatorAt: Date | null
      maxLotSize: number
      riskPercent: number
      settings: Prisma.JsonValue | null
      lastStartAt: Date | null
      lastStopAt: Date | null
      uptime: number
      totalTrades: number
      winningTrades: number
      totalProfit: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["eA"]>
    composites: {}
  }

  type EAGetPayload<S extends boolean | null | undefined | EADefaultArgs> = $Result.GetResult<Prisma.$EAPayload, S>

  type EACountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EAFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EACountAggregateInputType | true
    }

  export interface EADelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EA'], meta: { name: 'EA' } }
    /**
     * Find zero or one EA that matches the filter.
     * @param {EAFindUniqueArgs} args - Arguments to find a EA
     * @example
     * // Get one EA
     * const eA = await prisma.eA.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EAFindUniqueArgs>(args: SelectSubset<T, EAFindUniqueArgs<ExtArgs>>): Prisma__EAClient<$Result.GetResult<Prisma.$EAPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EA that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EAFindUniqueOrThrowArgs} args - Arguments to find a EA
     * @example
     * // Get one EA
     * const eA = await prisma.eA.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EAFindUniqueOrThrowArgs>(args: SelectSubset<T, EAFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EAClient<$Result.GetResult<Prisma.$EAPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EA that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EAFindFirstArgs} args - Arguments to find a EA
     * @example
     * // Get one EA
     * const eA = await prisma.eA.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EAFindFirstArgs>(args?: SelectSubset<T, EAFindFirstArgs<ExtArgs>>): Prisma__EAClient<$Result.GetResult<Prisma.$EAPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EA that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EAFindFirstOrThrowArgs} args - Arguments to find a EA
     * @example
     * // Get one EA
     * const eA = await prisma.eA.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EAFindFirstOrThrowArgs>(args?: SelectSubset<T, EAFindFirstOrThrowArgs<ExtArgs>>): Prisma__EAClient<$Result.GetResult<Prisma.$EAPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EAS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EAFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EAS
     * const eAS = await prisma.eA.findMany()
     * 
     * // Get first 10 EAS
     * const eAS = await prisma.eA.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eAWithIdOnly = await prisma.eA.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EAFindManyArgs>(args?: SelectSubset<T, EAFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EAPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EA.
     * @param {EACreateArgs} args - Arguments to create a EA.
     * @example
     * // Create one EA
     * const EA = await prisma.eA.create({
     *   data: {
     *     // ... data to create a EA
     *   }
     * })
     * 
     */
    create<T extends EACreateArgs>(args: SelectSubset<T, EACreateArgs<ExtArgs>>): Prisma__EAClient<$Result.GetResult<Prisma.$EAPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EAS.
     * @param {EACreateManyArgs} args - Arguments to create many EAS.
     * @example
     * // Create many EAS
     * const eA = await prisma.eA.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EACreateManyArgs>(args?: SelectSubset<T, EACreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EAS and returns the data saved in the database.
     * @param {EACreateManyAndReturnArgs} args - Arguments to create many EAS.
     * @example
     * // Create many EAS
     * const eA = await prisma.eA.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EAS and only return the `id`
     * const eAWithIdOnly = await prisma.eA.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EACreateManyAndReturnArgs>(args?: SelectSubset<T, EACreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EAPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EA.
     * @param {EADeleteArgs} args - Arguments to delete one EA.
     * @example
     * // Delete one EA
     * const EA = await prisma.eA.delete({
     *   where: {
     *     // ... filter to delete one EA
     *   }
     * })
     * 
     */
    delete<T extends EADeleteArgs>(args: SelectSubset<T, EADeleteArgs<ExtArgs>>): Prisma__EAClient<$Result.GetResult<Prisma.$EAPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EA.
     * @param {EAUpdateArgs} args - Arguments to update one EA.
     * @example
     * // Update one EA
     * const eA = await prisma.eA.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EAUpdateArgs>(args: SelectSubset<T, EAUpdateArgs<ExtArgs>>): Prisma__EAClient<$Result.GetResult<Prisma.$EAPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EAS.
     * @param {EADeleteManyArgs} args - Arguments to filter EAS to delete.
     * @example
     * // Delete a few EAS
     * const { count } = await prisma.eA.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EADeleteManyArgs>(args?: SelectSubset<T, EADeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EAS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EAUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EAS
     * const eA = await prisma.eA.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EAUpdateManyArgs>(args: SelectSubset<T, EAUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EA.
     * @param {EAUpsertArgs} args - Arguments to update or create a EA.
     * @example
     * // Update or create a EA
     * const eA = await prisma.eA.upsert({
     *   create: {
     *     // ... data to create a EA
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EA we want to update
     *   }
     * })
     */
    upsert<T extends EAUpsertArgs>(args: SelectSubset<T, EAUpsertArgs<ExtArgs>>): Prisma__EAClient<$Result.GetResult<Prisma.$EAPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EAS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EACountArgs} args - Arguments to filter EAS to count.
     * @example
     * // Count the number of EAS
     * const count = await prisma.eA.count({
     *   where: {
     *     // ... the filter for the EAS we want to count
     *   }
     * })
    **/
    count<T extends EACountArgs>(
      args?: Subset<T, EACountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EACountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EA.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EAAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EAAggregateArgs>(args: Subset<T, EAAggregateArgs>): Prisma.PrismaPromise<GetEAAggregateType<T>>

    /**
     * Group by EA.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EAGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EAGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EAGroupByArgs['orderBy'] }
        : { orderBy?: EAGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EAGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEAGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EA model
   */
  readonly fields: EAFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EA.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EAClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    mt5Account<T extends MT5AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MT5AccountDefaultArgs<ExtArgs>>): Prisma__MT5AccountClient<$Result.GetResult<Prisma.$MT5AccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EA model
   */ 
  interface EAFieldRefs {
    readonly id: FieldRef<"EA", 'String'>
    readonly userId: FieldRef<"EA", 'String'>
    readonly mt5AccountId: FieldRef<"EA", 'String'>
    readonly name: FieldRef<"EA", 'String'>
    readonly version: FieldRef<"EA", 'String'>
    readonly magicNumber: FieldRef<"EA", 'Int'>
    readonly status: FieldRef<"EA", 'EAStatus'>
    readonly safetyIndicator: FieldRef<"EA", 'SafetyIndicator'>
    readonly indicatorScore: FieldRef<"EA", 'Float'>
    readonly stoppedByIndicator: FieldRef<"EA", 'Boolean'>
    readonly stoppedByIndicatorAt: FieldRef<"EA", 'DateTime'>
    readonly maxLotSize: FieldRef<"EA", 'Float'>
    readonly riskPercent: FieldRef<"EA", 'Float'>
    readonly settings: FieldRef<"EA", 'Json'>
    readonly lastStartAt: FieldRef<"EA", 'DateTime'>
    readonly lastStopAt: FieldRef<"EA", 'DateTime'>
    readonly uptime: FieldRef<"EA", 'Int'>
    readonly totalTrades: FieldRef<"EA", 'Int'>
    readonly winningTrades: FieldRef<"EA", 'Int'>
    readonly totalProfit: FieldRef<"EA", 'Float'>
    readonly createdAt: FieldRef<"EA", 'DateTime'>
    readonly updatedAt: FieldRef<"EA", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EA findUnique
   */
  export type EAFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EA
     */
    select?: EASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EAInclude<ExtArgs> | null
    /**
     * Filter, which EA to fetch.
     */
    where: EAWhereUniqueInput
  }

  /**
   * EA findUniqueOrThrow
   */
  export type EAFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EA
     */
    select?: EASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EAInclude<ExtArgs> | null
    /**
     * Filter, which EA to fetch.
     */
    where: EAWhereUniqueInput
  }

  /**
   * EA findFirst
   */
  export type EAFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EA
     */
    select?: EASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EAInclude<ExtArgs> | null
    /**
     * Filter, which EA to fetch.
     */
    where?: EAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EAS to fetch.
     */
    orderBy?: EAOrderByWithRelationInput | EAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EAS.
     */
    cursor?: EAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EAS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EAS.
     */
    distinct?: EAScalarFieldEnum | EAScalarFieldEnum[]
  }

  /**
   * EA findFirstOrThrow
   */
  export type EAFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EA
     */
    select?: EASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EAInclude<ExtArgs> | null
    /**
     * Filter, which EA to fetch.
     */
    where?: EAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EAS to fetch.
     */
    orderBy?: EAOrderByWithRelationInput | EAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EAS.
     */
    cursor?: EAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EAS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EAS.
     */
    distinct?: EAScalarFieldEnum | EAScalarFieldEnum[]
  }

  /**
   * EA findMany
   */
  export type EAFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EA
     */
    select?: EASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EAInclude<ExtArgs> | null
    /**
     * Filter, which EAS to fetch.
     */
    where?: EAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EAS to fetch.
     */
    orderBy?: EAOrderByWithRelationInput | EAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EAS.
     */
    cursor?: EAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EAS.
     */
    skip?: number
    distinct?: EAScalarFieldEnum | EAScalarFieldEnum[]
  }

  /**
   * EA create
   */
  export type EACreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EA
     */
    select?: EASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EAInclude<ExtArgs> | null
    /**
     * The data needed to create a EA.
     */
    data: XOR<EACreateInput, EAUncheckedCreateInput>
  }

  /**
   * EA createMany
   */
  export type EACreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EAS.
     */
    data: EACreateManyInput | EACreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EA createManyAndReturn
   */
  export type EACreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EA
     */
    select?: EASelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EAS.
     */
    data: EACreateManyInput | EACreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EAIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EA update
   */
  export type EAUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EA
     */
    select?: EASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EAInclude<ExtArgs> | null
    /**
     * The data needed to update a EA.
     */
    data: XOR<EAUpdateInput, EAUncheckedUpdateInput>
    /**
     * Choose, which EA to update.
     */
    where: EAWhereUniqueInput
  }

  /**
   * EA updateMany
   */
  export type EAUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EAS.
     */
    data: XOR<EAUpdateManyMutationInput, EAUncheckedUpdateManyInput>
    /**
     * Filter which EAS to update
     */
    where?: EAWhereInput
  }

  /**
   * EA upsert
   */
  export type EAUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EA
     */
    select?: EASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EAInclude<ExtArgs> | null
    /**
     * The filter to search for the EA to update in case it exists.
     */
    where: EAWhereUniqueInput
    /**
     * In case the EA found by the `where` argument doesn't exist, create a new EA with this data.
     */
    create: XOR<EACreateInput, EAUncheckedCreateInput>
    /**
     * In case the EA was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EAUpdateInput, EAUncheckedUpdateInput>
  }

  /**
   * EA delete
   */
  export type EADeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EA
     */
    select?: EASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EAInclude<ExtArgs> | null
    /**
     * Filter which EA to delete.
     */
    where: EAWhereUniqueInput
  }

  /**
   * EA deleteMany
   */
  export type EADeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EAS to delete
     */
    where?: EAWhereInput
  }

  /**
   * EA without action
   */
  export type EADefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EA
     */
    select?: EASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EAInclude<ExtArgs> | null
  }


  /**
   * Model Trade
   */

  export type AggregateTrade = {
    _count: TradeCountAggregateOutputType | null
    _avg: TradeAvgAggregateOutputType | null
    _sum: TradeSumAggregateOutputType | null
    _min: TradeMinAggregateOutputType | null
    _max: TradeMaxAggregateOutputType | null
  }

  export type TradeAvgAggregateOutputType = {
    volume: number | null
    openPrice: number | null
    closePrice: number | null
    profit: number | null
    commission: number | null
    swap: number | null
    magicNumber: number | null
  }

  export type TradeSumAggregateOutputType = {
    volume: number | null
    openPrice: number | null
    closePrice: number | null
    profit: number | null
    commission: number | null
    swap: number | null
    magicNumber: number | null
  }

  export type TradeMinAggregateOutputType = {
    id: string | null
    userId: string | null
    mt5AccountId: string | null
    ticket: string | null
    symbol: string | null
    type: string | null
    volume: number | null
    openPrice: number | null
    openTime: Date | null
    closePrice: number | null
    closeTime: Date | null
    profit: number | null
    commission: number | null
    swap: number | null
    magicNumber: number | null
    comment: string | null
    isClosed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TradeMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    mt5AccountId: string | null
    ticket: string | null
    symbol: string | null
    type: string | null
    volume: number | null
    openPrice: number | null
    openTime: Date | null
    closePrice: number | null
    closeTime: Date | null
    profit: number | null
    commission: number | null
    swap: number | null
    magicNumber: number | null
    comment: string | null
    isClosed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TradeCountAggregateOutputType = {
    id: number
    userId: number
    mt5AccountId: number
    ticket: number
    symbol: number
    type: number
    volume: number
    openPrice: number
    openTime: number
    closePrice: number
    closeTime: number
    profit: number
    commission: number
    swap: number
    magicNumber: number
    comment: number
    isClosed: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TradeAvgAggregateInputType = {
    volume?: true
    openPrice?: true
    closePrice?: true
    profit?: true
    commission?: true
    swap?: true
    magicNumber?: true
  }

  export type TradeSumAggregateInputType = {
    volume?: true
    openPrice?: true
    closePrice?: true
    profit?: true
    commission?: true
    swap?: true
    magicNumber?: true
  }

  export type TradeMinAggregateInputType = {
    id?: true
    userId?: true
    mt5AccountId?: true
    ticket?: true
    symbol?: true
    type?: true
    volume?: true
    openPrice?: true
    openTime?: true
    closePrice?: true
    closeTime?: true
    profit?: true
    commission?: true
    swap?: true
    magicNumber?: true
    comment?: true
    isClosed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TradeMaxAggregateInputType = {
    id?: true
    userId?: true
    mt5AccountId?: true
    ticket?: true
    symbol?: true
    type?: true
    volume?: true
    openPrice?: true
    openTime?: true
    closePrice?: true
    closeTime?: true
    profit?: true
    commission?: true
    swap?: true
    magicNumber?: true
    comment?: true
    isClosed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TradeCountAggregateInputType = {
    id?: true
    userId?: true
    mt5AccountId?: true
    ticket?: true
    symbol?: true
    type?: true
    volume?: true
    openPrice?: true
    openTime?: true
    closePrice?: true
    closeTime?: true
    profit?: true
    commission?: true
    swap?: true
    magicNumber?: true
    comment?: true
    isClosed?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TradeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trade to aggregate.
     */
    where?: TradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trades to fetch.
     */
    orderBy?: TradeOrderByWithRelationInput | TradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Trades
    **/
    _count?: true | TradeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TradeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TradeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TradeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TradeMaxAggregateInputType
  }

  export type GetTradeAggregateType<T extends TradeAggregateArgs> = {
        [P in keyof T & keyof AggregateTrade]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrade[P]>
      : GetScalarType<T[P], AggregateTrade[P]>
  }




  export type TradeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TradeWhereInput
    orderBy?: TradeOrderByWithAggregationInput | TradeOrderByWithAggregationInput[]
    by: TradeScalarFieldEnum[] | TradeScalarFieldEnum
    having?: TradeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TradeCountAggregateInputType | true
    _avg?: TradeAvgAggregateInputType
    _sum?: TradeSumAggregateInputType
    _min?: TradeMinAggregateInputType
    _max?: TradeMaxAggregateInputType
  }

  export type TradeGroupByOutputType = {
    id: string
    userId: string
    mt5AccountId: string
    ticket: string
    symbol: string
    type: string
    volume: number
    openPrice: number
    openTime: Date
    closePrice: number | null
    closeTime: Date | null
    profit: number
    commission: number
    swap: number
    magicNumber: number | null
    comment: string | null
    isClosed: boolean
    createdAt: Date
    updatedAt: Date
    _count: TradeCountAggregateOutputType | null
    _avg: TradeAvgAggregateOutputType | null
    _sum: TradeSumAggregateOutputType | null
    _min: TradeMinAggregateOutputType | null
    _max: TradeMaxAggregateOutputType | null
  }

  type GetTradeGroupByPayload<T extends TradeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TradeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TradeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TradeGroupByOutputType[P]>
            : GetScalarType<T[P], TradeGroupByOutputType[P]>
        }
      >
    >


  export type TradeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    mt5AccountId?: boolean
    ticket?: boolean
    symbol?: boolean
    type?: boolean
    volume?: boolean
    openPrice?: boolean
    openTime?: boolean
    closePrice?: boolean
    closeTime?: boolean
    profit?: boolean
    commission?: boolean
    swap?: boolean
    magicNumber?: boolean
    comment?: boolean
    isClosed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    mt5Account?: boolean | MT5AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trade"]>

  export type TradeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    mt5AccountId?: boolean
    ticket?: boolean
    symbol?: boolean
    type?: boolean
    volume?: boolean
    openPrice?: boolean
    openTime?: boolean
    closePrice?: boolean
    closeTime?: boolean
    profit?: boolean
    commission?: boolean
    swap?: boolean
    magicNumber?: boolean
    comment?: boolean
    isClosed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    mt5Account?: boolean | MT5AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trade"]>

  export type TradeSelectScalar = {
    id?: boolean
    userId?: boolean
    mt5AccountId?: boolean
    ticket?: boolean
    symbol?: boolean
    type?: boolean
    volume?: boolean
    openPrice?: boolean
    openTime?: boolean
    closePrice?: boolean
    closeTime?: boolean
    profit?: boolean
    commission?: boolean
    swap?: boolean
    magicNumber?: boolean
    comment?: boolean
    isClosed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TradeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    mt5Account?: boolean | MT5AccountDefaultArgs<ExtArgs>
  }
  export type TradeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    mt5Account?: boolean | MT5AccountDefaultArgs<ExtArgs>
  }

  export type $TradePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Trade"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      mt5Account: Prisma.$MT5AccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      mt5AccountId: string
      ticket: string
      symbol: string
      type: string
      volume: number
      openPrice: number
      openTime: Date
      closePrice: number | null
      closeTime: Date | null
      profit: number
      commission: number
      swap: number
      magicNumber: number | null
      comment: string | null
      isClosed: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["trade"]>
    composites: {}
  }

  type TradeGetPayload<S extends boolean | null | undefined | TradeDefaultArgs> = $Result.GetResult<Prisma.$TradePayload, S>

  type TradeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TradeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TradeCountAggregateInputType | true
    }

  export interface TradeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Trade'], meta: { name: 'Trade' } }
    /**
     * Find zero or one Trade that matches the filter.
     * @param {TradeFindUniqueArgs} args - Arguments to find a Trade
     * @example
     * // Get one Trade
     * const trade = await prisma.trade.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TradeFindUniqueArgs>(args: SelectSubset<T, TradeFindUniqueArgs<ExtArgs>>): Prisma__TradeClient<$Result.GetResult<Prisma.$TradePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Trade that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TradeFindUniqueOrThrowArgs} args - Arguments to find a Trade
     * @example
     * // Get one Trade
     * const trade = await prisma.trade.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TradeFindUniqueOrThrowArgs>(args: SelectSubset<T, TradeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TradeClient<$Result.GetResult<Prisma.$TradePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Trade that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeFindFirstArgs} args - Arguments to find a Trade
     * @example
     * // Get one Trade
     * const trade = await prisma.trade.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TradeFindFirstArgs>(args?: SelectSubset<T, TradeFindFirstArgs<ExtArgs>>): Prisma__TradeClient<$Result.GetResult<Prisma.$TradePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Trade that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeFindFirstOrThrowArgs} args - Arguments to find a Trade
     * @example
     * // Get one Trade
     * const trade = await prisma.trade.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TradeFindFirstOrThrowArgs>(args?: SelectSubset<T, TradeFindFirstOrThrowArgs<ExtArgs>>): Prisma__TradeClient<$Result.GetResult<Prisma.$TradePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Trades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Trades
     * const trades = await prisma.trade.findMany()
     * 
     * // Get first 10 Trades
     * const trades = await prisma.trade.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tradeWithIdOnly = await prisma.trade.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TradeFindManyArgs>(args?: SelectSubset<T, TradeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Trade.
     * @param {TradeCreateArgs} args - Arguments to create a Trade.
     * @example
     * // Create one Trade
     * const Trade = await prisma.trade.create({
     *   data: {
     *     // ... data to create a Trade
     *   }
     * })
     * 
     */
    create<T extends TradeCreateArgs>(args: SelectSubset<T, TradeCreateArgs<ExtArgs>>): Prisma__TradeClient<$Result.GetResult<Prisma.$TradePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Trades.
     * @param {TradeCreateManyArgs} args - Arguments to create many Trades.
     * @example
     * // Create many Trades
     * const trade = await prisma.trade.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TradeCreateManyArgs>(args?: SelectSubset<T, TradeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Trades and returns the data saved in the database.
     * @param {TradeCreateManyAndReturnArgs} args - Arguments to create many Trades.
     * @example
     * // Create many Trades
     * const trade = await prisma.trade.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Trades and only return the `id`
     * const tradeWithIdOnly = await prisma.trade.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TradeCreateManyAndReturnArgs>(args?: SelectSubset<T, TradeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Trade.
     * @param {TradeDeleteArgs} args - Arguments to delete one Trade.
     * @example
     * // Delete one Trade
     * const Trade = await prisma.trade.delete({
     *   where: {
     *     // ... filter to delete one Trade
     *   }
     * })
     * 
     */
    delete<T extends TradeDeleteArgs>(args: SelectSubset<T, TradeDeleteArgs<ExtArgs>>): Prisma__TradeClient<$Result.GetResult<Prisma.$TradePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Trade.
     * @param {TradeUpdateArgs} args - Arguments to update one Trade.
     * @example
     * // Update one Trade
     * const trade = await prisma.trade.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TradeUpdateArgs>(args: SelectSubset<T, TradeUpdateArgs<ExtArgs>>): Prisma__TradeClient<$Result.GetResult<Prisma.$TradePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Trades.
     * @param {TradeDeleteManyArgs} args - Arguments to filter Trades to delete.
     * @example
     * // Delete a few Trades
     * const { count } = await prisma.trade.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TradeDeleteManyArgs>(args?: SelectSubset<T, TradeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Trades
     * const trade = await prisma.trade.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TradeUpdateManyArgs>(args: SelectSubset<T, TradeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Trade.
     * @param {TradeUpsertArgs} args - Arguments to update or create a Trade.
     * @example
     * // Update or create a Trade
     * const trade = await prisma.trade.upsert({
     *   create: {
     *     // ... data to create a Trade
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Trade we want to update
     *   }
     * })
     */
    upsert<T extends TradeUpsertArgs>(args: SelectSubset<T, TradeUpsertArgs<ExtArgs>>): Prisma__TradeClient<$Result.GetResult<Prisma.$TradePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Trades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeCountArgs} args - Arguments to filter Trades to count.
     * @example
     * // Count the number of Trades
     * const count = await prisma.trade.count({
     *   where: {
     *     // ... the filter for the Trades we want to count
     *   }
     * })
    **/
    count<T extends TradeCountArgs>(
      args?: Subset<T, TradeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TradeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Trade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TradeAggregateArgs>(args: Subset<T, TradeAggregateArgs>): Prisma.PrismaPromise<GetTradeAggregateType<T>>

    /**
     * Group by Trade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TradeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TradeGroupByArgs['orderBy'] }
        : { orderBy?: TradeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TradeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTradeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Trade model
   */
  readonly fields: TradeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Trade.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TradeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    mt5Account<T extends MT5AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MT5AccountDefaultArgs<ExtArgs>>): Prisma__MT5AccountClient<$Result.GetResult<Prisma.$MT5AccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Trade model
   */ 
  interface TradeFieldRefs {
    readonly id: FieldRef<"Trade", 'String'>
    readonly userId: FieldRef<"Trade", 'String'>
    readonly mt5AccountId: FieldRef<"Trade", 'String'>
    readonly ticket: FieldRef<"Trade", 'String'>
    readonly symbol: FieldRef<"Trade", 'String'>
    readonly type: FieldRef<"Trade", 'String'>
    readonly volume: FieldRef<"Trade", 'Float'>
    readonly openPrice: FieldRef<"Trade", 'Float'>
    readonly openTime: FieldRef<"Trade", 'DateTime'>
    readonly closePrice: FieldRef<"Trade", 'Float'>
    readonly closeTime: FieldRef<"Trade", 'DateTime'>
    readonly profit: FieldRef<"Trade", 'Float'>
    readonly commission: FieldRef<"Trade", 'Float'>
    readonly swap: FieldRef<"Trade", 'Float'>
    readonly magicNumber: FieldRef<"Trade", 'Int'>
    readonly comment: FieldRef<"Trade", 'String'>
    readonly isClosed: FieldRef<"Trade", 'Boolean'>
    readonly createdAt: FieldRef<"Trade", 'DateTime'>
    readonly updatedAt: FieldRef<"Trade", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Trade findUnique
   */
  export type TradeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trade
     */
    select?: TradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeInclude<ExtArgs> | null
    /**
     * Filter, which Trade to fetch.
     */
    where: TradeWhereUniqueInput
  }

  /**
   * Trade findUniqueOrThrow
   */
  export type TradeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trade
     */
    select?: TradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeInclude<ExtArgs> | null
    /**
     * Filter, which Trade to fetch.
     */
    where: TradeWhereUniqueInput
  }

  /**
   * Trade findFirst
   */
  export type TradeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trade
     */
    select?: TradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeInclude<ExtArgs> | null
    /**
     * Filter, which Trade to fetch.
     */
    where?: TradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trades to fetch.
     */
    orderBy?: TradeOrderByWithRelationInput | TradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trades.
     */
    cursor?: TradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trades.
     */
    distinct?: TradeScalarFieldEnum | TradeScalarFieldEnum[]
  }

  /**
   * Trade findFirstOrThrow
   */
  export type TradeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trade
     */
    select?: TradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeInclude<ExtArgs> | null
    /**
     * Filter, which Trade to fetch.
     */
    where?: TradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trades to fetch.
     */
    orderBy?: TradeOrderByWithRelationInput | TradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trades.
     */
    cursor?: TradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trades.
     */
    distinct?: TradeScalarFieldEnum | TradeScalarFieldEnum[]
  }

  /**
   * Trade findMany
   */
  export type TradeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trade
     */
    select?: TradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeInclude<ExtArgs> | null
    /**
     * Filter, which Trades to fetch.
     */
    where?: TradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trades to fetch.
     */
    orderBy?: TradeOrderByWithRelationInput | TradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Trades.
     */
    cursor?: TradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trades.
     */
    skip?: number
    distinct?: TradeScalarFieldEnum | TradeScalarFieldEnum[]
  }

  /**
   * Trade create
   */
  export type TradeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trade
     */
    select?: TradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeInclude<ExtArgs> | null
    /**
     * The data needed to create a Trade.
     */
    data: XOR<TradeCreateInput, TradeUncheckedCreateInput>
  }

  /**
   * Trade createMany
   */
  export type TradeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Trades.
     */
    data: TradeCreateManyInput | TradeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Trade createManyAndReturn
   */
  export type TradeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trade
     */
    select?: TradeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Trades.
     */
    data: TradeCreateManyInput | TradeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Trade update
   */
  export type TradeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trade
     */
    select?: TradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeInclude<ExtArgs> | null
    /**
     * The data needed to update a Trade.
     */
    data: XOR<TradeUpdateInput, TradeUncheckedUpdateInput>
    /**
     * Choose, which Trade to update.
     */
    where: TradeWhereUniqueInput
  }

  /**
   * Trade updateMany
   */
  export type TradeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Trades.
     */
    data: XOR<TradeUpdateManyMutationInput, TradeUncheckedUpdateManyInput>
    /**
     * Filter which Trades to update
     */
    where?: TradeWhereInput
  }

  /**
   * Trade upsert
   */
  export type TradeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trade
     */
    select?: TradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeInclude<ExtArgs> | null
    /**
     * The filter to search for the Trade to update in case it exists.
     */
    where: TradeWhereUniqueInput
    /**
     * In case the Trade found by the `where` argument doesn't exist, create a new Trade with this data.
     */
    create: XOR<TradeCreateInput, TradeUncheckedCreateInput>
    /**
     * In case the Trade was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TradeUpdateInput, TradeUncheckedUpdateInput>
  }

  /**
   * Trade delete
   */
  export type TradeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trade
     */
    select?: TradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeInclude<ExtArgs> | null
    /**
     * Filter which Trade to delete.
     */
    where: TradeWhereUniqueInput
  }

  /**
   * Trade deleteMany
   */
  export type TradeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trades to delete
     */
    where?: TradeWhereInput
  }

  /**
   * Trade without action
   */
  export type TradeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trade
     */
    select?: TradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeInclude<ExtArgs> | null
  }


  /**
   * Model Automation
   */

  export type AggregateAutomation = {
    _count: AutomationCountAggregateOutputType | null
    _avg: AutomationAvgAggregateOutputType | null
    _sum: AutomationSumAggregateOutputType | null
    _min: AutomationMinAggregateOutputType | null
    _max: AutomationMaxAggregateOutputType | null
  }

  export type AutomationAvgAggregateOutputType = {
    triggerValue: number | null
    priority: number | null
    totalTriggered: number | null
    totalSent: number | null
    totalFailed: number | null
  }

  export type AutomationSumAggregateOutputType = {
    triggerValue: number | null
    priority: number | null
    totalTriggered: number | null
    totalSent: number | null
    totalFailed: number | null
  }

  export type AutomationMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    userId: string | null
    triggerType: $Enums.AutomationTriggerType | null
    triggerValue: number | null
    messageSubject: string | null
    messageBody: string | null
    status: $Enums.AutomationStatus | null
    priority: number | null
    isUserEnabled: boolean | null
    totalTriggered: number | null
    totalSent: number | null
    totalFailed: number | null
    lastTriggered: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
  }

  export type AutomationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    userId: string | null
    triggerType: $Enums.AutomationTriggerType | null
    triggerValue: number | null
    messageSubject: string | null
    messageBody: string | null
    status: $Enums.AutomationStatus | null
    priority: number | null
    isUserEnabled: boolean | null
    totalTriggered: number | null
    totalSent: number | null
    totalFailed: number | null
    lastTriggered: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
  }

  export type AutomationCountAggregateOutputType = {
    id: number
    name: number
    description: number
    userId: number
    triggerType: number
    triggerValue: number
    triggerData: number
    actionTypes: number
    actionData: number
    messageSubject: number
    messageBody: number
    status: number
    priority: number
    isUserEnabled: number
    totalTriggered: number
    totalSent: number
    totalFailed: number
    lastTriggered: number
    createdAt: number
    updatedAt: number
    createdBy: number
    _all: number
  }


  export type AutomationAvgAggregateInputType = {
    triggerValue?: true
    priority?: true
    totalTriggered?: true
    totalSent?: true
    totalFailed?: true
  }

  export type AutomationSumAggregateInputType = {
    triggerValue?: true
    priority?: true
    totalTriggered?: true
    totalSent?: true
    totalFailed?: true
  }

  export type AutomationMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    userId?: true
    triggerType?: true
    triggerValue?: true
    messageSubject?: true
    messageBody?: true
    status?: true
    priority?: true
    isUserEnabled?: true
    totalTriggered?: true
    totalSent?: true
    totalFailed?: true
    lastTriggered?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
  }

  export type AutomationMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    userId?: true
    triggerType?: true
    triggerValue?: true
    messageSubject?: true
    messageBody?: true
    status?: true
    priority?: true
    isUserEnabled?: true
    totalTriggered?: true
    totalSent?: true
    totalFailed?: true
    lastTriggered?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
  }

  export type AutomationCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    userId?: true
    triggerType?: true
    triggerValue?: true
    triggerData?: true
    actionTypes?: true
    actionData?: true
    messageSubject?: true
    messageBody?: true
    status?: true
    priority?: true
    isUserEnabled?: true
    totalTriggered?: true
    totalSent?: true
    totalFailed?: true
    lastTriggered?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    _all?: true
  }

  export type AutomationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Automation to aggregate.
     */
    where?: AutomationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Automations to fetch.
     */
    orderBy?: AutomationOrderByWithRelationInput | AutomationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AutomationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Automations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Automations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Automations
    **/
    _count?: true | AutomationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AutomationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AutomationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AutomationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AutomationMaxAggregateInputType
  }

  export type GetAutomationAggregateType<T extends AutomationAggregateArgs> = {
        [P in keyof T & keyof AggregateAutomation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutomation[P]>
      : GetScalarType<T[P], AggregateAutomation[P]>
  }




  export type AutomationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutomationWhereInput
    orderBy?: AutomationOrderByWithAggregationInput | AutomationOrderByWithAggregationInput[]
    by: AutomationScalarFieldEnum[] | AutomationScalarFieldEnum
    having?: AutomationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AutomationCountAggregateInputType | true
    _avg?: AutomationAvgAggregateInputType
    _sum?: AutomationSumAggregateInputType
    _min?: AutomationMinAggregateInputType
    _max?: AutomationMaxAggregateInputType
  }

  export type AutomationGroupByOutputType = {
    id: string
    name: string
    description: string | null
    userId: string | null
    triggerType: $Enums.AutomationTriggerType
    triggerValue: number | null
    triggerData: JsonValue | null
    actionTypes: $Enums.AutomationActionType[]
    actionData: JsonValue | null
    messageSubject: string | null
    messageBody: string
    status: $Enums.AutomationStatus
    priority: number
    isUserEnabled: boolean
    totalTriggered: number
    totalSent: number
    totalFailed: number
    lastTriggered: Date | null
    createdAt: Date
    updatedAt: Date
    createdBy: string | null
    _count: AutomationCountAggregateOutputType | null
    _avg: AutomationAvgAggregateOutputType | null
    _sum: AutomationSumAggregateOutputType | null
    _min: AutomationMinAggregateOutputType | null
    _max: AutomationMaxAggregateOutputType | null
  }

  type GetAutomationGroupByPayload<T extends AutomationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AutomationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AutomationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AutomationGroupByOutputType[P]>
            : GetScalarType<T[P], AutomationGroupByOutputType[P]>
        }
      >
    >


  export type AutomationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    userId?: boolean
    triggerType?: boolean
    triggerValue?: boolean
    triggerData?: boolean
    actionTypes?: boolean
    actionData?: boolean
    messageSubject?: boolean
    messageBody?: boolean
    status?: boolean
    priority?: boolean
    isUserEnabled?: boolean
    totalTriggered?: boolean
    totalSent?: boolean
    totalFailed?: boolean
    lastTriggered?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    user?: boolean | Automation$userArgs<ExtArgs>
    logs?: boolean | Automation$logsArgs<ExtArgs>
    _count?: boolean | AutomationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["automation"]>

  export type AutomationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    userId?: boolean
    triggerType?: boolean
    triggerValue?: boolean
    triggerData?: boolean
    actionTypes?: boolean
    actionData?: boolean
    messageSubject?: boolean
    messageBody?: boolean
    status?: boolean
    priority?: boolean
    isUserEnabled?: boolean
    totalTriggered?: boolean
    totalSent?: boolean
    totalFailed?: boolean
    lastTriggered?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    user?: boolean | Automation$userArgs<ExtArgs>
  }, ExtArgs["result"]["automation"]>

  export type AutomationSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    userId?: boolean
    triggerType?: boolean
    triggerValue?: boolean
    triggerData?: boolean
    actionTypes?: boolean
    actionData?: boolean
    messageSubject?: boolean
    messageBody?: boolean
    status?: boolean
    priority?: boolean
    isUserEnabled?: boolean
    totalTriggered?: boolean
    totalSent?: boolean
    totalFailed?: boolean
    lastTriggered?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
  }

  export type AutomationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Automation$userArgs<ExtArgs>
    logs?: boolean | Automation$logsArgs<ExtArgs>
    _count?: boolean | AutomationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AutomationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Automation$userArgs<ExtArgs>
  }

  export type $AutomationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Automation"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      logs: Prisma.$NotificationLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      userId: string | null
      triggerType: $Enums.AutomationTriggerType
      triggerValue: number | null
      triggerData: Prisma.JsonValue | null
      actionTypes: $Enums.AutomationActionType[]
      actionData: Prisma.JsonValue | null
      messageSubject: string | null
      messageBody: string
      status: $Enums.AutomationStatus
      priority: number
      isUserEnabled: boolean
      totalTriggered: number
      totalSent: number
      totalFailed: number
      lastTriggered: Date | null
      createdAt: Date
      updatedAt: Date
      createdBy: string | null
    }, ExtArgs["result"]["automation"]>
    composites: {}
  }

  type AutomationGetPayload<S extends boolean | null | undefined | AutomationDefaultArgs> = $Result.GetResult<Prisma.$AutomationPayload, S>

  type AutomationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AutomationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AutomationCountAggregateInputType | true
    }

  export interface AutomationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Automation'], meta: { name: 'Automation' } }
    /**
     * Find zero or one Automation that matches the filter.
     * @param {AutomationFindUniqueArgs} args - Arguments to find a Automation
     * @example
     * // Get one Automation
     * const automation = await prisma.automation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AutomationFindUniqueArgs>(args: SelectSubset<T, AutomationFindUniqueArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Automation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AutomationFindUniqueOrThrowArgs} args - Arguments to find a Automation
     * @example
     * // Get one Automation
     * const automation = await prisma.automation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AutomationFindUniqueOrThrowArgs>(args: SelectSubset<T, AutomationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Automation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationFindFirstArgs} args - Arguments to find a Automation
     * @example
     * // Get one Automation
     * const automation = await prisma.automation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AutomationFindFirstArgs>(args?: SelectSubset<T, AutomationFindFirstArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Automation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationFindFirstOrThrowArgs} args - Arguments to find a Automation
     * @example
     * // Get one Automation
     * const automation = await prisma.automation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AutomationFindFirstOrThrowArgs>(args?: SelectSubset<T, AutomationFindFirstOrThrowArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Automations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Automations
     * const automations = await prisma.automation.findMany()
     * 
     * // Get first 10 Automations
     * const automations = await prisma.automation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const automationWithIdOnly = await prisma.automation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AutomationFindManyArgs>(args?: SelectSubset<T, AutomationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Automation.
     * @param {AutomationCreateArgs} args - Arguments to create a Automation.
     * @example
     * // Create one Automation
     * const Automation = await prisma.automation.create({
     *   data: {
     *     // ... data to create a Automation
     *   }
     * })
     * 
     */
    create<T extends AutomationCreateArgs>(args: SelectSubset<T, AutomationCreateArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Automations.
     * @param {AutomationCreateManyArgs} args - Arguments to create many Automations.
     * @example
     * // Create many Automations
     * const automation = await prisma.automation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AutomationCreateManyArgs>(args?: SelectSubset<T, AutomationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Automations and returns the data saved in the database.
     * @param {AutomationCreateManyAndReturnArgs} args - Arguments to create many Automations.
     * @example
     * // Create many Automations
     * const automation = await prisma.automation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Automations and only return the `id`
     * const automationWithIdOnly = await prisma.automation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AutomationCreateManyAndReturnArgs>(args?: SelectSubset<T, AutomationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Automation.
     * @param {AutomationDeleteArgs} args - Arguments to delete one Automation.
     * @example
     * // Delete one Automation
     * const Automation = await prisma.automation.delete({
     *   where: {
     *     // ... filter to delete one Automation
     *   }
     * })
     * 
     */
    delete<T extends AutomationDeleteArgs>(args: SelectSubset<T, AutomationDeleteArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Automation.
     * @param {AutomationUpdateArgs} args - Arguments to update one Automation.
     * @example
     * // Update one Automation
     * const automation = await prisma.automation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AutomationUpdateArgs>(args: SelectSubset<T, AutomationUpdateArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Automations.
     * @param {AutomationDeleteManyArgs} args - Arguments to filter Automations to delete.
     * @example
     * // Delete a few Automations
     * const { count } = await prisma.automation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AutomationDeleteManyArgs>(args?: SelectSubset<T, AutomationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Automations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Automations
     * const automation = await prisma.automation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AutomationUpdateManyArgs>(args: SelectSubset<T, AutomationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Automation.
     * @param {AutomationUpsertArgs} args - Arguments to update or create a Automation.
     * @example
     * // Update or create a Automation
     * const automation = await prisma.automation.upsert({
     *   create: {
     *     // ... data to create a Automation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Automation we want to update
     *   }
     * })
     */
    upsert<T extends AutomationUpsertArgs>(args: SelectSubset<T, AutomationUpsertArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Automations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationCountArgs} args - Arguments to filter Automations to count.
     * @example
     * // Count the number of Automations
     * const count = await prisma.automation.count({
     *   where: {
     *     // ... the filter for the Automations we want to count
     *   }
     * })
    **/
    count<T extends AutomationCountArgs>(
      args?: Subset<T, AutomationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AutomationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Automation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AutomationAggregateArgs>(args: Subset<T, AutomationAggregateArgs>): Prisma.PrismaPromise<GetAutomationAggregateType<T>>

    /**
     * Group by Automation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AutomationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AutomationGroupByArgs['orderBy'] }
        : { orderBy?: AutomationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AutomationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutomationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Automation model
   */
  readonly fields: AutomationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Automation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AutomationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Automation$userArgs<ExtArgs> = {}>(args?: Subset<T, Automation$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    logs<T extends Automation$logsArgs<ExtArgs> = {}>(args?: Subset<T, Automation$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Automation model
   */ 
  interface AutomationFieldRefs {
    readonly id: FieldRef<"Automation", 'String'>
    readonly name: FieldRef<"Automation", 'String'>
    readonly description: FieldRef<"Automation", 'String'>
    readonly userId: FieldRef<"Automation", 'String'>
    readonly triggerType: FieldRef<"Automation", 'AutomationTriggerType'>
    readonly triggerValue: FieldRef<"Automation", 'Int'>
    readonly triggerData: FieldRef<"Automation", 'Json'>
    readonly actionTypes: FieldRef<"Automation", 'AutomationActionType[]'>
    readonly actionData: FieldRef<"Automation", 'Json'>
    readonly messageSubject: FieldRef<"Automation", 'String'>
    readonly messageBody: FieldRef<"Automation", 'String'>
    readonly status: FieldRef<"Automation", 'AutomationStatus'>
    readonly priority: FieldRef<"Automation", 'Int'>
    readonly isUserEnabled: FieldRef<"Automation", 'Boolean'>
    readonly totalTriggered: FieldRef<"Automation", 'Int'>
    readonly totalSent: FieldRef<"Automation", 'Int'>
    readonly totalFailed: FieldRef<"Automation", 'Int'>
    readonly lastTriggered: FieldRef<"Automation", 'DateTime'>
    readonly createdAt: FieldRef<"Automation", 'DateTime'>
    readonly updatedAt: FieldRef<"Automation", 'DateTime'>
    readonly createdBy: FieldRef<"Automation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Automation findUnique
   */
  export type AutomationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    /**
     * Filter, which Automation to fetch.
     */
    where: AutomationWhereUniqueInput
  }

  /**
   * Automation findUniqueOrThrow
   */
  export type AutomationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    /**
     * Filter, which Automation to fetch.
     */
    where: AutomationWhereUniqueInput
  }

  /**
   * Automation findFirst
   */
  export type AutomationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    /**
     * Filter, which Automation to fetch.
     */
    where?: AutomationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Automations to fetch.
     */
    orderBy?: AutomationOrderByWithRelationInput | AutomationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Automations.
     */
    cursor?: AutomationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Automations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Automations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Automations.
     */
    distinct?: AutomationScalarFieldEnum | AutomationScalarFieldEnum[]
  }

  /**
   * Automation findFirstOrThrow
   */
  export type AutomationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    /**
     * Filter, which Automation to fetch.
     */
    where?: AutomationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Automations to fetch.
     */
    orderBy?: AutomationOrderByWithRelationInput | AutomationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Automations.
     */
    cursor?: AutomationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Automations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Automations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Automations.
     */
    distinct?: AutomationScalarFieldEnum | AutomationScalarFieldEnum[]
  }

  /**
   * Automation findMany
   */
  export type AutomationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    /**
     * Filter, which Automations to fetch.
     */
    where?: AutomationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Automations to fetch.
     */
    orderBy?: AutomationOrderByWithRelationInput | AutomationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Automations.
     */
    cursor?: AutomationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Automations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Automations.
     */
    skip?: number
    distinct?: AutomationScalarFieldEnum | AutomationScalarFieldEnum[]
  }

  /**
   * Automation create
   */
  export type AutomationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    /**
     * The data needed to create a Automation.
     */
    data: XOR<AutomationCreateInput, AutomationUncheckedCreateInput>
  }

  /**
   * Automation createMany
   */
  export type AutomationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Automations.
     */
    data: AutomationCreateManyInput | AutomationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Automation createManyAndReturn
   */
  export type AutomationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Automations.
     */
    data: AutomationCreateManyInput | AutomationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Automation update
   */
  export type AutomationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    /**
     * The data needed to update a Automation.
     */
    data: XOR<AutomationUpdateInput, AutomationUncheckedUpdateInput>
    /**
     * Choose, which Automation to update.
     */
    where: AutomationWhereUniqueInput
  }

  /**
   * Automation updateMany
   */
  export type AutomationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Automations.
     */
    data: XOR<AutomationUpdateManyMutationInput, AutomationUncheckedUpdateManyInput>
    /**
     * Filter which Automations to update
     */
    where?: AutomationWhereInput
  }

  /**
   * Automation upsert
   */
  export type AutomationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    /**
     * The filter to search for the Automation to update in case it exists.
     */
    where: AutomationWhereUniqueInput
    /**
     * In case the Automation found by the `where` argument doesn't exist, create a new Automation with this data.
     */
    create: XOR<AutomationCreateInput, AutomationUncheckedCreateInput>
    /**
     * In case the Automation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AutomationUpdateInput, AutomationUncheckedUpdateInput>
  }

  /**
   * Automation delete
   */
  export type AutomationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    /**
     * Filter which Automation to delete.
     */
    where: AutomationWhereUniqueInput
  }

  /**
   * Automation deleteMany
   */
  export type AutomationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Automations to delete
     */
    where?: AutomationWhereInput
  }

  /**
   * Automation.user
   */
  export type Automation$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Automation.logs
   */
  export type Automation$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    where?: NotificationLogWhereInput
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    cursor?: NotificationLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationLogScalarFieldEnum | NotificationLogScalarFieldEnum[]
  }

  /**
   * Automation without action
   */
  export type AutomationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
  }


  /**
   * Model NotificationLog
   */

  export type AggregateNotificationLog = {
    _count: NotificationLogCountAggregateOutputType | null
    _min: NotificationLogMinAggregateOutputType | null
    _max: NotificationLogMaxAggregateOutputType | null
  }

  export type NotificationLogMinAggregateOutputType = {
    id: string | null
    automationId: string | null
    userId: string | null
    channel: $Enums.AutomationActionType | null
    recipient: string | null
    subject: string | null
    message: string | null
    status: $Enums.NotificationStatus | null
    sentAt: Date | null
    deliveredAt: Date | null
    failedAt: Date | null
    errorMessage: string | null
    createdAt: Date | null
  }

  export type NotificationLogMaxAggregateOutputType = {
    id: string | null
    automationId: string | null
    userId: string | null
    channel: $Enums.AutomationActionType | null
    recipient: string | null
    subject: string | null
    message: string | null
    status: $Enums.NotificationStatus | null
    sentAt: Date | null
    deliveredAt: Date | null
    failedAt: Date | null
    errorMessage: string | null
    createdAt: Date | null
  }

  export type NotificationLogCountAggregateOutputType = {
    id: number
    automationId: number
    userId: number
    channel: number
    recipient: number
    subject: number
    message: number
    status: number
    sentAt: number
    deliveredAt: number
    failedAt: number
    errorMessage: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type NotificationLogMinAggregateInputType = {
    id?: true
    automationId?: true
    userId?: true
    channel?: true
    recipient?: true
    subject?: true
    message?: true
    status?: true
    sentAt?: true
    deliveredAt?: true
    failedAt?: true
    errorMessage?: true
    createdAt?: true
  }

  export type NotificationLogMaxAggregateInputType = {
    id?: true
    automationId?: true
    userId?: true
    channel?: true
    recipient?: true
    subject?: true
    message?: true
    status?: true
    sentAt?: true
    deliveredAt?: true
    failedAt?: true
    errorMessage?: true
    createdAt?: true
  }

  export type NotificationLogCountAggregateInputType = {
    id?: true
    automationId?: true
    userId?: true
    channel?: true
    recipient?: true
    subject?: true
    message?: true
    status?: true
    sentAt?: true
    deliveredAt?: true
    failedAt?: true
    errorMessage?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationLog to aggregate.
     */
    where?: NotificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationLogs to fetch.
     */
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationLogs
    **/
    _count?: true | NotificationLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationLogMaxAggregateInputType
  }

  export type GetNotificationLogAggregateType<T extends NotificationLogAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationLog[P]>
      : GetScalarType<T[P], AggregateNotificationLog[P]>
  }




  export type NotificationLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationLogWhereInput
    orderBy?: NotificationLogOrderByWithAggregationInput | NotificationLogOrderByWithAggregationInput[]
    by: NotificationLogScalarFieldEnum[] | NotificationLogScalarFieldEnum
    having?: NotificationLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationLogCountAggregateInputType | true
    _min?: NotificationLogMinAggregateInputType
    _max?: NotificationLogMaxAggregateInputType
  }

  export type NotificationLogGroupByOutputType = {
    id: string
    automationId: string
    userId: string
    channel: $Enums.AutomationActionType
    recipient: string
    subject: string | null
    message: string
    status: $Enums.NotificationStatus
    sentAt: Date | null
    deliveredAt: Date | null
    failedAt: Date | null
    errorMessage: string | null
    metadata: JsonValue | null
    createdAt: Date
    _count: NotificationLogCountAggregateOutputType | null
    _min: NotificationLogMinAggregateOutputType | null
    _max: NotificationLogMaxAggregateOutputType | null
  }

  type GetNotificationLogGroupByPayload<T extends NotificationLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationLogGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationLogGroupByOutputType[P]>
        }
      >
    >


  export type NotificationLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    automationId?: boolean
    userId?: boolean
    channel?: boolean
    recipient?: boolean
    subject?: boolean
    message?: boolean
    status?: boolean
    sentAt?: boolean
    deliveredAt?: boolean
    failedAt?: boolean
    errorMessage?: boolean
    metadata?: boolean
    createdAt?: boolean
    automation?: boolean | AutomationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationLog"]>

  export type NotificationLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    automationId?: boolean
    userId?: boolean
    channel?: boolean
    recipient?: boolean
    subject?: boolean
    message?: boolean
    status?: boolean
    sentAt?: boolean
    deliveredAt?: boolean
    failedAt?: boolean
    errorMessage?: boolean
    metadata?: boolean
    createdAt?: boolean
    automation?: boolean | AutomationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationLog"]>

  export type NotificationLogSelectScalar = {
    id?: boolean
    automationId?: boolean
    userId?: boolean
    channel?: boolean
    recipient?: boolean
    subject?: boolean
    message?: boolean
    status?: boolean
    sentAt?: boolean
    deliveredAt?: boolean
    failedAt?: boolean
    errorMessage?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type NotificationLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    automation?: boolean | AutomationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    automation?: boolean | AutomationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationLog"
    objects: {
      automation: Prisma.$AutomationPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      automationId: string
      userId: string
      channel: $Enums.AutomationActionType
      recipient: string
      subject: string | null
      message: string
      status: $Enums.NotificationStatus
      sentAt: Date | null
      deliveredAt: Date | null
      failedAt: Date | null
      errorMessage: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["notificationLog"]>
    composites: {}
  }

  type NotificationLogGetPayload<S extends boolean | null | undefined | NotificationLogDefaultArgs> = $Result.GetResult<Prisma.$NotificationLogPayload, S>

  type NotificationLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationLogCountAggregateInputType | true
    }

  export interface NotificationLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationLog'], meta: { name: 'NotificationLog' } }
    /**
     * Find zero or one NotificationLog that matches the filter.
     * @param {NotificationLogFindUniqueArgs} args - Arguments to find a NotificationLog
     * @example
     * // Get one NotificationLog
     * const notificationLog = await prisma.notificationLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationLogFindUniqueArgs>(args: SelectSubset<T, NotificationLogFindUniqueArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NotificationLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationLogFindUniqueOrThrowArgs} args - Arguments to find a NotificationLog
     * @example
     * // Get one NotificationLog
     * const notificationLog = await prisma.notificationLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationLogFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NotificationLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogFindFirstArgs} args - Arguments to find a NotificationLog
     * @example
     * // Get one NotificationLog
     * const notificationLog = await prisma.notificationLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationLogFindFirstArgs>(args?: SelectSubset<T, NotificationLogFindFirstArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NotificationLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogFindFirstOrThrowArgs} args - Arguments to find a NotificationLog
     * @example
     * // Get one NotificationLog
     * const notificationLog = await prisma.notificationLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationLogFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NotificationLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationLogs
     * const notificationLogs = await prisma.notificationLog.findMany()
     * 
     * // Get first 10 NotificationLogs
     * const notificationLogs = await prisma.notificationLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationLogWithIdOnly = await prisma.notificationLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationLogFindManyArgs>(args?: SelectSubset<T, NotificationLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NotificationLog.
     * @param {NotificationLogCreateArgs} args - Arguments to create a NotificationLog.
     * @example
     * // Create one NotificationLog
     * const NotificationLog = await prisma.notificationLog.create({
     *   data: {
     *     // ... data to create a NotificationLog
     *   }
     * })
     * 
     */
    create<T extends NotificationLogCreateArgs>(args: SelectSubset<T, NotificationLogCreateArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NotificationLogs.
     * @param {NotificationLogCreateManyArgs} args - Arguments to create many NotificationLogs.
     * @example
     * // Create many NotificationLogs
     * const notificationLog = await prisma.notificationLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationLogCreateManyArgs>(args?: SelectSubset<T, NotificationLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationLogs and returns the data saved in the database.
     * @param {NotificationLogCreateManyAndReturnArgs} args - Arguments to create many NotificationLogs.
     * @example
     * // Create many NotificationLogs
     * const notificationLog = await prisma.notificationLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationLogs and only return the `id`
     * const notificationLogWithIdOnly = await prisma.notificationLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationLogCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NotificationLog.
     * @param {NotificationLogDeleteArgs} args - Arguments to delete one NotificationLog.
     * @example
     * // Delete one NotificationLog
     * const NotificationLog = await prisma.notificationLog.delete({
     *   where: {
     *     // ... filter to delete one NotificationLog
     *   }
     * })
     * 
     */
    delete<T extends NotificationLogDeleteArgs>(args: SelectSubset<T, NotificationLogDeleteArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NotificationLog.
     * @param {NotificationLogUpdateArgs} args - Arguments to update one NotificationLog.
     * @example
     * // Update one NotificationLog
     * const notificationLog = await prisma.notificationLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationLogUpdateArgs>(args: SelectSubset<T, NotificationLogUpdateArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NotificationLogs.
     * @param {NotificationLogDeleteManyArgs} args - Arguments to filter NotificationLogs to delete.
     * @example
     * // Delete a few NotificationLogs
     * const { count } = await prisma.notificationLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationLogDeleteManyArgs>(args?: SelectSubset<T, NotificationLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationLogs
     * const notificationLog = await prisma.notificationLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationLogUpdateManyArgs>(args: SelectSubset<T, NotificationLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NotificationLog.
     * @param {NotificationLogUpsertArgs} args - Arguments to update or create a NotificationLog.
     * @example
     * // Update or create a NotificationLog
     * const notificationLog = await prisma.notificationLog.upsert({
     *   create: {
     *     // ... data to create a NotificationLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationLog we want to update
     *   }
     * })
     */
    upsert<T extends NotificationLogUpsertArgs>(args: SelectSubset<T, NotificationLogUpsertArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NotificationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogCountArgs} args - Arguments to filter NotificationLogs to count.
     * @example
     * // Count the number of NotificationLogs
     * const count = await prisma.notificationLog.count({
     *   where: {
     *     // ... the filter for the NotificationLogs we want to count
     *   }
     * })
    **/
    count<T extends NotificationLogCountArgs>(
      args?: Subset<T, NotificationLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationLogAggregateArgs>(args: Subset<T, NotificationLogAggregateArgs>): Prisma.PrismaPromise<GetNotificationLogAggregateType<T>>

    /**
     * Group by NotificationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationLogGroupByArgs['orderBy'] }
        : { orderBy?: NotificationLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationLog model
   */
  readonly fields: NotificationLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    automation<T extends AutomationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AutomationDefaultArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationLog model
   */ 
  interface NotificationLogFieldRefs {
    readonly id: FieldRef<"NotificationLog", 'String'>
    readonly automationId: FieldRef<"NotificationLog", 'String'>
    readonly userId: FieldRef<"NotificationLog", 'String'>
    readonly channel: FieldRef<"NotificationLog", 'AutomationActionType'>
    readonly recipient: FieldRef<"NotificationLog", 'String'>
    readonly subject: FieldRef<"NotificationLog", 'String'>
    readonly message: FieldRef<"NotificationLog", 'String'>
    readonly status: FieldRef<"NotificationLog", 'NotificationStatus'>
    readonly sentAt: FieldRef<"NotificationLog", 'DateTime'>
    readonly deliveredAt: FieldRef<"NotificationLog", 'DateTime'>
    readonly failedAt: FieldRef<"NotificationLog", 'DateTime'>
    readonly errorMessage: FieldRef<"NotificationLog", 'String'>
    readonly metadata: FieldRef<"NotificationLog", 'Json'>
    readonly createdAt: FieldRef<"NotificationLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationLog findUnique
   */
  export type NotificationLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * Filter, which NotificationLog to fetch.
     */
    where: NotificationLogWhereUniqueInput
  }

  /**
   * NotificationLog findUniqueOrThrow
   */
  export type NotificationLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * Filter, which NotificationLog to fetch.
     */
    where: NotificationLogWhereUniqueInput
  }

  /**
   * NotificationLog findFirst
   */
  export type NotificationLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * Filter, which NotificationLog to fetch.
     */
    where?: NotificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationLogs to fetch.
     */
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationLogs.
     */
    cursor?: NotificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationLogs.
     */
    distinct?: NotificationLogScalarFieldEnum | NotificationLogScalarFieldEnum[]
  }

  /**
   * NotificationLog findFirstOrThrow
   */
  export type NotificationLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * Filter, which NotificationLog to fetch.
     */
    where?: NotificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationLogs to fetch.
     */
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationLogs.
     */
    cursor?: NotificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationLogs.
     */
    distinct?: NotificationLogScalarFieldEnum | NotificationLogScalarFieldEnum[]
  }

  /**
   * NotificationLog findMany
   */
  export type NotificationLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * Filter, which NotificationLogs to fetch.
     */
    where?: NotificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationLogs to fetch.
     */
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationLogs.
     */
    cursor?: NotificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationLogs.
     */
    skip?: number
    distinct?: NotificationLogScalarFieldEnum | NotificationLogScalarFieldEnum[]
  }

  /**
   * NotificationLog create
   */
  export type NotificationLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationLog.
     */
    data: XOR<NotificationLogCreateInput, NotificationLogUncheckedCreateInput>
  }

  /**
   * NotificationLog createMany
   */
  export type NotificationLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationLogs.
     */
    data: NotificationLogCreateManyInput | NotificationLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationLog createManyAndReturn
   */
  export type NotificationLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NotificationLogs.
     */
    data: NotificationLogCreateManyInput | NotificationLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationLog update
   */
  export type NotificationLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationLog.
     */
    data: XOR<NotificationLogUpdateInput, NotificationLogUncheckedUpdateInput>
    /**
     * Choose, which NotificationLog to update.
     */
    where: NotificationLogWhereUniqueInput
  }

  /**
   * NotificationLog updateMany
   */
  export type NotificationLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationLogs.
     */
    data: XOR<NotificationLogUpdateManyMutationInput, NotificationLogUncheckedUpdateManyInput>
    /**
     * Filter which NotificationLogs to update
     */
    where?: NotificationLogWhereInput
  }

  /**
   * NotificationLog upsert
   */
  export type NotificationLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationLog to update in case it exists.
     */
    where: NotificationLogWhereUniqueInput
    /**
     * In case the NotificationLog found by the `where` argument doesn't exist, create a new NotificationLog with this data.
     */
    create: XOR<NotificationLogCreateInput, NotificationLogUncheckedCreateInput>
    /**
     * In case the NotificationLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationLogUpdateInput, NotificationLogUncheckedUpdateInput>
  }

  /**
   * NotificationLog delete
   */
  export type NotificationLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * Filter which NotificationLog to delete.
     */
    where: NotificationLogWhereUniqueInput
  }

  /**
   * NotificationLog deleteMany
   */
  export type NotificationLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationLogs to delete
     */
    where?: NotificationLogWhereInput
  }

  /**
   * NotificationLog without action
   */
  export type NotificationLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
  }


  /**
   * Model UserInsight
   */

  export type AggregateUserInsight = {
    _count: UserInsightCountAggregateOutputType | null
    _avg: UserInsightAvgAggregateOutputType | null
    _sum: UserInsightSumAggregateOutputType | null
    _min: UserInsightMinAggregateOutputType | null
    _max: UserInsightMaxAggregateOutputType | null
  }

  export type UserInsightAvgAggregateOutputType = {
    winRate: number | null
    avgProfitPerTrade: number | null
    avgLossPerTrade: number | null
    profitFactor: number | null
    maxDrawdown: number | null
    sharpeRatio: number | null
    tradingDaysActive: number | null
    avgTradesPerDay: number | null
    consecutiveWins: number | null
    consecutiveLosses: number | null
    daysSinceLastTrade: number | null
    lifetimeValue: number | null
    totalRevenue: number | null
    churnRisk: number | null
    engagementScore: number | null
    retentionProbability: number | null
    upsellProbability: number | null
  }

  export type UserInsightSumAggregateOutputType = {
    winRate: number | null
    avgProfitPerTrade: number | null
    avgLossPerTrade: number | null
    profitFactor: number | null
    maxDrawdown: number | null
    sharpeRatio: number | null
    tradingDaysActive: number | null
    avgTradesPerDay: number | null
    consecutiveWins: number | null
    consecutiveLosses: number | null
    daysSinceLastTrade: number | null
    lifetimeValue: number | null
    totalRevenue: number | null
    churnRisk: number | null
    engagementScore: number | null
    retentionProbability: number | null
    upsellProbability: number | null
  }

  export type UserInsightMinAggregateOutputType = {
    id: string | null
    userId: string | null
    winRate: number | null
    avgProfitPerTrade: number | null
    avgLossPerTrade: number | null
    profitFactor: number | null
    maxDrawdown: number | null
    sharpeRatio: number | null
    tradingDaysActive: number | null
    avgTradesPerDay: number | null
    preferredTimeframe: string | null
    riskLevel: string | null
    lastTradeDate: Date | null
    consecutiveWins: number | null
    consecutiveLosses: number | null
    daysSinceLastTrade: number | null
    lifetimeValue: number | null
    totalRevenue: number | null
    churnRisk: number | null
    engagementScore: number | null
    predictedNextAction: string | null
    retentionProbability: number | null
    upsellProbability: number | null
    updatedAt: Date | null
  }

  export type UserInsightMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    winRate: number | null
    avgProfitPerTrade: number | null
    avgLossPerTrade: number | null
    profitFactor: number | null
    maxDrawdown: number | null
    sharpeRatio: number | null
    tradingDaysActive: number | null
    avgTradesPerDay: number | null
    preferredTimeframe: string | null
    riskLevel: string | null
    lastTradeDate: Date | null
    consecutiveWins: number | null
    consecutiveLosses: number | null
    daysSinceLastTrade: number | null
    lifetimeValue: number | null
    totalRevenue: number | null
    churnRisk: number | null
    engagementScore: number | null
    predictedNextAction: string | null
    retentionProbability: number | null
    upsellProbability: number | null
    updatedAt: Date | null
  }

  export type UserInsightCountAggregateOutputType = {
    id: number
    userId: number
    winRate: number
    avgProfitPerTrade: number
    avgLossPerTrade: number
    profitFactor: number
    maxDrawdown: number
    sharpeRatio: number
    tradingDaysActive: number
    avgTradesPerDay: number
    preferredTimeframe: number
    riskLevel: number
    lastTradeDate: number
    consecutiveWins: number
    consecutiveLosses: number
    daysSinceLastTrade: number
    lifetimeValue: number
    totalRevenue: number
    churnRisk: number
    engagementScore: number
    predictedNextAction: number
    retentionProbability: number
    upsellProbability: number
    updatedAt: number
    _all: number
  }


  export type UserInsightAvgAggregateInputType = {
    winRate?: true
    avgProfitPerTrade?: true
    avgLossPerTrade?: true
    profitFactor?: true
    maxDrawdown?: true
    sharpeRatio?: true
    tradingDaysActive?: true
    avgTradesPerDay?: true
    consecutiveWins?: true
    consecutiveLosses?: true
    daysSinceLastTrade?: true
    lifetimeValue?: true
    totalRevenue?: true
    churnRisk?: true
    engagementScore?: true
    retentionProbability?: true
    upsellProbability?: true
  }

  export type UserInsightSumAggregateInputType = {
    winRate?: true
    avgProfitPerTrade?: true
    avgLossPerTrade?: true
    profitFactor?: true
    maxDrawdown?: true
    sharpeRatio?: true
    tradingDaysActive?: true
    avgTradesPerDay?: true
    consecutiveWins?: true
    consecutiveLosses?: true
    daysSinceLastTrade?: true
    lifetimeValue?: true
    totalRevenue?: true
    churnRisk?: true
    engagementScore?: true
    retentionProbability?: true
    upsellProbability?: true
  }

  export type UserInsightMinAggregateInputType = {
    id?: true
    userId?: true
    winRate?: true
    avgProfitPerTrade?: true
    avgLossPerTrade?: true
    profitFactor?: true
    maxDrawdown?: true
    sharpeRatio?: true
    tradingDaysActive?: true
    avgTradesPerDay?: true
    preferredTimeframe?: true
    riskLevel?: true
    lastTradeDate?: true
    consecutiveWins?: true
    consecutiveLosses?: true
    daysSinceLastTrade?: true
    lifetimeValue?: true
    totalRevenue?: true
    churnRisk?: true
    engagementScore?: true
    predictedNextAction?: true
    retentionProbability?: true
    upsellProbability?: true
    updatedAt?: true
  }

  export type UserInsightMaxAggregateInputType = {
    id?: true
    userId?: true
    winRate?: true
    avgProfitPerTrade?: true
    avgLossPerTrade?: true
    profitFactor?: true
    maxDrawdown?: true
    sharpeRatio?: true
    tradingDaysActive?: true
    avgTradesPerDay?: true
    preferredTimeframe?: true
    riskLevel?: true
    lastTradeDate?: true
    consecutiveWins?: true
    consecutiveLosses?: true
    daysSinceLastTrade?: true
    lifetimeValue?: true
    totalRevenue?: true
    churnRisk?: true
    engagementScore?: true
    predictedNextAction?: true
    retentionProbability?: true
    upsellProbability?: true
    updatedAt?: true
  }

  export type UserInsightCountAggregateInputType = {
    id?: true
    userId?: true
    winRate?: true
    avgProfitPerTrade?: true
    avgLossPerTrade?: true
    profitFactor?: true
    maxDrawdown?: true
    sharpeRatio?: true
    tradingDaysActive?: true
    avgTradesPerDay?: true
    preferredTimeframe?: true
    riskLevel?: true
    lastTradeDate?: true
    consecutiveWins?: true
    consecutiveLosses?: true
    daysSinceLastTrade?: true
    lifetimeValue?: true
    totalRevenue?: true
    churnRisk?: true
    engagementScore?: true
    predictedNextAction?: true
    retentionProbability?: true
    upsellProbability?: true
    updatedAt?: true
    _all?: true
  }

  export type UserInsightAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserInsight to aggregate.
     */
    where?: UserInsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInsights to fetch.
     */
    orderBy?: UserInsightOrderByWithRelationInput | UserInsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserInsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInsights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserInsights
    **/
    _count?: true | UserInsightCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserInsightAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserInsightSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserInsightMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserInsightMaxAggregateInputType
  }

  export type GetUserInsightAggregateType<T extends UserInsightAggregateArgs> = {
        [P in keyof T & keyof AggregateUserInsight]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserInsight[P]>
      : GetScalarType<T[P], AggregateUserInsight[P]>
  }




  export type UserInsightGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserInsightWhereInput
    orderBy?: UserInsightOrderByWithAggregationInput | UserInsightOrderByWithAggregationInput[]
    by: UserInsightScalarFieldEnum[] | UserInsightScalarFieldEnum
    having?: UserInsightScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserInsightCountAggregateInputType | true
    _avg?: UserInsightAvgAggregateInputType
    _sum?: UserInsightSumAggregateInputType
    _min?: UserInsightMinAggregateInputType
    _max?: UserInsightMaxAggregateInputType
  }

  export type UserInsightGroupByOutputType = {
    id: string
    userId: string
    winRate: number
    avgProfitPerTrade: number
    avgLossPerTrade: number
    profitFactor: number
    maxDrawdown: number
    sharpeRatio: number
    tradingDaysActive: number
    avgTradesPerDay: number
    preferredTimeframe: string | null
    riskLevel: string | null
    lastTradeDate: Date | null
    consecutiveWins: number
    consecutiveLosses: number
    daysSinceLastTrade: number
    lifetimeValue: number
    totalRevenue: number
    churnRisk: number
    engagementScore: number
    predictedNextAction: string | null
    retentionProbability: number
    upsellProbability: number
    updatedAt: Date
    _count: UserInsightCountAggregateOutputType | null
    _avg: UserInsightAvgAggregateOutputType | null
    _sum: UserInsightSumAggregateOutputType | null
    _min: UserInsightMinAggregateOutputType | null
    _max: UserInsightMaxAggregateOutputType | null
  }

  type GetUserInsightGroupByPayload<T extends UserInsightGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserInsightGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserInsightGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserInsightGroupByOutputType[P]>
            : GetScalarType<T[P], UserInsightGroupByOutputType[P]>
        }
      >
    >


  export type UserInsightSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    winRate?: boolean
    avgProfitPerTrade?: boolean
    avgLossPerTrade?: boolean
    profitFactor?: boolean
    maxDrawdown?: boolean
    sharpeRatio?: boolean
    tradingDaysActive?: boolean
    avgTradesPerDay?: boolean
    preferredTimeframe?: boolean
    riskLevel?: boolean
    lastTradeDate?: boolean
    consecutiveWins?: boolean
    consecutiveLosses?: boolean
    daysSinceLastTrade?: boolean
    lifetimeValue?: boolean
    totalRevenue?: boolean
    churnRisk?: boolean
    engagementScore?: boolean
    predictedNextAction?: boolean
    retentionProbability?: boolean
    upsellProbability?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userInsight"]>

  export type UserInsightSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    winRate?: boolean
    avgProfitPerTrade?: boolean
    avgLossPerTrade?: boolean
    profitFactor?: boolean
    maxDrawdown?: boolean
    sharpeRatio?: boolean
    tradingDaysActive?: boolean
    avgTradesPerDay?: boolean
    preferredTimeframe?: boolean
    riskLevel?: boolean
    lastTradeDate?: boolean
    consecutiveWins?: boolean
    consecutiveLosses?: boolean
    daysSinceLastTrade?: boolean
    lifetimeValue?: boolean
    totalRevenue?: boolean
    churnRisk?: boolean
    engagementScore?: boolean
    predictedNextAction?: boolean
    retentionProbability?: boolean
    upsellProbability?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userInsight"]>

  export type UserInsightSelectScalar = {
    id?: boolean
    userId?: boolean
    winRate?: boolean
    avgProfitPerTrade?: boolean
    avgLossPerTrade?: boolean
    profitFactor?: boolean
    maxDrawdown?: boolean
    sharpeRatio?: boolean
    tradingDaysActive?: boolean
    avgTradesPerDay?: boolean
    preferredTimeframe?: boolean
    riskLevel?: boolean
    lastTradeDate?: boolean
    consecutiveWins?: boolean
    consecutiveLosses?: boolean
    daysSinceLastTrade?: boolean
    lifetimeValue?: boolean
    totalRevenue?: boolean
    churnRisk?: boolean
    engagementScore?: boolean
    predictedNextAction?: boolean
    retentionProbability?: boolean
    upsellProbability?: boolean
    updatedAt?: boolean
  }

  export type UserInsightInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserInsightIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserInsightPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserInsight"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      winRate: number
      avgProfitPerTrade: number
      avgLossPerTrade: number
      profitFactor: number
      maxDrawdown: number
      sharpeRatio: number
      tradingDaysActive: number
      avgTradesPerDay: number
      preferredTimeframe: string | null
      riskLevel: string | null
      lastTradeDate: Date | null
      consecutiveWins: number
      consecutiveLosses: number
      daysSinceLastTrade: number
      lifetimeValue: number
      totalRevenue: number
      churnRisk: number
      engagementScore: number
      predictedNextAction: string | null
      retentionProbability: number
      upsellProbability: number
      updatedAt: Date
    }, ExtArgs["result"]["userInsight"]>
    composites: {}
  }

  type UserInsightGetPayload<S extends boolean | null | undefined | UserInsightDefaultArgs> = $Result.GetResult<Prisma.$UserInsightPayload, S>

  type UserInsightCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserInsightFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserInsightCountAggregateInputType | true
    }

  export interface UserInsightDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserInsight'], meta: { name: 'UserInsight' } }
    /**
     * Find zero or one UserInsight that matches the filter.
     * @param {UserInsightFindUniqueArgs} args - Arguments to find a UserInsight
     * @example
     * // Get one UserInsight
     * const userInsight = await prisma.userInsight.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserInsightFindUniqueArgs>(args: SelectSubset<T, UserInsightFindUniqueArgs<ExtArgs>>): Prisma__UserInsightClient<$Result.GetResult<Prisma.$UserInsightPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserInsight that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserInsightFindUniqueOrThrowArgs} args - Arguments to find a UserInsight
     * @example
     * // Get one UserInsight
     * const userInsight = await prisma.userInsight.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserInsightFindUniqueOrThrowArgs>(args: SelectSubset<T, UserInsightFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserInsightClient<$Result.GetResult<Prisma.$UserInsightPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserInsight that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInsightFindFirstArgs} args - Arguments to find a UserInsight
     * @example
     * // Get one UserInsight
     * const userInsight = await prisma.userInsight.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserInsightFindFirstArgs>(args?: SelectSubset<T, UserInsightFindFirstArgs<ExtArgs>>): Prisma__UserInsightClient<$Result.GetResult<Prisma.$UserInsightPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserInsight that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInsightFindFirstOrThrowArgs} args - Arguments to find a UserInsight
     * @example
     * // Get one UserInsight
     * const userInsight = await prisma.userInsight.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserInsightFindFirstOrThrowArgs>(args?: SelectSubset<T, UserInsightFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserInsightClient<$Result.GetResult<Prisma.$UserInsightPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserInsights that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInsightFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserInsights
     * const userInsights = await prisma.userInsight.findMany()
     * 
     * // Get first 10 UserInsights
     * const userInsights = await prisma.userInsight.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userInsightWithIdOnly = await prisma.userInsight.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserInsightFindManyArgs>(args?: SelectSubset<T, UserInsightFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserInsightPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserInsight.
     * @param {UserInsightCreateArgs} args - Arguments to create a UserInsight.
     * @example
     * // Create one UserInsight
     * const UserInsight = await prisma.userInsight.create({
     *   data: {
     *     // ... data to create a UserInsight
     *   }
     * })
     * 
     */
    create<T extends UserInsightCreateArgs>(args: SelectSubset<T, UserInsightCreateArgs<ExtArgs>>): Prisma__UserInsightClient<$Result.GetResult<Prisma.$UserInsightPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserInsights.
     * @param {UserInsightCreateManyArgs} args - Arguments to create many UserInsights.
     * @example
     * // Create many UserInsights
     * const userInsight = await prisma.userInsight.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserInsightCreateManyArgs>(args?: SelectSubset<T, UserInsightCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserInsights and returns the data saved in the database.
     * @param {UserInsightCreateManyAndReturnArgs} args - Arguments to create many UserInsights.
     * @example
     * // Create many UserInsights
     * const userInsight = await prisma.userInsight.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserInsights and only return the `id`
     * const userInsightWithIdOnly = await prisma.userInsight.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserInsightCreateManyAndReturnArgs>(args?: SelectSubset<T, UserInsightCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserInsightPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserInsight.
     * @param {UserInsightDeleteArgs} args - Arguments to delete one UserInsight.
     * @example
     * // Delete one UserInsight
     * const UserInsight = await prisma.userInsight.delete({
     *   where: {
     *     // ... filter to delete one UserInsight
     *   }
     * })
     * 
     */
    delete<T extends UserInsightDeleteArgs>(args: SelectSubset<T, UserInsightDeleteArgs<ExtArgs>>): Prisma__UserInsightClient<$Result.GetResult<Prisma.$UserInsightPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserInsight.
     * @param {UserInsightUpdateArgs} args - Arguments to update one UserInsight.
     * @example
     * // Update one UserInsight
     * const userInsight = await prisma.userInsight.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserInsightUpdateArgs>(args: SelectSubset<T, UserInsightUpdateArgs<ExtArgs>>): Prisma__UserInsightClient<$Result.GetResult<Prisma.$UserInsightPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserInsights.
     * @param {UserInsightDeleteManyArgs} args - Arguments to filter UserInsights to delete.
     * @example
     * // Delete a few UserInsights
     * const { count } = await prisma.userInsight.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserInsightDeleteManyArgs>(args?: SelectSubset<T, UserInsightDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserInsights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInsightUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserInsights
     * const userInsight = await prisma.userInsight.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserInsightUpdateManyArgs>(args: SelectSubset<T, UserInsightUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserInsight.
     * @param {UserInsightUpsertArgs} args - Arguments to update or create a UserInsight.
     * @example
     * // Update or create a UserInsight
     * const userInsight = await prisma.userInsight.upsert({
     *   create: {
     *     // ... data to create a UserInsight
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserInsight we want to update
     *   }
     * })
     */
    upsert<T extends UserInsightUpsertArgs>(args: SelectSubset<T, UserInsightUpsertArgs<ExtArgs>>): Prisma__UserInsightClient<$Result.GetResult<Prisma.$UserInsightPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserInsights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInsightCountArgs} args - Arguments to filter UserInsights to count.
     * @example
     * // Count the number of UserInsights
     * const count = await prisma.userInsight.count({
     *   where: {
     *     // ... the filter for the UserInsights we want to count
     *   }
     * })
    **/
    count<T extends UserInsightCountArgs>(
      args?: Subset<T, UserInsightCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserInsightCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserInsight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInsightAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserInsightAggregateArgs>(args: Subset<T, UserInsightAggregateArgs>): Prisma.PrismaPromise<GetUserInsightAggregateType<T>>

    /**
     * Group by UserInsight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInsightGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserInsightGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserInsightGroupByArgs['orderBy'] }
        : { orderBy?: UserInsightGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserInsightGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserInsightGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserInsight model
   */
  readonly fields: UserInsightFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserInsight.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserInsightClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserInsight model
   */ 
  interface UserInsightFieldRefs {
    readonly id: FieldRef<"UserInsight", 'String'>
    readonly userId: FieldRef<"UserInsight", 'String'>
    readonly winRate: FieldRef<"UserInsight", 'Float'>
    readonly avgProfitPerTrade: FieldRef<"UserInsight", 'Float'>
    readonly avgLossPerTrade: FieldRef<"UserInsight", 'Float'>
    readonly profitFactor: FieldRef<"UserInsight", 'Float'>
    readonly maxDrawdown: FieldRef<"UserInsight", 'Float'>
    readonly sharpeRatio: FieldRef<"UserInsight", 'Float'>
    readonly tradingDaysActive: FieldRef<"UserInsight", 'Int'>
    readonly avgTradesPerDay: FieldRef<"UserInsight", 'Float'>
    readonly preferredTimeframe: FieldRef<"UserInsight", 'String'>
    readonly riskLevel: FieldRef<"UserInsight", 'String'>
    readonly lastTradeDate: FieldRef<"UserInsight", 'DateTime'>
    readonly consecutiveWins: FieldRef<"UserInsight", 'Int'>
    readonly consecutiveLosses: FieldRef<"UserInsight", 'Int'>
    readonly daysSinceLastTrade: FieldRef<"UserInsight", 'Int'>
    readonly lifetimeValue: FieldRef<"UserInsight", 'Float'>
    readonly totalRevenue: FieldRef<"UserInsight", 'Float'>
    readonly churnRisk: FieldRef<"UserInsight", 'Float'>
    readonly engagementScore: FieldRef<"UserInsight", 'Float'>
    readonly predictedNextAction: FieldRef<"UserInsight", 'String'>
    readonly retentionProbability: FieldRef<"UserInsight", 'Float'>
    readonly upsellProbability: FieldRef<"UserInsight", 'Float'>
    readonly updatedAt: FieldRef<"UserInsight", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserInsight findUnique
   */
  export type UserInsightFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInsight
     */
    select?: UserInsightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInsightInclude<ExtArgs> | null
    /**
     * Filter, which UserInsight to fetch.
     */
    where: UserInsightWhereUniqueInput
  }

  /**
   * UserInsight findUniqueOrThrow
   */
  export type UserInsightFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInsight
     */
    select?: UserInsightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInsightInclude<ExtArgs> | null
    /**
     * Filter, which UserInsight to fetch.
     */
    where: UserInsightWhereUniqueInput
  }

  /**
   * UserInsight findFirst
   */
  export type UserInsightFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInsight
     */
    select?: UserInsightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInsightInclude<ExtArgs> | null
    /**
     * Filter, which UserInsight to fetch.
     */
    where?: UserInsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInsights to fetch.
     */
    orderBy?: UserInsightOrderByWithRelationInput | UserInsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserInsights.
     */
    cursor?: UserInsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInsights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserInsights.
     */
    distinct?: UserInsightScalarFieldEnum | UserInsightScalarFieldEnum[]
  }

  /**
   * UserInsight findFirstOrThrow
   */
  export type UserInsightFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInsight
     */
    select?: UserInsightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInsightInclude<ExtArgs> | null
    /**
     * Filter, which UserInsight to fetch.
     */
    where?: UserInsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInsights to fetch.
     */
    orderBy?: UserInsightOrderByWithRelationInput | UserInsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserInsights.
     */
    cursor?: UserInsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInsights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserInsights.
     */
    distinct?: UserInsightScalarFieldEnum | UserInsightScalarFieldEnum[]
  }

  /**
   * UserInsight findMany
   */
  export type UserInsightFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInsight
     */
    select?: UserInsightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInsightInclude<ExtArgs> | null
    /**
     * Filter, which UserInsights to fetch.
     */
    where?: UserInsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInsights to fetch.
     */
    orderBy?: UserInsightOrderByWithRelationInput | UserInsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserInsights.
     */
    cursor?: UserInsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInsights.
     */
    skip?: number
    distinct?: UserInsightScalarFieldEnum | UserInsightScalarFieldEnum[]
  }

  /**
   * UserInsight create
   */
  export type UserInsightCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInsight
     */
    select?: UserInsightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInsightInclude<ExtArgs> | null
    /**
     * The data needed to create a UserInsight.
     */
    data: XOR<UserInsightCreateInput, UserInsightUncheckedCreateInput>
  }

  /**
   * UserInsight createMany
   */
  export type UserInsightCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserInsights.
     */
    data: UserInsightCreateManyInput | UserInsightCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserInsight createManyAndReturn
   */
  export type UserInsightCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInsight
     */
    select?: UserInsightSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserInsights.
     */
    data: UserInsightCreateManyInput | UserInsightCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInsightIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserInsight update
   */
  export type UserInsightUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInsight
     */
    select?: UserInsightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInsightInclude<ExtArgs> | null
    /**
     * The data needed to update a UserInsight.
     */
    data: XOR<UserInsightUpdateInput, UserInsightUncheckedUpdateInput>
    /**
     * Choose, which UserInsight to update.
     */
    where: UserInsightWhereUniqueInput
  }

  /**
   * UserInsight updateMany
   */
  export type UserInsightUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserInsights.
     */
    data: XOR<UserInsightUpdateManyMutationInput, UserInsightUncheckedUpdateManyInput>
    /**
     * Filter which UserInsights to update
     */
    where?: UserInsightWhereInput
  }

  /**
   * UserInsight upsert
   */
  export type UserInsightUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInsight
     */
    select?: UserInsightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInsightInclude<ExtArgs> | null
    /**
     * The filter to search for the UserInsight to update in case it exists.
     */
    where: UserInsightWhereUniqueInput
    /**
     * In case the UserInsight found by the `where` argument doesn't exist, create a new UserInsight with this data.
     */
    create: XOR<UserInsightCreateInput, UserInsightUncheckedCreateInput>
    /**
     * In case the UserInsight was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserInsightUpdateInput, UserInsightUncheckedUpdateInput>
  }

  /**
   * UserInsight delete
   */
  export type UserInsightDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInsight
     */
    select?: UserInsightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInsightInclude<ExtArgs> | null
    /**
     * Filter which UserInsight to delete.
     */
    where: UserInsightWhereUniqueInput
  }

  /**
   * UserInsight deleteMany
   */
  export type UserInsightDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserInsights to delete
     */
    where?: UserInsightWhereInput
  }

  /**
   * UserInsight without action
   */
  export type UserInsightDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInsight
     */
    select?: UserInsightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInsightInclude<ExtArgs> | null
  }


  /**
   * Model SystemLog
   */

  export type AggregateSystemLog = {
    _count: SystemLogCountAggregateOutputType | null
    _min: SystemLogMinAggregateOutputType | null
    _max: SystemLogMaxAggregateOutputType | null
  }

  export type SystemLogMinAggregateOutputType = {
    id: string | null
    level: string | null
    component: string | null
    message: string | null
    createdAt: Date | null
  }

  export type SystemLogMaxAggregateOutputType = {
    id: string | null
    level: string | null
    component: string | null
    message: string | null
    createdAt: Date | null
  }

  export type SystemLogCountAggregateOutputType = {
    id: number
    level: number
    component: number
    message: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type SystemLogMinAggregateInputType = {
    id?: true
    level?: true
    component?: true
    message?: true
    createdAt?: true
  }

  export type SystemLogMaxAggregateInputType = {
    id?: true
    level?: true
    component?: true
    message?: true
    createdAt?: true
  }

  export type SystemLogCountAggregateInputType = {
    id?: true
    level?: true
    component?: true
    message?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type SystemLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemLog to aggregate.
     */
    where?: SystemLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemLogs to fetch.
     */
    orderBy?: SystemLogOrderByWithRelationInput | SystemLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemLogs
    **/
    _count?: true | SystemLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemLogMaxAggregateInputType
  }

  export type GetSystemLogAggregateType<T extends SystemLogAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemLog[P]>
      : GetScalarType<T[P], AggregateSystemLog[P]>
  }




  export type SystemLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemLogWhereInput
    orderBy?: SystemLogOrderByWithAggregationInput | SystemLogOrderByWithAggregationInput[]
    by: SystemLogScalarFieldEnum[] | SystemLogScalarFieldEnum
    having?: SystemLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemLogCountAggregateInputType | true
    _min?: SystemLogMinAggregateInputType
    _max?: SystemLogMaxAggregateInputType
  }

  export type SystemLogGroupByOutputType = {
    id: string
    level: string
    component: string
    message: string
    metadata: JsonValue | null
    createdAt: Date
    _count: SystemLogCountAggregateOutputType | null
    _min: SystemLogMinAggregateOutputType | null
    _max: SystemLogMaxAggregateOutputType | null
  }

  type GetSystemLogGroupByPayload<T extends SystemLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemLogGroupByOutputType[P]>
            : GetScalarType<T[P], SystemLogGroupByOutputType[P]>
        }
      >
    >


  export type SystemLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    level?: boolean
    component?: boolean
    message?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["systemLog"]>

  export type SystemLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    level?: boolean
    component?: boolean
    message?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["systemLog"]>

  export type SystemLogSelectScalar = {
    id?: boolean
    level?: boolean
    component?: boolean
    message?: boolean
    metadata?: boolean
    createdAt?: boolean
  }


  export type $SystemLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      level: string
      component: string
      message: string
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["systemLog"]>
    composites: {}
  }

  type SystemLogGetPayload<S extends boolean | null | undefined | SystemLogDefaultArgs> = $Result.GetResult<Prisma.$SystemLogPayload, S>

  type SystemLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SystemLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SystemLogCountAggregateInputType | true
    }

  export interface SystemLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemLog'], meta: { name: 'SystemLog' } }
    /**
     * Find zero or one SystemLog that matches the filter.
     * @param {SystemLogFindUniqueArgs} args - Arguments to find a SystemLog
     * @example
     * // Get one SystemLog
     * const systemLog = await prisma.systemLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemLogFindUniqueArgs>(args: SelectSubset<T, SystemLogFindUniqueArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SystemLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SystemLogFindUniqueOrThrowArgs} args - Arguments to find a SystemLog
     * @example
     * // Get one SystemLog
     * const systemLog = await prisma.systemLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemLogFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SystemLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogFindFirstArgs} args - Arguments to find a SystemLog
     * @example
     * // Get one SystemLog
     * const systemLog = await prisma.systemLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemLogFindFirstArgs>(args?: SelectSubset<T, SystemLogFindFirstArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SystemLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogFindFirstOrThrowArgs} args - Arguments to find a SystemLog
     * @example
     * // Get one SystemLog
     * const systemLog = await prisma.systemLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemLogFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SystemLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemLogs
     * const systemLogs = await prisma.systemLog.findMany()
     * 
     * // Get first 10 SystemLogs
     * const systemLogs = await prisma.systemLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemLogWithIdOnly = await prisma.systemLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemLogFindManyArgs>(args?: SelectSubset<T, SystemLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SystemLog.
     * @param {SystemLogCreateArgs} args - Arguments to create a SystemLog.
     * @example
     * // Create one SystemLog
     * const SystemLog = await prisma.systemLog.create({
     *   data: {
     *     // ... data to create a SystemLog
     *   }
     * })
     * 
     */
    create<T extends SystemLogCreateArgs>(args: SelectSubset<T, SystemLogCreateArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SystemLogs.
     * @param {SystemLogCreateManyArgs} args - Arguments to create many SystemLogs.
     * @example
     * // Create many SystemLogs
     * const systemLog = await prisma.systemLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemLogCreateManyArgs>(args?: SelectSubset<T, SystemLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemLogs and returns the data saved in the database.
     * @param {SystemLogCreateManyAndReturnArgs} args - Arguments to create many SystemLogs.
     * @example
     * // Create many SystemLogs
     * const systemLog = await prisma.systemLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemLogs and only return the `id`
     * const systemLogWithIdOnly = await prisma.systemLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemLogCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SystemLog.
     * @param {SystemLogDeleteArgs} args - Arguments to delete one SystemLog.
     * @example
     * // Delete one SystemLog
     * const SystemLog = await prisma.systemLog.delete({
     *   where: {
     *     // ... filter to delete one SystemLog
     *   }
     * })
     * 
     */
    delete<T extends SystemLogDeleteArgs>(args: SelectSubset<T, SystemLogDeleteArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SystemLog.
     * @param {SystemLogUpdateArgs} args - Arguments to update one SystemLog.
     * @example
     * // Update one SystemLog
     * const systemLog = await prisma.systemLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemLogUpdateArgs>(args: SelectSubset<T, SystemLogUpdateArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SystemLogs.
     * @param {SystemLogDeleteManyArgs} args - Arguments to filter SystemLogs to delete.
     * @example
     * // Delete a few SystemLogs
     * const { count } = await prisma.systemLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemLogDeleteManyArgs>(args?: SelectSubset<T, SystemLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemLogs
     * const systemLog = await prisma.systemLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemLogUpdateManyArgs>(args: SelectSubset<T, SystemLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemLog.
     * @param {SystemLogUpsertArgs} args - Arguments to update or create a SystemLog.
     * @example
     * // Update or create a SystemLog
     * const systemLog = await prisma.systemLog.upsert({
     *   create: {
     *     // ... data to create a SystemLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemLog we want to update
     *   }
     * })
     */
    upsert<T extends SystemLogUpsertArgs>(args: SelectSubset<T, SystemLogUpsertArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SystemLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogCountArgs} args - Arguments to filter SystemLogs to count.
     * @example
     * // Count the number of SystemLogs
     * const count = await prisma.systemLog.count({
     *   where: {
     *     // ... the filter for the SystemLogs we want to count
     *   }
     * })
    **/
    count<T extends SystemLogCountArgs>(
      args?: Subset<T, SystemLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemLogAggregateArgs>(args: Subset<T, SystemLogAggregateArgs>): Prisma.PrismaPromise<GetSystemLogAggregateType<T>>

    /**
     * Group by SystemLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemLogGroupByArgs['orderBy'] }
        : { orderBy?: SystemLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemLog model
   */
  readonly fields: SystemLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemLog model
   */ 
  interface SystemLogFieldRefs {
    readonly id: FieldRef<"SystemLog", 'String'>
    readonly level: FieldRef<"SystemLog", 'String'>
    readonly component: FieldRef<"SystemLog", 'String'>
    readonly message: FieldRef<"SystemLog", 'String'>
    readonly metadata: FieldRef<"SystemLog", 'Json'>
    readonly createdAt: FieldRef<"SystemLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemLog findUnique
   */
  export type SystemLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Filter, which SystemLog to fetch.
     */
    where: SystemLogWhereUniqueInput
  }

  /**
   * SystemLog findUniqueOrThrow
   */
  export type SystemLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Filter, which SystemLog to fetch.
     */
    where: SystemLogWhereUniqueInput
  }

  /**
   * SystemLog findFirst
   */
  export type SystemLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Filter, which SystemLog to fetch.
     */
    where?: SystemLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemLogs to fetch.
     */
    orderBy?: SystemLogOrderByWithRelationInput | SystemLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemLogs.
     */
    cursor?: SystemLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemLogs.
     */
    distinct?: SystemLogScalarFieldEnum | SystemLogScalarFieldEnum[]
  }

  /**
   * SystemLog findFirstOrThrow
   */
  export type SystemLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Filter, which SystemLog to fetch.
     */
    where?: SystemLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemLogs to fetch.
     */
    orderBy?: SystemLogOrderByWithRelationInput | SystemLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemLogs.
     */
    cursor?: SystemLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemLogs.
     */
    distinct?: SystemLogScalarFieldEnum | SystemLogScalarFieldEnum[]
  }

  /**
   * SystemLog findMany
   */
  export type SystemLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Filter, which SystemLogs to fetch.
     */
    where?: SystemLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemLogs to fetch.
     */
    orderBy?: SystemLogOrderByWithRelationInput | SystemLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemLogs.
     */
    cursor?: SystemLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemLogs.
     */
    skip?: number
    distinct?: SystemLogScalarFieldEnum | SystemLogScalarFieldEnum[]
  }

  /**
   * SystemLog create
   */
  export type SystemLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * The data needed to create a SystemLog.
     */
    data: XOR<SystemLogCreateInput, SystemLogUncheckedCreateInput>
  }

  /**
   * SystemLog createMany
   */
  export type SystemLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemLogs.
     */
    data: SystemLogCreateManyInput | SystemLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemLog createManyAndReturn
   */
  export type SystemLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SystemLogs.
     */
    data: SystemLogCreateManyInput | SystemLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemLog update
   */
  export type SystemLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * The data needed to update a SystemLog.
     */
    data: XOR<SystemLogUpdateInput, SystemLogUncheckedUpdateInput>
    /**
     * Choose, which SystemLog to update.
     */
    where: SystemLogWhereUniqueInput
  }

  /**
   * SystemLog updateMany
   */
  export type SystemLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemLogs.
     */
    data: XOR<SystemLogUpdateManyMutationInput, SystemLogUncheckedUpdateManyInput>
    /**
     * Filter which SystemLogs to update
     */
    where?: SystemLogWhereInput
  }

  /**
   * SystemLog upsert
   */
  export type SystemLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * The filter to search for the SystemLog to update in case it exists.
     */
    where: SystemLogWhereUniqueInput
    /**
     * In case the SystemLog found by the `where` argument doesn't exist, create a new SystemLog with this data.
     */
    create: XOR<SystemLogCreateInput, SystemLogUncheckedCreateInput>
    /**
     * In case the SystemLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemLogUpdateInput, SystemLogUncheckedUpdateInput>
  }

  /**
   * SystemLog delete
   */
  export type SystemLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Filter which SystemLog to delete.
     */
    where: SystemLogWhereUniqueInput
  }

  /**
   * SystemLog deleteMany
   */
  export type SystemLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemLogs to delete
     */
    where?: SystemLogWhereInput
  }

  /**
   * SystemLog without action
   */
  export type SystemLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
  }


  /**
   * Model MarketCondition
   */

  export type AggregateMarketCondition = {
    _count: MarketConditionCountAggregateOutputType | null
    _avg: MarketConditionAvgAggregateOutputType | null
    _sum: MarketConditionSumAggregateOutputType | null
    _min: MarketConditionMinAggregateOutputType | null
    _max: MarketConditionMaxAggregateOutputType | null
  }

  export type MarketConditionAvgAggregateOutputType = {
    volatility: number | null
    spread: number | null
  }

  export type MarketConditionSumAggregateOutputType = {
    volatility: number | null
    spread: number | null
  }

  export type MarketConditionMinAggregateOutputType = {
    id: string | null
    volatility: number | null
    spread: number | null
    trend: string | null
    newsImpact: boolean | null
    safetyIndicator: $Enums.SafetyIndicator | null
    reason: string | null
    timestamp: Date | null
  }

  export type MarketConditionMaxAggregateOutputType = {
    id: string | null
    volatility: number | null
    spread: number | null
    trend: string | null
    newsImpact: boolean | null
    safetyIndicator: $Enums.SafetyIndicator | null
    reason: string | null
    timestamp: Date | null
  }

  export type MarketConditionCountAggregateOutputType = {
    id: number
    volatility: number
    spread: number
    trend: number
    newsImpact: number
    safetyIndicator: number
    reason: number
    timestamp: number
    _all: number
  }


  export type MarketConditionAvgAggregateInputType = {
    volatility?: true
    spread?: true
  }

  export type MarketConditionSumAggregateInputType = {
    volatility?: true
    spread?: true
  }

  export type MarketConditionMinAggregateInputType = {
    id?: true
    volatility?: true
    spread?: true
    trend?: true
    newsImpact?: true
    safetyIndicator?: true
    reason?: true
    timestamp?: true
  }

  export type MarketConditionMaxAggregateInputType = {
    id?: true
    volatility?: true
    spread?: true
    trend?: true
    newsImpact?: true
    safetyIndicator?: true
    reason?: true
    timestamp?: true
  }

  export type MarketConditionCountAggregateInputType = {
    id?: true
    volatility?: true
    spread?: true
    trend?: true
    newsImpact?: true
    safetyIndicator?: true
    reason?: true
    timestamp?: true
    _all?: true
  }

  export type MarketConditionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketCondition to aggregate.
     */
    where?: MarketConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketConditions to fetch.
     */
    orderBy?: MarketConditionOrderByWithRelationInput | MarketConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MarketConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketConditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MarketConditions
    **/
    _count?: true | MarketConditionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MarketConditionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MarketConditionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarketConditionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarketConditionMaxAggregateInputType
  }

  export type GetMarketConditionAggregateType<T extends MarketConditionAggregateArgs> = {
        [P in keyof T & keyof AggregateMarketCondition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarketCondition[P]>
      : GetScalarType<T[P], AggregateMarketCondition[P]>
  }




  export type MarketConditionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketConditionWhereInput
    orderBy?: MarketConditionOrderByWithAggregationInput | MarketConditionOrderByWithAggregationInput[]
    by: MarketConditionScalarFieldEnum[] | MarketConditionScalarFieldEnum
    having?: MarketConditionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarketConditionCountAggregateInputType | true
    _avg?: MarketConditionAvgAggregateInputType
    _sum?: MarketConditionSumAggregateInputType
    _min?: MarketConditionMinAggregateInputType
    _max?: MarketConditionMaxAggregateInputType
  }

  export type MarketConditionGroupByOutputType = {
    id: string
    volatility: number
    spread: number
    trend: string
    newsImpact: boolean
    safetyIndicator: $Enums.SafetyIndicator
    reason: string
    timestamp: Date
    _count: MarketConditionCountAggregateOutputType | null
    _avg: MarketConditionAvgAggregateOutputType | null
    _sum: MarketConditionSumAggregateOutputType | null
    _min: MarketConditionMinAggregateOutputType | null
    _max: MarketConditionMaxAggregateOutputType | null
  }

  type GetMarketConditionGroupByPayload<T extends MarketConditionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MarketConditionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarketConditionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarketConditionGroupByOutputType[P]>
            : GetScalarType<T[P], MarketConditionGroupByOutputType[P]>
        }
      >
    >


  export type MarketConditionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    volatility?: boolean
    spread?: boolean
    trend?: boolean
    newsImpact?: boolean
    safetyIndicator?: boolean
    reason?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["marketCondition"]>

  export type MarketConditionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    volatility?: boolean
    spread?: boolean
    trend?: boolean
    newsImpact?: boolean
    safetyIndicator?: boolean
    reason?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["marketCondition"]>

  export type MarketConditionSelectScalar = {
    id?: boolean
    volatility?: boolean
    spread?: boolean
    trend?: boolean
    newsImpact?: boolean
    safetyIndicator?: boolean
    reason?: boolean
    timestamp?: boolean
  }


  export type $MarketConditionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MarketCondition"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      volatility: number
      spread: number
      trend: string
      newsImpact: boolean
      safetyIndicator: $Enums.SafetyIndicator
      reason: string
      timestamp: Date
    }, ExtArgs["result"]["marketCondition"]>
    composites: {}
  }

  type MarketConditionGetPayload<S extends boolean | null | undefined | MarketConditionDefaultArgs> = $Result.GetResult<Prisma.$MarketConditionPayload, S>

  type MarketConditionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MarketConditionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MarketConditionCountAggregateInputType | true
    }

  export interface MarketConditionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MarketCondition'], meta: { name: 'MarketCondition' } }
    /**
     * Find zero or one MarketCondition that matches the filter.
     * @param {MarketConditionFindUniqueArgs} args - Arguments to find a MarketCondition
     * @example
     * // Get one MarketCondition
     * const marketCondition = await prisma.marketCondition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MarketConditionFindUniqueArgs>(args: SelectSubset<T, MarketConditionFindUniqueArgs<ExtArgs>>): Prisma__MarketConditionClient<$Result.GetResult<Prisma.$MarketConditionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MarketCondition that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MarketConditionFindUniqueOrThrowArgs} args - Arguments to find a MarketCondition
     * @example
     * // Get one MarketCondition
     * const marketCondition = await prisma.marketCondition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MarketConditionFindUniqueOrThrowArgs>(args: SelectSubset<T, MarketConditionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MarketConditionClient<$Result.GetResult<Prisma.$MarketConditionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MarketCondition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketConditionFindFirstArgs} args - Arguments to find a MarketCondition
     * @example
     * // Get one MarketCondition
     * const marketCondition = await prisma.marketCondition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MarketConditionFindFirstArgs>(args?: SelectSubset<T, MarketConditionFindFirstArgs<ExtArgs>>): Prisma__MarketConditionClient<$Result.GetResult<Prisma.$MarketConditionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MarketCondition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketConditionFindFirstOrThrowArgs} args - Arguments to find a MarketCondition
     * @example
     * // Get one MarketCondition
     * const marketCondition = await prisma.marketCondition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MarketConditionFindFirstOrThrowArgs>(args?: SelectSubset<T, MarketConditionFindFirstOrThrowArgs<ExtArgs>>): Prisma__MarketConditionClient<$Result.GetResult<Prisma.$MarketConditionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MarketConditions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketConditionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MarketConditions
     * const marketConditions = await prisma.marketCondition.findMany()
     * 
     * // Get first 10 MarketConditions
     * const marketConditions = await prisma.marketCondition.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const marketConditionWithIdOnly = await prisma.marketCondition.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MarketConditionFindManyArgs>(args?: SelectSubset<T, MarketConditionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketConditionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MarketCondition.
     * @param {MarketConditionCreateArgs} args - Arguments to create a MarketCondition.
     * @example
     * // Create one MarketCondition
     * const MarketCondition = await prisma.marketCondition.create({
     *   data: {
     *     // ... data to create a MarketCondition
     *   }
     * })
     * 
     */
    create<T extends MarketConditionCreateArgs>(args: SelectSubset<T, MarketConditionCreateArgs<ExtArgs>>): Prisma__MarketConditionClient<$Result.GetResult<Prisma.$MarketConditionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MarketConditions.
     * @param {MarketConditionCreateManyArgs} args - Arguments to create many MarketConditions.
     * @example
     * // Create many MarketConditions
     * const marketCondition = await prisma.marketCondition.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MarketConditionCreateManyArgs>(args?: SelectSubset<T, MarketConditionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MarketConditions and returns the data saved in the database.
     * @param {MarketConditionCreateManyAndReturnArgs} args - Arguments to create many MarketConditions.
     * @example
     * // Create many MarketConditions
     * const marketCondition = await prisma.marketCondition.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MarketConditions and only return the `id`
     * const marketConditionWithIdOnly = await prisma.marketCondition.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MarketConditionCreateManyAndReturnArgs>(args?: SelectSubset<T, MarketConditionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketConditionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MarketCondition.
     * @param {MarketConditionDeleteArgs} args - Arguments to delete one MarketCondition.
     * @example
     * // Delete one MarketCondition
     * const MarketCondition = await prisma.marketCondition.delete({
     *   where: {
     *     // ... filter to delete one MarketCondition
     *   }
     * })
     * 
     */
    delete<T extends MarketConditionDeleteArgs>(args: SelectSubset<T, MarketConditionDeleteArgs<ExtArgs>>): Prisma__MarketConditionClient<$Result.GetResult<Prisma.$MarketConditionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MarketCondition.
     * @param {MarketConditionUpdateArgs} args - Arguments to update one MarketCondition.
     * @example
     * // Update one MarketCondition
     * const marketCondition = await prisma.marketCondition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MarketConditionUpdateArgs>(args: SelectSubset<T, MarketConditionUpdateArgs<ExtArgs>>): Prisma__MarketConditionClient<$Result.GetResult<Prisma.$MarketConditionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MarketConditions.
     * @param {MarketConditionDeleteManyArgs} args - Arguments to filter MarketConditions to delete.
     * @example
     * // Delete a few MarketConditions
     * const { count } = await prisma.marketCondition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MarketConditionDeleteManyArgs>(args?: SelectSubset<T, MarketConditionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketConditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketConditionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MarketConditions
     * const marketCondition = await prisma.marketCondition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MarketConditionUpdateManyArgs>(args: SelectSubset<T, MarketConditionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MarketCondition.
     * @param {MarketConditionUpsertArgs} args - Arguments to update or create a MarketCondition.
     * @example
     * // Update or create a MarketCondition
     * const marketCondition = await prisma.marketCondition.upsert({
     *   create: {
     *     // ... data to create a MarketCondition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MarketCondition we want to update
     *   }
     * })
     */
    upsert<T extends MarketConditionUpsertArgs>(args: SelectSubset<T, MarketConditionUpsertArgs<ExtArgs>>): Prisma__MarketConditionClient<$Result.GetResult<Prisma.$MarketConditionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MarketConditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketConditionCountArgs} args - Arguments to filter MarketConditions to count.
     * @example
     * // Count the number of MarketConditions
     * const count = await prisma.marketCondition.count({
     *   where: {
     *     // ... the filter for the MarketConditions we want to count
     *   }
     * })
    **/
    count<T extends MarketConditionCountArgs>(
      args?: Subset<T, MarketConditionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarketConditionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MarketCondition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketConditionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarketConditionAggregateArgs>(args: Subset<T, MarketConditionAggregateArgs>): Prisma.PrismaPromise<GetMarketConditionAggregateType<T>>

    /**
     * Group by MarketCondition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketConditionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarketConditionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarketConditionGroupByArgs['orderBy'] }
        : { orderBy?: MarketConditionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarketConditionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarketConditionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MarketCondition model
   */
  readonly fields: MarketConditionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MarketCondition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MarketConditionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MarketCondition model
   */ 
  interface MarketConditionFieldRefs {
    readonly id: FieldRef<"MarketCondition", 'String'>
    readonly volatility: FieldRef<"MarketCondition", 'Float'>
    readonly spread: FieldRef<"MarketCondition", 'Float'>
    readonly trend: FieldRef<"MarketCondition", 'String'>
    readonly newsImpact: FieldRef<"MarketCondition", 'Boolean'>
    readonly safetyIndicator: FieldRef<"MarketCondition", 'SafetyIndicator'>
    readonly reason: FieldRef<"MarketCondition", 'String'>
    readonly timestamp: FieldRef<"MarketCondition", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MarketCondition findUnique
   */
  export type MarketConditionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketCondition
     */
    select?: MarketConditionSelect<ExtArgs> | null
    /**
     * Filter, which MarketCondition to fetch.
     */
    where: MarketConditionWhereUniqueInput
  }

  /**
   * MarketCondition findUniqueOrThrow
   */
  export type MarketConditionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketCondition
     */
    select?: MarketConditionSelect<ExtArgs> | null
    /**
     * Filter, which MarketCondition to fetch.
     */
    where: MarketConditionWhereUniqueInput
  }

  /**
   * MarketCondition findFirst
   */
  export type MarketConditionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketCondition
     */
    select?: MarketConditionSelect<ExtArgs> | null
    /**
     * Filter, which MarketCondition to fetch.
     */
    where?: MarketConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketConditions to fetch.
     */
    orderBy?: MarketConditionOrderByWithRelationInput | MarketConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketConditions.
     */
    cursor?: MarketConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketConditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketConditions.
     */
    distinct?: MarketConditionScalarFieldEnum | MarketConditionScalarFieldEnum[]
  }

  /**
   * MarketCondition findFirstOrThrow
   */
  export type MarketConditionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketCondition
     */
    select?: MarketConditionSelect<ExtArgs> | null
    /**
     * Filter, which MarketCondition to fetch.
     */
    where?: MarketConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketConditions to fetch.
     */
    orderBy?: MarketConditionOrderByWithRelationInput | MarketConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketConditions.
     */
    cursor?: MarketConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketConditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketConditions.
     */
    distinct?: MarketConditionScalarFieldEnum | MarketConditionScalarFieldEnum[]
  }

  /**
   * MarketCondition findMany
   */
  export type MarketConditionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketCondition
     */
    select?: MarketConditionSelect<ExtArgs> | null
    /**
     * Filter, which MarketConditions to fetch.
     */
    where?: MarketConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketConditions to fetch.
     */
    orderBy?: MarketConditionOrderByWithRelationInput | MarketConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MarketConditions.
     */
    cursor?: MarketConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketConditions.
     */
    skip?: number
    distinct?: MarketConditionScalarFieldEnum | MarketConditionScalarFieldEnum[]
  }

  /**
   * MarketCondition create
   */
  export type MarketConditionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketCondition
     */
    select?: MarketConditionSelect<ExtArgs> | null
    /**
     * The data needed to create a MarketCondition.
     */
    data: XOR<MarketConditionCreateInput, MarketConditionUncheckedCreateInput>
  }

  /**
   * MarketCondition createMany
   */
  export type MarketConditionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MarketConditions.
     */
    data: MarketConditionCreateManyInput | MarketConditionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MarketCondition createManyAndReturn
   */
  export type MarketConditionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketCondition
     */
    select?: MarketConditionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MarketConditions.
     */
    data: MarketConditionCreateManyInput | MarketConditionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MarketCondition update
   */
  export type MarketConditionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketCondition
     */
    select?: MarketConditionSelect<ExtArgs> | null
    /**
     * The data needed to update a MarketCondition.
     */
    data: XOR<MarketConditionUpdateInput, MarketConditionUncheckedUpdateInput>
    /**
     * Choose, which MarketCondition to update.
     */
    where: MarketConditionWhereUniqueInput
  }

  /**
   * MarketCondition updateMany
   */
  export type MarketConditionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MarketConditions.
     */
    data: XOR<MarketConditionUpdateManyMutationInput, MarketConditionUncheckedUpdateManyInput>
    /**
     * Filter which MarketConditions to update
     */
    where?: MarketConditionWhereInput
  }

  /**
   * MarketCondition upsert
   */
  export type MarketConditionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketCondition
     */
    select?: MarketConditionSelect<ExtArgs> | null
    /**
     * The filter to search for the MarketCondition to update in case it exists.
     */
    where: MarketConditionWhereUniqueInput
    /**
     * In case the MarketCondition found by the `where` argument doesn't exist, create a new MarketCondition with this data.
     */
    create: XOR<MarketConditionCreateInput, MarketConditionUncheckedCreateInput>
    /**
     * In case the MarketCondition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MarketConditionUpdateInput, MarketConditionUncheckedUpdateInput>
  }

  /**
   * MarketCondition delete
   */
  export type MarketConditionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketCondition
     */
    select?: MarketConditionSelect<ExtArgs> | null
    /**
     * Filter which MarketCondition to delete.
     */
    where: MarketConditionWhereUniqueInput
  }

  /**
   * MarketCondition deleteMany
   */
  export type MarketConditionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketConditions to delete
     */
    where?: MarketConditionWhereInput
  }

  /**
   * MarketCondition without action
   */
  export type MarketConditionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketCondition
     */
    select?: MarketConditionSelect<ExtArgs> | null
  }


  /**
   * Model LeaderboardEntry
   */

  export type AggregateLeaderboardEntry = {
    _count: LeaderboardEntryCountAggregateOutputType | null
    _avg: LeaderboardEntryAvgAggregateOutputType | null
    _sum: LeaderboardEntrySumAggregateOutputType | null
    _min: LeaderboardEntryMinAggregateOutputType | null
    _max: LeaderboardEntryMaxAggregateOutputType | null
  }

  export type LeaderboardEntryAvgAggregateOutputType = {
    trades: number | null
    winningTrades: number | null
    losingTrades: number | null
    profit: number | null
    volume: number | null
    winRate: number | null
    rank: number | null
    previousRank: number | null
  }

  export type LeaderboardEntrySumAggregateOutputType = {
    trades: number | null
    winningTrades: number | null
    losingTrades: number | null
    profit: number | null
    volume: number | null
    winRate: number | null
    rank: number | null
    previousRank: number | null
  }

  export type LeaderboardEntryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    period: string | null
    periodDate: Date | null
    trades: number | null
    winningTrades: number | null
    losingTrades: number | null
    profit: number | null
    volume: number | null
    winRate: number | null
    rank: number | null
    previousRank: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeaderboardEntryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    period: string | null
    periodDate: Date | null
    trades: number | null
    winningTrades: number | null
    losingTrades: number | null
    profit: number | null
    volume: number | null
    winRate: number | null
    rank: number | null
    previousRank: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeaderboardEntryCountAggregateOutputType = {
    id: number
    userId: number
    period: number
    periodDate: number
    trades: number
    winningTrades: number
    losingTrades: number
    profit: number
    volume: number
    winRate: number
    rank: number
    previousRank: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LeaderboardEntryAvgAggregateInputType = {
    trades?: true
    winningTrades?: true
    losingTrades?: true
    profit?: true
    volume?: true
    winRate?: true
    rank?: true
    previousRank?: true
  }

  export type LeaderboardEntrySumAggregateInputType = {
    trades?: true
    winningTrades?: true
    losingTrades?: true
    profit?: true
    volume?: true
    winRate?: true
    rank?: true
    previousRank?: true
  }

  export type LeaderboardEntryMinAggregateInputType = {
    id?: true
    userId?: true
    period?: true
    periodDate?: true
    trades?: true
    winningTrades?: true
    losingTrades?: true
    profit?: true
    volume?: true
    winRate?: true
    rank?: true
    previousRank?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeaderboardEntryMaxAggregateInputType = {
    id?: true
    userId?: true
    period?: true
    periodDate?: true
    trades?: true
    winningTrades?: true
    losingTrades?: true
    profit?: true
    volume?: true
    winRate?: true
    rank?: true
    previousRank?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeaderboardEntryCountAggregateInputType = {
    id?: true
    userId?: true
    period?: true
    periodDate?: true
    trades?: true
    winningTrades?: true
    losingTrades?: true
    profit?: true
    volume?: true
    winRate?: true
    rank?: true
    previousRank?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LeaderboardEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaderboardEntry to aggregate.
     */
    where?: LeaderboardEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaderboardEntries to fetch.
     */
    orderBy?: LeaderboardEntryOrderByWithRelationInput | LeaderboardEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaderboardEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaderboardEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaderboardEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeaderboardEntries
    **/
    _count?: true | LeaderboardEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeaderboardEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeaderboardEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaderboardEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaderboardEntryMaxAggregateInputType
  }

  export type GetLeaderboardEntryAggregateType<T extends LeaderboardEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateLeaderboardEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeaderboardEntry[P]>
      : GetScalarType<T[P], AggregateLeaderboardEntry[P]>
  }




  export type LeaderboardEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaderboardEntryWhereInput
    orderBy?: LeaderboardEntryOrderByWithAggregationInput | LeaderboardEntryOrderByWithAggregationInput[]
    by: LeaderboardEntryScalarFieldEnum[] | LeaderboardEntryScalarFieldEnum
    having?: LeaderboardEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaderboardEntryCountAggregateInputType | true
    _avg?: LeaderboardEntryAvgAggregateInputType
    _sum?: LeaderboardEntrySumAggregateInputType
    _min?: LeaderboardEntryMinAggregateInputType
    _max?: LeaderboardEntryMaxAggregateInputType
  }

  export type LeaderboardEntryGroupByOutputType = {
    id: string
    userId: string
    period: string
    periodDate: Date
    trades: number
    winningTrades: number
    losingTrades: number
    profit: number
    volume: number
    winRate: number
    rank: number | null
    previousRank: number | null
    createdAt: Date
    updatedAt: Date
    _count: LeaderboardEntryCountAggregateOutputType | null
    _avg: LeaderboardEntryAvgAggregateOutputType | null
    _sum: LeaderboardEntrySumAggregateOutputType | null
    _min: LeaderboardEntryMinAggregateOutputType | null
    _max: LeaderboardEntryMaxAggregateOutputType | null
  }

  type GetLeaderboardEntryGroupByPayload<T extends LeaderboardEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaderboardEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaderboardEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaderboardEntryGroupByOutputType[P]>
            : GetScalarType<T[P], LeaderboardEntryGroupByOutputType[P]>
        }
      >
    >


  export type LeaderboardEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    period?: boolean
    periodDate?: boolean
    trades?: boolean
    winningTrades?: boolean
    losingTrades?: boolean
    profit?: boolean
    volume?: boolean
    winRate?: boolean
    rank?: boolean
    previousRank?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaderboardEntry"]>

  export type LeaderboardEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    period?: boolean
    periodDate?: boolean
    trades?: boolean
    winningTrades?: boolean
    losingTrades?: boolean
    profit?: boolean
    volume?: boolean
    winRate?: boolean
    rank?: boolean
    previousRank?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaderboardEntry"]>

  export type LeaderboardEntrySelectScalar = {
    id?: boolean
    userId?: boolean
    period?: boolean
    periodDate?: boolean
    trades?: boolean
    winningTrades?: boolean
    losingTrades?: boolean
    profit?: boolean
    volume?: boolean
    winRate?: boolean
    rank?: boolean
    previousRank?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LeaderboardEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LeaderboardEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LeaderboardEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeaderboardEntry"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      period: string
      periodDate: Date
      trades: number
      winningTrades: number
      losingTrades: number
      profit: number
      volume: number
      winRate: number
      rank: number | null
      previousRank: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["leaderboardEntry"]>
    composites: {}
  }

  type LeaderboardEntryGetPayload<S extends boolean | null | undefined | LeaderboardEntryDefaultArgs> = $Result.GetResult<Prisma.$LeaderboardEntryPayload, S>

  type LeaderboardEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LeaderboardEntryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LeaderboardEntryCountAggregateInputType | true
    }

  export interface LeaderboardEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeaderboardEntry'], meta: { name: 'LeaderboardEntry' } }
    /**
     * Find zero or one LeaderboardEntry that matches the filter.
     * @param {LeaderboardEntryFindUniqueArgs} args - Arguments to find a LeaderboardEntry
     * @example
     * // Get one LeaderboardEntry
     * const leaderboardEntry = await prisma.leaderboardEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeaderboardEntryFindUniqueArgs>(args: SelectSubset<T, LeaderboardEntryFindUniqueArgs<ExtArgs>>): Prisma__LeaderboardEntryClient<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LeaderboardEntry that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LeaderboardEntryFindUniqueOrThrowArgs} args - Arguments to find a LeaderboardEntry
     * @example
     * // Get one LeaderboardEntry
     * const leaderboardEntry = await prisma.leaderboardEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeaderboardEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, LeaderboardEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeaderboardEntryClient<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LeaderboardEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardEntryFindFirstArgs} args - Arguments to find a LeaderboardEntry
     * @example
     * // Get one LeaderboardEntry
     * const leaderboardEntry = await prisma.leaderboardEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeaderboardEntryFindFirstArgs>(args?: SelectSubset<T, LeaderboardEntryFindFirstArgs<ExtArgs>>): Prisma__LeaderboardEntryClient<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LeaderboardEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardEntryFindFirstOrThrowArgs} args - Arguments to find a LeaderboardEntry
     * @example
     * // Get one LeaderboardEntry
     * const leaderboardEntry = await prisma.leaderboardEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeaderboardEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, LeaderboardEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeaderboardEntryClient<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LeaderboardEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeaderboardEntries
     * const leaderboardEntries = await prisma.leaderboardEntry.findMany()
     * 
     * // Get first 10 LeaderboardEntries
     * const leaderboardEntries = await prisma.leaderboardEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaderboardEntryWithIdOnly = await prisma.leaderboardEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeaderboardEntryFindManyArgs>(args?: SelectSubset<T, LeaderboardEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LeaderboardEntry.
     * @param {LeaderboardEntryCreateArgs} args - Arguments to create a LeaderboardEntry.
     * @example
     * // Create one LeaderboardEntry
     * const LeaderboardEntry = await prisma.leaderboardEntry.create({
     *   data: {
     *     // ... data to create a LeaderboardEntry
     *   }
     * })
     * 
     */
    create<T extends LeaderboardEntryCreateArgs>(args: SelectSubset<T, LeaderboardEntryCreateArgs<ExtArgs>>): Prisma__LeaderboardEntryClient<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LeaderboardEntries.
     * @param {LeaderboardEntryCreateManyArgs} args - Arguments to create many LeaderboardEntries.
     * @example
     * // Create many LeaderboardEntries
     * const leaderboardEntry = await prisma.leaderboardEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeaderboardEntryCreateManyArgs>(args?: SelectSubset<T, LeaderboardEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LeaderboardEntries and returns the data saved in the database.
     * @param {LeaderboardEntryCreateManyAndReturnArgs} args - Arguments to create many LeaderboardEntries.
     * @example
     * // Create many LeaderboardEntries
     * const leaderboardEntry = await prisma.leaderboardEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LeaderboardEntries and only return the `id`
     * const leaderboardEntryWithIdOnly = await prisma.leaderboardEntry.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeaderboardEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, LeaderboardEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LeaderboardEntry.
     * @param {LeaderboardEntryDeleteArgs} args - Arguments to delete one LeaderboardEntry.
     * @example
     * // Delete one LeaderboardEntry
     * const LeaderboardEntry = await prisma.leaderboardEntry.delete({
     *   where: {
     *     // ... filter to delete one LeaderboardEntry
     *   }
     * })
     * 
     */
    delete<T extends LeaderboardEntryDeleteArgs>(args: SelectSubset<T, LeaderboardEntryDeleteArgs<ExtArgs>>): Prisma__LeaderboardEntryClient<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LeaderboardEntry.
     * @param {LeaderboardEntryUpdateArgs} args - Arguments to update one LeaderboardEntry.
     * @example
     * // Update one LeaderboardEntry
     * const leaderboardEntry = await prisma.leaderboardEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeaderboardEntryUpdateArgs>(args: SelectSubset<T, LeaderboardEntryUpdateArgs<ExtArgs>>): Prisma__LeaderboardEntryClient<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LeaderboardEntries.
     * @param {LeaderboardEntryDeleteManyArgs} args - Arguments to filter LeaderboardEntries to delete.
     * @example
     * // Delete a few LeaderboardEntries
     * const { count } = await prisma.leaderboardEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeaderboardEntryDeleteManyArgs>(args?: SelectSubset<T, LeaderboardEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeaderboardEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeaderboardEntries
     * const leaderboardEntry = await prisma.leaderboardEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeaderboardEntryUpdateManyArgs>(args: SelectSubset<T, LeaderboardEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LeaderboardEntry.
     * @param {LeaderboardEntryUpsertArgs} args - Arguments to update or create a LeaderboardEntry.
     * @example
     * // Update or create a LeaderboardEntry
     * const leaderboardEntry = await prisma.leaderboardEntry.upsert({
     *   create: {
     *     // ... data to create a LeaderboardEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeaderboardEntry we want to update
     *   }
     * })
     */
    upsert<T extends LeaderboardEntryUpsertArgs>(args: SelectSubset<T, LeaderboardEntryUpsertArgs<ExtArgs>>): Prisma__LeaderboardEntryClient<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LeaderboardEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardEntryCountArgs} args - Arguments to filter LeaderboardEntries to count.
     * @example
     * // Count the number of LeaderboardEntries
     * const count = await prisma.leaderboardEntry.count({
     *   where: {
     *     // ... the filter for the LeaderboardEntries we want to count
     *   }
     * })
    **/
    count<T extends LeaderboardEntryCountArgs>(
      args?: Subset<T, LeaderboardEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaderboardEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeaderboardEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaderboardEntryAggregateArgs>(args: Subset<T, LeaderboardEntryAggregateArgs>): Prisma.PrismaPromise<GetLeaderboardEntryAggregateType<T>>

    /**
     * Group by LeaderboardEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaderboardEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaderboardEntryGroupByArgs['orderBy'] }
        : { orderBy?: LeaderboardEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaderboardEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaderboardEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeaderboardEntry model
   */
  readonly fields: LeaderboardEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeaderboardEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaderboardEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LeaderboardEntry model
   */ 
  interface LeaderboardEntryFieldRefs {
    readonly id: FieldRef<"LeaderboardEntry", 'String'>
    readonly userId: FieldRef<"LeaderboardEntry", 'String'>
    readonly period: FieldRef<"LeaderboardEntry", 'String'>
    readonly periodDate: FieldRef<"LeaderboardEntry", 'DateTime'>
    readonly trades: FieldRef<"LeaderboardEntry", 'Int'>
    readonly winningTrades: FieldRef<"LeaderboardEntry", 'Int'>
    readonly losingTrades: FieldRef<"LeaderboardEntry", 'Int'>
    readonly profit: FieldRef<"LeaderboardEntry", 'Float'>
    readonly volume: FieldRef<"LeaderboardEntry", 'Float'>
    readonly winRate: FieldRef<"LeaderboardEntry", 'Float'>
    readonly rank: FieldRef<"LeaderboardEntry", 'Int'>
    readonly previousRank: FieldRef<"LeaderboardEntry", 'Int'>
    readonly createdAt: FieldRef<"LeaderboardEntry", 'DateTime'>
    readonly updatedAt: FieldRef<"LeaderboardEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LeaderboardEntry findUnique
   */
  export type LeaderboardEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
    /**
     * Filter, which LeaderboardEntry to fetch.
     */
    where: LeaderboardEntryWhereUniqueInput
  }

  /**
   * LeaderboardEntry findUniqueOrThrow
   */
  export type LeaderboardEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
    /**
     * Filter, which LeaderboardEntry to fetch.
     */
    where: LeaderboardEntryWhereUniqueInput
  }

  /**
   * LeaderboardEntry findFirst
   */
  export type LeaderboardEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
    /**
     * Filter, which LeaderboardEntry to fetch.
     */
    where?: LeaderboardEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaderboardEntries to fetch.
     */
    orderBy?: LeaderboardEntryOrderByWithRelationInput | LeaderboardEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaderboardEntries.
     */
    cursor?: LeaderboardEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaderboardEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaderboardEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaderboardEntries.
     */
    distinct?: LeaderboardEntryScalarFieldEnum | LeaderboardEntryScalarFieldEnum[]
  }

  /**
   * LeaderboardEntry findFirstOrThrow
   */
  export type LeaderboardEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
    /**
     * Filter, which LeaderboardEntry to fetch.
     */
    where?: LeaderboardEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaderboardEntries to fetch.
     */
    orderBy?: LeaderboardEntryOrderByWithRelationInput | LeaderboardEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaderboardEntries.
     */
    cursor?: LeaderboardEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaderboardEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaderboardEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaderboardEntries.
     */
    distinct?: LeaderboardEntryScalarFieldEnum | LeaderboardEntryScalarFieldEnum[]
  }

  /**
   * LeaderboardEntry findMany
   */
  export type LeaderboardEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
    /**
     * Filter, which LeaderboardEntries to fetch.
     */
    where?: LeaderboardEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaderboardEntries to fetch.
     */
    orderBy?: LeaderboardEntryOrderByWithRelationInput | LeaderboardEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeaderboardEntries.
     */
    cursor?: LeaderboardEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaderboardEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaderboardEntries.
     */
    skip?: number
    distinct?: LeaderboardEntryScalarFieldEnum | LeaderboardEntryScalarFieldEnum[]
  }

  /**
   * LeaderboardEntry create
   */
  export type LeaderboardEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a LeaderboardEntry.
     */
    data: XOR<LeaderboardEntryCreateInput, LeaderboardEntryUncheckedCreateInput>
  }

  /**
   * LeaderboardEntry createMany
   */
  export type LeaderboardEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeaderboardEntries.
     */
    data: LeaderboardEntryCreateManyInput | LeaderboardEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeaderboardEntry createManyAndReturn
   */
  export type LeaderboardEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LeaderboardEntries.
     */
    data: LeaderboardEntryCreateManyInput | LeaderboardEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeaderboardEntry update
   */
  export type LeaderboardEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a LeaderboardEntry.
     */
    data: XOR<LeaderboardEntryUpdateInput, LeaderboardEntryUncheckedUpdateInput>
    /**
     * Choose, which LeaderboardEntry to update.
     */
    where: LeaderboardEntryWhereUniqueInput
  }

  /**
   * LeaderboardEntry updateMany
   */
  export type LeaderboardEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeaderboardEntries.
     */
    data: XOR<LeaderboardEntryUpdateManyMutationInput, LeaderboardEntryUncheckedUpdateManyInput>
    /**
     * Filter which LeaderboardEntries to update
     */
    where?: LeaderboardEntryWhereInput
  }

  /**
   * LeaderboardEntry upsert
   */
  export type LeaderboardEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the LeaderboardEntry to update in case it exists.
     */
    where: LeaderboardEntryWhereUniqueInput
    /**
     * In case the LeaderboardEntry found by the `where` argument doesn't exist, create a new LeaderboardEntry with this data.
     */
    create: XOR<LeaderboardEntryCreateInput, LeaderboardEntryUncheckedCreateInput>
    /**
     * In case the LeaderboardEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaderboardEntryUpdateInput, LeaderboardEntryUncheckedUpdateInput>
  }

  /**
   * LeaderboardEntry delete
   */
  export type LeaderboardEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
    /**
     * Filter which LeaderboardEntry to delete.
     */
    where: LeaderboardEntryWhereUniqueInput
  }

  /**
   * LeaderboardEntry deleteMany
   */
  export type LeaderboardEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaderboardEntries to delete
     */
    where?: LeaderboardEntryWhereInput
  }

  /**
   * LeaderboardEntry without action
   */
  export type LeaderboardEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
  }


  /**
   * Model IBPartner
   */

  export type AggregateIBPartner = {
    _count: IBPartnerCountAggregateOutputType | null
    _avg: IBPartnerAvgAggregateOutputType | null
    _sum: IBPartnerSumAggregateOutputType | null
    _min: IBPartnerMinAggregateOutputType | null
    _max: IBPartnerMaxAggregateOutputType | null
  }

  export type IBPartnerAvgAggregateOutputType = {
    monthlyFee: number | null
    traderLimit: number | null
    spreadRevShare: number | null
    totalTraders: number | null
    activeTraders: number | null
    monthlyRevenue: number | null
    lifetimeRevenue: number | null
  }

  export type IBPartnerSumAggregateOutputType = {
    monthlyFee: number | null
    traderLimit: number | null
    spreadRevShare: number | null
    totalTraders: number | null
    activeTraders: number | null
    monthlyRevenue: number | null
    lifetimeRevenue: number | null
  }

  export type IBPartnerMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    companyName: string | null
    contactName: string | null
    phone: string | null
    ibCode: string | null
    domain: string | null
    logo: string | null
    favicon: string | null
    brandColor: string | null
    brandName: string | null
    isActive: boolean | null
    isApproved: boolean | null
    currentTraders: string | null
    message: string | null
    companyDocument: string | null
    idDocument: string | null
    kycDocument: string | null
    kycStatus: string | null
    emailVerified: boolean | null
    verificationCode: string | null
    verificationExpiry: Date | null
    pricingTier: string | null
    monthlyFee: number | null
    traderLimit: number | null
    spreadRevShare: number | null
    totalTraders: number | null
    activeTraders: number | null
    monthlyRevenue: number | null
    lifetimeRevenue: number | null
    createdAt: Date | null
    updatedAt: Date | null
    approvedAt: Date | null
    approvedBy: string | null
  }

  export type IBPartnerMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    companyName: string | null
    contactName: string | null
    phone: string | null
    ibCode: string | null
    domain: string | null
    logo: string | null
    favicon: string | null
    brandColor: string | null
    brandName: string | null
    isActive: boolean | null
    isApproved: boolean | null
    currentTraders: string | null
    message: string | null
    companyDocument: string | null
    idDocument: string | null
    kycDocument: string | null
    kycStatus: string | null
    emailVerified: boolean | null
    verificationCode: string | null
    verificationExpiry: Date | null
    pricingTier: string | null
    monthlyFee: number | null
    traderLimit: number | null
    spreadRevShare: number | null
    totalTraders: number | null
    activeTraders: number | null
    monthlyRevenue: number | null
    lifetimeRevenue: number | null
    createdAt: Date | null
    updatedAt: Date | null
    approvedAt: Date | null
    approvedBy: string | null
  }

  export type IBPartnerCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    companyName: number
    contactName: number
    phone: number
    ibCode: number
    domain: number
    logo: number
    favicon: number
    brandColor: number
    brandName: number
    isActive: number
    isApproved: number
    currentTraders: number
    message: number
    companyDocument: number
    idDocument: number
    kycDocument: number
    kycStatus: number
    emailVerified: number
    verificationCode: number
    verificationExpiry: number
    pricingTier: number
    monthlyFee: number
    traderLimit: number
    spreadRevShare: number
    totalTraders: number
    activeTraders: number
    monthlyRevenue: number
    lifetimeRevenue: number
    createdAt: number
    updatedAt: number
    approvedAt: number
    approvedBy: number
    _all: number
  }


  export type IBPartnerAvgAggregateInputType = {
    monthlyFee?: true
    traderLimit?: true
    spreadRevShare?: true
    totalTraders?: true
    activeTraders?: true
    monthlyRevenue?: true
    lifetimeRevenue?: true
  }

  export type IBPartnerSumAggregateInputType = {
    monthlyFee?: true
    traderLimit?: true
    spreadRevShare?: true
    totalTraders?: true
    activeTraders?: true
    monthlyRevenue?: true
    lifetimeRevenue?: true
  }

  export type IBPartnerMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    companyName?: true
    contactName?: true
    phone?: true
    ibCode?: true
    domain?: true
    logo?: true
    favicon?: true
    brandColor?: true
    brandName?: true
    isActive?: true
    isApproved?: true
    currentTraders?: true
    message?: true
    companyDocument?: true
    idDocument?: true
    kycDocument?: true
    kycStatus?: true
    emailVerified?: true
    verificationCode?: true
    verificationExpiry?: true
    pricingTier?: true
    monthlyFee?: true
    traderLimit?: true
    spreadRevShare?: true
    totalTraders?: true
    activeTraders?: true
    monthlyRevenue?: true
    lifetimeRevenue?: true
    createdAt?: true
    updatedAt?: true
    approvedAt?: true
    approvedBy?: true
  }

  export type IBPartnerMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    companyName?: true
    contactName?: true
    phone?: true
    ibCode?: true
    domain?: true
    logo?: true
    favicon?: true
    brandColor?: true
    brandName?: true
    isActive?: true
    isApproved?: true
    currentTraders?: true
    message?: true
    companyDocument?: true
    idDocument?: true
    kycDocument?: true
    kycStatus?: true
    emailVerified?: true
    verificationCode?: true
    verificationExpiry?: true
    pricingTier?: true
    monthlyFee?: true
    traderLimit?: true
    spreadRevShare?: true
    totalTraders?: true
    activeTraders?: true
    monthlyRevenue?: true
    lifetimeRevenue?: true
    createdAt?: true
    updatedAt?: true
    approvedAt?: true
    approvedBy?: true
  }

  export type IBPartnerCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    companyName?: true
    contactName?: true
    phone?: true
    ibCode?: true
    domain?: true
    logo?: true
    favicon?: true
    brandColor?: true
    brandName?: true
    isActive?: true
    isApproved?: true
    currentTraders?: true
    message?: true
    companyDocument?: true
    idDocument?: true
    kycDocument?: true
    kycStatus?: true
    emailVerified?: true
    verificationCode?: true
    verificationExpiry?: true
    pricingTier?: true
    monthlyFee?: true
    traderLimit?: true
    spreadRevShare?: true
    totalTraders?: true
    activeTraders?: true
    monthlyRevenue?: true
    lifetimeRevenue?: true
    createdAt?: true
    updatedAt?: true
    approvedAt?: true
    approvedBy?: true
    _all?: true
  }

  export type IBPartnerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IBPartner to aggregate.
     */
    where?: IBPartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IBPartners to fetch.
     */
    orderBy?: IBPartnerOrderByWithRelationInput | IBPartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IBPartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IBPartners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IBPartners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IBPartners
    **/
    _count?: true | IBPartnerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IBPartnerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IBPartnerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IBPartnerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IBPartnerMaxAggregateInputType
  }

  export type GetIBPartnerAggregateType<T extends IBPartnerAggregateArgs> = {
        [P in keyof T & keyof AggregateIBPartner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIBPartner[P]>
      : GetScalarType<T[P], AggregateIBPartner[P]>
  }




  export type IBPartnerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IBPartnerWhereInput
    orderBy?: IBPartnerOrderByWithAggregationInput | IBPartnerOrderByWithAggregationInput[]
    by: IBPartnerScalarFieldEnum[] | IBPartnerScalarFieldEnum
    having?: IBPartnerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IBPartnerCountAggregateInputType | true
    _avg?: IBPartnerAvgAggregateInputType
    _sum?: IBPartnerSumAggregateInputType
    _min?: IBPartnerMinAggregateInputType
    _max?: IBPartnerMaxAggregateInputType
  }

  export type IBPartnerGroupByOutputType = {
    id: string
    email: string
    passwordHash: string
    companyName: string
    contactName: string
    phone: string
    ibCode: string
    domain: string | null
    logo: string | null
    favicon: string | null
    brandColor: string
    brandName: string | null
    isActive: boolean
    isApproved: boolean
    currentTraders: string | null
    message: string | null
    companyDocument: string | null
    idDocument: string | null
    kycDocument: string | null
    kycStatus: string
    emailVerified: boolean
    verificationCode: string | null
    verificationExpiry: Date | null
    pricingTier: string
    monthlyFee: number
    traderLimit: number
    spreadRevShare: number
    totalTraders: number
    activeTraders: number
    monthlyRevenue: number
    lifetimeRevenue: number
    createdAt: Date
    updatedAt: Date
    approvedAt: Date | null
    approvedBy: string | null
    _count: IBPartnerCountAggregateOutputType | null
    _avg: IBPartnerAvgAggregateOutputType | null
    _sum: IBPartnerSumAggregateOutputType | null
    _min: IBPartnerMinAggregateOutputType | null
    _max: IBPartnerMaxAggregateOutputType | null
  }

  type GetIBPartnerGroupByPayload<T extends IBPartnerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IBPartnerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IBPartnerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IBPartnerGroupByOutputType[P]>
            : GetScalarType<T[P], IBPartnerGroupByOutputType[P]>
        }
      >
    >


  export type IBPartnerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    companyName?: boolean
    contactName?: boolean
    phone?: boolean
    ibCode?: boolean
    domain?: boolean
    logo?: boolean
    favicon?: boolean
    brandColor?: boolean
    brandName?: boolean
    isActive?: boolean
    isApproved?: boolean
    currentTraders?: boolean
    message?: boolean
    companyDocument?: boolean
    idDocument?: boolean
    kycDocument?: boolean
    kycStatus?: boolean
    emailVerified?: boolean
    verificationCode?: boolean
    verificationExpiry?: boolean
    pricingTier?: boolean
    monthlyFee?: boolean
    traderLimit?: boolean
    spreadRevShare?: boolean
    totalTraders?: boolean
    activeTraders?: boolean
    monthlyRevenue?: boolean
    lifetimeRevenue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    approvedAt?: boolean
    approvedBy?: boolean
    users?: boolean | IBPartner$usersArgs<ExtArgs>
    anonymousAccounts?: boolean | IBPartner$anonymousAccountsArgs<ExtArgs>
    commissions?: boolean | IBPartner$commissionsArgs<ExtArgs>
    commissionRates?: boolean | IBPartner$commissionRatesArgs<ExtArgs>
    _count?: boolean | IBPartnerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["iBPartner"]>

  export type IBPartnerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    companyName?: boolean
    contactName?: boolean
    phone?: boolean
    ibCode?: boolean
    domain?: boolean
    logo?: boolean
    favicon?: boolean
    brandColor?: boolean
    brandName?: boolean
    isActive?: boolean
    isApproved?: boolean
    currentTraders?: boolean
    message?: boolean
    companyDocument?: boolean
    idDocument?: boolean
    kycDocument?: boolean
    kycStatus?: boolean
    emailVerified?: boolean
    verificationCode?: boolean
    verificationExpiry?: boolean
    pricingTier?: boolean
    monthlyFee?: boolean
    traderLimit?: boolean
    spreadRevShare?: boolean
    totalTraders?: boolean
    activeTraders?: boolean
    monthlyRevenue?: boolean
    lifetimeRevenue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    approvedAt?: boolean
    approvedBy?: boolean
  }, ExtArgs["result"]["iBPartner"]>

  export type IBPartnerSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    companyName?: boolean
    contactName?: boolean
    phone?: boolean
    ibCode?: boolean
    domain?: boolean
    logo?: boolean
    favicon?: boolean
    brandColor?: boolean
    brandName?: boolean
    isActive?: boolean
    isApproved?: boolean
    currentTraders?: boolean
    message?: boolean
    companyDocument?: boolean
    idDocument?: boolean
    kycDocument?: boolean
    kycStatus?: boolean
    emailVerified?: boolean
    verificationCode?: boolean
    verificationExpiry?: boolean
    pricingTier?: boolean
    monthlyFee?: boolean
    traderLimit?: boolean
    spreadRevShare?: boolean
    totalTraders?: boolean
    activeTraders?: boolean
    monthlyRevenue?: boolean
    lifetimeRevenue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    approvedAt?: boolean
    approvedBy?: boolean
  }

  export type IBPartnerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | IBPartner$usersArgs<ExtArgs>
    anonymousAccounts?: boolean | IBPartner$anonymousAccountsArgs<ExtArgs>
    commissions?: boolean | IBPartner$commissionsArgs<ExtArgs>
    commissionRates?: boolean | IBPartner$commissionRatesArgs<ExtArgs>
    _count?: boolean | IBPartnerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type IBPartnerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $IBPartnerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IBPartner"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      anonymousAccounts: Prisma.$AnonymousAccountPayload<ExtArgs>[]
      commissions: Prisma.$IBCommissionPayload<ExtArgs>[]
      commissionRates: Prisma.$IBCommissionRatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string
      companyName: string
      contactName: string
      phone: string
      ibCode: string
      domain: string | null
      logo: string | null
      favicon: string | null
      brandColor: string
      brandName: string | null
      isActive: boolean
      isApproved: boolean
      currentTraders: string | null
      message: string | null
      companyDocument: string | null
      idDocument: string | null
      kycDocument: string | null
      kycStatus: string
      emailVerified: boolean
      verificationCode: string | null
      verificationExpiry: Date | null
      pricingTier: string
      monthlyFee: number
      traderLimit: number
      spreadRevShare: number
      totalTraders: number
      activeTraders: number
      monthlyRevenue: number
      lifetimeRevenue: number
      createdAt: Date
      updatedAt: Date
      approvedAt: Date | null
      approvedBy: string | null
    }, ExtArgs["result"]["iBPartner"]>
    composites: {}
  }

  type IBPartnerGetPayload<S extends boolean | null | undefined | IBPartnerDefaultArgs> = $Result.GetResult<Prisma.$IBPartnerPayload, S>

  type IBPartnerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IBPartnerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IBPartnerCountAggregateInputType | true
    }

  export interface IBPartnerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IBPartner'], meta: { name: 'IBPartner' } }
    /**
     * Find zero or one IBPartner that matches the filter.
     * @param {IBPartnerFindUniqueArgs} args - Arguments to find a IBPartner
     * @example
     * // Get one IBPartner
     * const iBPartner = await prisma.iBPartner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IBPartnerFindUniqueArgs>(args: SelectSubset<T, IBPartnerFindUniqueArgs<ExtArgs>>): Prisma__IBPartnerClient<$Result.GetResult<Prisma.$IBPartnerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one IBPartner that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IBPartnerFindUniqueOrThrowArgs} args - Arguments to find a IBPartner
     * @example
     * // Get one IBPartner
     * const iBPartner = await prisma.iBPartner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IBPartnerFindUniqueOrThrowArgs>(args: SelectSubset<T, IBPartnerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IBPartnerClient<$Result.GetResult<Prisma.$IBPartnerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first IBPartner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IBPartnerFindFirstArgs} args - Arguments to find a IBPartner
     * @example
     * // Get one IBPartner
     * const iBPartner = await prisma.iBPartner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IBPartnerFindFirstArgs>(args?: SelectSubset<T, IBPartnerFindFirstArgs<ExtArgs>>): Prisma__IBPartnerClient<$Result.GetResult<Prisma.$IBPartnerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first IBPartner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IBPartnerFindFirstOrThrowArgs} args - Arguments to find a IBPartner
     * @example
     * // Get one IBPartner
     * const iBPartner = await prisma.iBPartner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IBPartnerFindFirstOrThrowArgs>(args?: SelectSubset<T, IBPartnerFindFirstOrThrowArgs<ExtArgs>>): Prisma__IBPartnerClient<$Result.GetResult<Prisma.$IBPartnerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more IBPartners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IBPartnerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IBPartners
     * const iBPartners = await prisma.iBPartner.findMany()
     * 
     * // Get first 10 IBPartners
     * const iBPartners = await prisma.iBPartner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const iBPartnerWithIdOnly = await prisma.iBPartner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IBPartnerFindManyArgs>(args?: SelectSubset<T, IBPartnerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IBPartnerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a IBPartner.
     * @param {IBPartnerCreateArgs} args - Arguments to create a IBPartner.
     * @example
     * // Create one IBPartner
     * const IBPartner = await prisma.iBPartner.create({
     *   data: {
     *     // ... data to create a IBPartner
     *   }
     * })
     * 
     */
    create<T extends IBPartnerCreateArgs>(args: SelectSubset<T, IBPartnerCreateArgs<ExtArgs>>): Prisma__IBPartnerClient<$Result.GetResult<Prisma.$IBPartnerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many IBPartners.
     * @param {IBPartnerCreateManyArgs} args - Arguments to create many IBPartners.
     * @example
     * // Create many IBPartners
     * const iBPartner = await prisma.iBPartner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IBPartnerCreateManyArgs>(args?: SelectSubset<T, IBPartnerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IBPartners and returns the data saved in the database.
     * @param {IBPartnerCreateManyAndReturnArgs} args - Arguments to create many IBPartners.
     * @example
     * // Create many IBPartners
     * const iBPartner = await prisma.iBPartner.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IBPartners and only return the `id`
     * const iBPartnerWithIdOnly = await prisma.iBPartner.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IBPartnerCreateManyAndReturnArgs>(args?: SelectSubset<T, IBPartnerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IBPartnerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a IBPartner.
     * @param {IBPartnerDeleteArgs} args - Arguments to delete one IBPartner.
     * @example
     * // Delete one IBPartner
     * const IBPartner = await prisma.iBPartner.delete({
     *   where: {
     *     // ... filter to delete one IBPartner
     *   }
     * })
     * 
     */
    delete<T extends IBPartnerDeleteArgs>(args: SelectSubset<T, IBPartnerDeleteArgs<ExtArgs>>): Prisma__IBPartnerClient<$Result.GetResult<Prisma.$IBPartnerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one IBPartner.
     * @param {IBPartnerUpdateArgs} args - Arguments to update one IBPartner.
     * @example
     * // Update one IBPartner
     * const iBPartner = await prisma.iBPartner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IBPartnerUpdateArgs>(args: SelectSubset<T, IBPartnerUpdateArgs<ExtArgs>>): Prisma__IBPartnerClient<$Result.GetResult<Prisma.$IBPartnerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more IBPartners.
     * @param {IBPartnerDeleteManyArgs} args - Arguments to filter IBPartners to delete.
     * @example
     * // Delete a few IBPartners
     * const { count } = await prisma.iBPartner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IBPartnerDeleteManyArgs>(args?: SelectSubset<T, IBPartnerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IBPartners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IBPartnerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IBPartners
     * const iBPartner = await prisma.iBPartner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IBPartnerUpdateManyArgs>(args: SelectSubset<T, IBPartnerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IBPartner.
     * @param {IBPartnerUpsertArgs} args - Arguments to update or create a IBPartner.
     * @example
     * // Update or create a IBPartner
     * const iBPartner = await prisma.iBPartner.upsert({
     *   create: {
     *     // ... data to create a IBPartner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IBPartner we want to update
     *   }
     * })
     */
    upsert<T extends IBPartnerUpsertArgs>(args: SelectSubset<T, IBPartnerUpsertArgs<ExtArgs>>): Prisma__IBPartnerClient<$Result.GetResult<Prisma.$IBPartnerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of IBPartners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IBPartnerCountArgs} args - Arguments to filter IBPartners to count.
     * @example
     * // Count the number of IBPartners
     * const count = await prisma.iBPartner.count({
     *   where: {
     *     // ... the filter for the IBPartners we want to count
     *   }
     * })
    **/
    count<T extends IBPartnerCountArgs>(
      args?: Subset<T, IBPartnerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IBPartnerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IBPartner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IBPartnerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IBPartnerAggregateArgs>(args: Subset<T, IBPartnerAggregateArgs>): Prisma.PrismaPromise<GetIBPartnerAggregateType<T>>

    /**
     * Group by IBPartner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IBPartnerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IBPartnerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IBPartnerGroupByArgs['orderBy'] }
        : { orderBy?: IBPartnerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IBPartnerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIBPartnerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IBPartner model
   */
  readonly fields: IBPartnerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IBPartner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IBPartnerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends IBPartner$usersArgs<ExtArgs> = {}>(args?: Subset<T, IBPartner$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    anonymousAccounts<T extends IBPartner$anonymousAccountsArgs<ExtArgs> = {}>(args?: Subset<T, IBPartner$anonymousAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnonymousAccountPayload<ExtArgs>, T, "findMany"> | Null>
    commissions<T extends IBPartner$commissionsArgs<ExtArgs> = {}>(args?: Subset<T, IBPartner$commissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IBCommissionPayload<ExtArgs>, T, "findMany"> | Null>
    commissionRates<T extends IBPartner$commissionRatesArgs<ExtArgs> = {}>(args?: Subset<T, IBPartner$commissionRatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IBCommissionRatePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IBPartner model
   */ 
  interface IBPartnerFieldRefs {
    readonly id: FieldRef<"IBPartner", 'String'>
    readonly email: FieldRef<"IBPartner", 'String'>
    readonly passwordHash: FieldRef<"IBPartner", 'String'>
    readonly companyName: FieldRef<"IBPartner", 'String'>
    readonly contactName: FieldRef<"IBPartner", 'String'>
    readonly phone: FieldRef<"IBPartner", 'String'>
    readonly ibCode: FieldRef<"IBPartner", 'String'>
    readonly domain: FieldRef<"IBPartner", 'String'>
    readonly logo: FieldRef<"IBPartner", 'String'>
    readonly favicon: FieldRef<"IBPartner", 'String'>
    readonly brandColor: FieldRef<"IBPartner", 'String'>
    readonly brandName: FieldRef<"IBPartner", 'String'>
    readonly isActive: FieldRef<"IBPartner", 'Boolean'>
    readonly isApproved: FieldRef<"IBPartner", 'Boolean'>
    readonly currentTraders: FieldRef<"IBPartner", 'String'>
    readonly message: FieldRef<"IBPartner", 'String'>
    readonly companyDocument: FieldRef<"IBPartner", 'String'>
    readonly idDocument: FieldRef<"IBPartner", 'String'>
    readonly kycDocument: FieldRef<"IBPartner", 'String'>
    readonly kycStatus: FieldRef<"IBPartner", 'String'>
    readonly emailVerified: FieldRef<"IBPartner", 'Boolean'>
    readonly verificationCode: FieldRef<"IBPartner", 'String'>
    readonly verificationExpiry: FieldRef<"IBPartner", 'DateTime'>
    readonly pricingTier: FieldRef<"IBPartner", 'String'>
    readonly monthlyFee: FieldRef<"IBPartner", 'Float'>
    readonly traderLimit: FieldRef<"IBPartner", 'Int'>
    readonly spreadRevShare: FieldRef<"IBPartner", 'Float'>
    readonly totalTraders: FieldRef<"IBPartner", 'Int'>
    readonly activeTraders: FieldRef<"IBPartner", 'Int'>
    readonly monthlyRevenue: FieldRef<"IBPartner", 'Float'>
    readonly lifetimeRevenue: FieldRef<"IBPartner", 'Float'>
    readonly createdAt: FieldRef<"IBPartner", 'DateTime'>
    readonly updatedAt: FieldRef<"IBPartner", 'DateTime'>
    readonly approvedAt: FieldRef<"IBPartner", 'DateTime'>
    readonly approvedBy: FieldRef<"IBPartner", 'String'>
  }
    

  // Custom InputTypes
  /**
   * IBPartner findUnique
   */
  export type IBPartnerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IBPartner
     */
    select?: IBPartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IBPartnerInclude<ExtArgs> | null
    /**
     * Filter, which IBPartner to fetch.
     */
    where: IBPartnerWhereUniqueInput
  }

  /**
   * IBPartner findUniqueOrThrow
   */
  export type IBPartnerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IBPartner
     */
    select?: IBPartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IBPartnerInclude<ExtArgs> | null
    /**
     * Filter, which IBPartner to fetch.
     */
    where: IBPartnerWhereUniqueInput
  }

  /**
   * IBPartner findFirst
   */
  export type IBPartnerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IBPartner
     */
    select?: IBPartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IBPartnerInclude<ExtArgs> | null
    /**
     * Filter, which IBPartner to fetch.
     */
    where?: IBPartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IBPartners to fetch.
     */
    orderBy?: IBPartnerOrderByWithRelationInput | IBPartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IBPartners.
     */
    cursor?: IBPartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IBPartners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IBPartners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IBPartners.
     */
    distinct?: IBPartnerScalarFieldEnum | IBPartnerScalarFieldEnum[]
  }

  /**
   * IBPartner findFirstOrThrow
   */
  export type IBPartnerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IBPartner
     */
    select?: IBPartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IBPartnerInclude<ExtArgs> | null
    /**
     * Filter, which IBPartner to fetch.
     */
    where?: IBPartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IBPartners to fetch.
     */
    orderBy?: IBPartnerOrderByWithRelationInput | IBPartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IBPartners.
     */
    cursor?: IBPartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IBPartners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IBPartners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IBPartners.
     */
    distinct?: IBPartnerScalarFieldEnum | IBPartnerScalarFieldEnum[]
  }

  /**
   * IBPartner findMany
   */
  export type IBPartnerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IBPartner
     */
    select?: IBPartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IBPartnerInclude<ExtArgs> | null
    /**
     * Filter, which IBPartners to fetch.
     */
    where?: IBPartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IBPartners to fetch.
     */
    orderBy?: IBPartnerOrderByWithRelationInput | IBPartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IBPartners.
     */
    cursor?: IBPartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IBPartners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IBPartners.
     */
    skip?: number
    distinct?: IBPartnerScalarFieldEnum | IBPartnerScalarFieldEnum[]
  }

  /**
   * IBPartner create
   */
  export type IBPartnerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IBPartner
     */
    select?: IBPartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IBPartnerInclude<ExtArgs> | null
    /**
     * The data needed to create a IBPartner.
     */
    data: XOR<IBPartnerCreateInput, IBPartnerUncheckedCreateInput>
  }

  /**
   * IBPartner createMany
   */
  export type IBPartnerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IBPartners.
     */
    data: IBPartnerCreateManyInput | IBPartnerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IBPartner createManyAndReturn
   */
  export type IBPartnerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IBPartner
     */
    select?: IBPartnerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many IBPartners.
     */
    data: IBPartnerCreateManyInput | IBPartnerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IBPartner update
   */
  export type IBPartnerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IBPartner
     */
    select?: IBPartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IBPartnerInclude<ExtArgs> | null
    /**
     * The data needed to update a IBPartner.
     */
    data: XOR<IBPartnerUpdateInput, IBPartnerUncheckedUpdateInput>
    /**
     * Choose, which IBPartner to update.
     */
    where: IBPartnerWhereUniqueInput
  }

  /**
   * IBPartner updateMany
   */
  export type IBPartnerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IBPartners.
     */
    data: XOR<IBPartnerUpdateManyMutationInput, IBPartnerUncheckedUpdateManyInput>
    /**
     * Filter which IBPartners to update
     */
    where?: IBPartnerWhereInput
  }

  /**
   * IBPartner upsert
   */
  export type IBPartnerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IBPartner
     */
    select?: IBPartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IBPartnerInclude<ExtArgs> | null
    /**
     * The filter to search for the IBPartner to update in case it exists.
     */
    where: IBPartnerWhereUniqueInput
    /**
     * In case the IBPartner found by the `where` argument doesn't exist, create a new IBPartner with this data.
     */
    create: XOR<IBPartnerCreateInput, IBPartnerUncheckedCreateInput>
    /**
     * In case the IBPartner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IBPartnerUpdateInput, IBPartnerUncheckedUpdateInput>
  }

  /**
   * IBPartner delete
   */
  export type IBPartnerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IBPartner
     */
    select?: IBPartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IBPartnerInclude<ExtArgs> | null
    /**
     * Filter which IBPartner to delete.
     */
    where: IBPartnerWhereUniqueInput
  }

  /**
   * IBPartner deleteMany
   */
  export type IBPartnerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IBPartners to delete
     */
    where?: IBPartnerWhereInput
  }

  /**
   * IBPartner.users
   */
  export type IBPartner$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * IBPartner.anonymousAccounts
   */
  export type IBPartner$anonymousAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousAccount
     */
    select?: AnonymousAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnonymousAccountInclude<ExtArgs> | null
    where?: AnonymousAccountWhereInput
    orderBy?: AnonymousAccountOrderByWithRelationInput | AnonymousAccountOrderByWithRelationInput[]
    cursor?: AnonymousAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnonymousAccountScalarFieldEnum | AnonymousAccountScalarFieldEnum[]
  }

  /**
   * IBPartner.commissions
   */
  export type IBPartner$commissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IBCommission
     */
    select?: IBCommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IBCommissionInclude<ExtArgs> | null
    where?: IBCommissionWhereInput
    orderBy?: IBCommissionOrderByWithRelationInput | IBCommissionOrderByWithRelationInput[]
    cursor?: IBCommissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IBCommissionScalarFieldEnum | IBCommissionScalarFieldEnum[]
  }

  /**
   * IBPartner.commissionRates
   */
  export type IBPartner$commissionRatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IBCommissionRate
     */
    select?: IBCommissionRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IBCommissionRateInclude<ExtArgs> | null
    where?: IBCommissionRateWhereInput
    orderBy?: IBCommissionRateOrderByWithRelationInput | IBCommissionRateOrderByWithRelationInput[]
    cursor?: IBCommissionRateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IBCommissionRateScalarFieldEnum | IBCommissionRateScalarFieldEnum[]
  }

  /**
   * IBPartner without action
   */
  export type IBPartnerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IBPartner
     */
    select?: IBPartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IBPartnerInclude<ExtArgs> | null
  }


  /**
   * Model Agent
   */

  export type AggregateAgent = {
    _count: AgentCountAggregateOutputType | null
    _avg: AgentAvgAggregateOutputType | null
    _sum: AgentSumAggregateOutputType | null
    _min: AgentMinAggregateOutputType | null
    _max: AgentMaxAggregateOutputType | null
  }

  export type AgentAvgAggregateOutputType = {
    maxCapacity: number | null
    currentLoad: number | null
    totalTrades: number | null
    profitableTrades: number | null
    losingTrades: number | null
    totalProfit: number | null
    winRate: number | null
    aiOptimizationScore: number | null
    cpuUsage: number | null
    memoryUsage: number | null
    diskUsage: number | null
    mt5InstanceCount: number | null
  }

  export type AgentSumAggregateOutputType = {
    maxCapacity: number | null
    currentLoad: number | null
    totalTrades: number | null
    profitableTrades: number | null
    losingTrades: number | null
    totalProfit: number | null
    winRate: number | null
    aiOptimizationScore: number | null
    cpuUsage: number | null
    memoryUsage: number | null
    diskUsage: number | null
    mt5InstanceCount: number | null
  }

  export type AgentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    machineId: string | null
    machineName: string | null
    isPoolAgent: boolean | null
    maxCapacity: number | null
    currentLoad: number | null
    vpsName: string | null
    vpsRegion: string | null
    vpsIp: string | null
    mt5AccountNumber: string | null
    mt5Broker: string | null
    mt5ServerName: string | null
    mt5Version: string | null
    status: string | null
    lastHeartbeat: Date | null
    connectedAt: Date | null
    disconnectedAt: Date | null
    eaLoaded: boolean | null
    eaRunning: boolean | null
    eaName: string | null
    chartSymbol: string | null
    chartTimeframe: string | null
    tradeCopierActive: boolean | null
    isMasterAccount: boolean | null
    masterAgentId: string | null
    totalTrades: number | null
    profitableTrades: number | null
    losingTrades: number | null
    totalProfit: number | null
    winRate: number | null
    aiOptimizationScore: number | null
    lastOptimizedAt: Date | null
    apiKey: string | null
    osVersion: string | null
    agentVersion: string | null
    cpuUsage: number | null
    memoryUsage: number | null
    diskUsage: number | null
    mt5InstanceCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    machineId: string | null
    machineName: string | null
    isPoolAgent: boolean | null
    maxCapacity: number | null
    currentLoad: number | null
    vpsName: string | null
    vpsRegion: string | null
    vpsIp: string | null
    mt5AccountNumber: string | null
    mt5Broker: string | null
    mt5ServerName: string | null
    mt5Version: string | null
    status: string | null
    lastHeartbeat: Date | null
    connectedAt: Date | null
    disconnectedAt: Date | null
    eaLoaded: boolean | null
    eaRunning: boolean | null
    eaName: string | null
    chartSymbol: string | null
    chartTimeframe: string | null
    tradeCopierActive: boolean | null
    isMasterAccount: boolean | null
    masterAgentId: string | null
    totalTrades: number | null
    profitableTrades: number | null
    losingTrades: number | null
    totalProfit: number | null
    winRate: number | null
    aiOptimizationScore: number | null
    lastOptimizedAt: Date | null
    apiKey: string | null
    osVersion: string | null
    agentVersion: string | null
    cpuUsage: number | null
    memoryUsage: number | null
    diskUsage: number | null
    mt5InstanceCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentCountAggregateOutputType = {
    id: number
    userId: number
    machineId: number
    machineName: number
    isPoolAgent: number
    managedAccounts: number
    maxCapacity: number
    currentLoad: number
    vpsName: number
    vpsRegion: number
    vpsIp: number
    mt5AccountNumber: number
    mt5Broker: number
    mt5ServerName: number
    mt5Version: number
    status: number
    lastHeartbeat: number
    connectedAt: number
    disconnectedAt: number
    eaLoaded: number
    eaRunning: number
    eaName: number
    chartSymbol: number
    chartTimeframe: number
    tradeCopierActive: number
    isMasterAccount: number
    masterAgentId: number
    totalTrades: number
    profitableTrades: number
    losingTrades: number
    totalProfit: number
    winRate: number
    indicatorSettings: number
    aiOptimizationScore: number
    lastOptimizedAt: number
    apiKey: number
    osVersion: number
    agentVersion: number
    cpuUsage: number
    memoryUsage: number
    diskUsage: number
    mt5InstanceCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AgentAvgAggregateInputType = {
    maxCapacity?: true
    currentLoad?: true
    totalTrades?: true
    profitableTrades?: true
    losingTrades?: true
    totalProfit?: true
    winRate?: true
    aiOptimizationScore?: true
    cpuUsage?: true
    memoryUsage?: true
    diskUsage?: true
    mt5InstanceCount?: true
  }

  export type AgentSumAggregateInputType = {
    maxCapacity?: true
    currentLoad?: true
    totalTrades?: true
    profitableTrades?: true
    losingTrades?: true
    totalProfit?: true
    winRate?: true
    aiOptimizationScore?: true
    cpuUsage?: true
    memoryUsage?: true
    diskUsage?: true
    mt5InstanceCount?: true
  }

  export type AgentMinAggregateInputType = {
    id?: true
    userId?: true
    machineId?: true
    machineName?: true
    isPoolAgent?: true
    maxCapacity?: true
    currentLoad?: true
    vpsName?: true
    vpsRegion?: true
    vpsIp?: true
    mt5AccountNumber?: true
    mt5Broker?: true
    mt5ServerName?: true
    mt5Version?: true
    status?: true
    lastHeartbeat?: true
    connectedAt?: true
    disconnectedAt?: true
    eaLoaded?: true
    eaRunning?: true
    eaName?: true
    chartSymbol?: true
    chartTimeframe?: true
    tradeCopierActive?: true
    isMasterAccount?: true
    masterAgentId?: true
    totalTrades?: true
    profitableTrades?: true
    losingTrades?: true
    totalProfit?: true
    winRate?: true
    aiOptimizationScore?: true
    lastOptimizedAt?: true
    apiKey?: true
    osVersion?: true
    agentVersion?: true
    cpuUsage?: true
    memoryUsage?: true
    diskUsage?: true
    mt5InstanceCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentMaxAggregateInputType = {
    id?: true
    userId?: true
    machineId?: true
    machineName?: true
    isPoolAgent?: true
    maxCapacity?: true
    currentLoad?: true
    vpsName?: true
    vpsRegion?: true
    vpsIp?: true
    mt5AccountNumber?: true
    mt5Broker?: true
    mt5ServerName?: true
    mt5Version?: true
    status?: true
    lastHeartbeat?: true
    connectedAt?: true
    disconnectedAt?: true
    eaLoaded?: true
    eaRunning?: true
    eaName?: true
    chartSymbol?: true
    chartTimeframe?: true
    tradeCopierActive?: true
    isMasterAccount?: true
    masterAgentId?: true
    totalTrades?: true
    profitableTrades?: true
    losingTrades?: true
    totalProfit?: true
    winRate?: true
    aiOptimizationScore?: true
    lastOptimizedAt?: true
    apiKey?: true
    osVersion?: true
    agentVersion?: true
    cpuUsage?: true
    memoryUsage?: true
    diskUsage?: true
    mt5InstanceCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentCountAggregateInputType = {
    id?: true
    userId?: true
    machineId?: true
    machineName?: true
    isPoolAgent?: true
    managedAccounts?: true
    maxCapacity?: true
    currentLoad?: true
    vpsName?: true
    vpsRegion?: true
    vpsIp?: true
    mt5AccountNumber?: true
    mt5Broker?: true
    mt5ServerName?: true
    mt5Version?: true
    status?: true
    lastHeartbeat?: true
    connectedAt?: true
    disconnectedAt?: true
    eaLoaded?: true
    eaRunning?: true
    eaName?: true
    chartSymbol?: true
    chartTimeframe?: true
    tradeCopierActive?: true
    isMasterAccount?: true
    masterAgentId?: true
    totalTrades?: true
    profitableTrades?: true
    losingTrades?: true
    totalProfit?: true
    winRate?: true
    indicatorSettings?: true
    aiOptimizationScore?: true
    lastOptimizedAt?: true
    apiKey?: true
    osVersion?: true
    agentVersion?: true
    cpuUsage?: true
    memoryUsage?: true
    diskUsage?: true
    mt5InstanceCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AgentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agent to aggregate.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Agents
    **/
    _count?: true | AgentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgentMaxAggregateInputType
  }

  export type GetAgentAggregateType<T extends AgentAggregateArgs> = {
        [P in keyof T & keyof AggregateAgent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgent[P]>
      : GetScalarType<T[P], AggregateAgent[P]>
  }




  export type AgentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentWhereInput
    orderBy?: AgentOrderByWithAggregationInput | AgentOrderByWithAggregationInput[]
    by: AgentScalarFieldEnum[] | AgentScalarFieldEnum
    having?: AgentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgentCountAggregateInputType | true
    _avg?: AgentAvgAggregateInputType
    _sum?: AgentSumAggregateInputType
    _min?: AgentMinAggregateInputType
    _max?: AgentMaxAggregateInputType
  }

  export type AgentGroupByOutputType = {
    id: string
    userId: string | null
    machineId: string
    machineName: string | null
    isPoolAgent: boolean
    managedAccounts: string[]
    maxCapacity: number
    currentLoad: number
    vpsName: string | null
    vpsRegion: string | null
    vpsIp: string | null
    mt5AccountNumber: string | null
    mt5Broker: string | null
    mt5ServerName: string | null
    mt5Version: string | null
    status: string
    lastHeartbeat: Date | null
    connectedAt: Date | null
    disconnectedAt: Date | null
    eaLoaded: boolean
    eaRunning: boolean
    eaName: string | null
    chartSymbol: string | null
    chartTimeframe: string | null
    tradeCopierActive: boolean
    isMasterAccount: boolean
    masterAgentId: string | null
    totalTrades: number
    profitableTrades: number
    losingTrades: number
    totalProfit: number
    winRate: number
    indicatorSettings: JsonValue | null
    aiOptimizationScore: number
    lastOptimizedAt: Date | null
    apiKey: string | null
    osVersion: string | null
    agentVersion: string | null
    cpuUsage: number | null
    memoryUsage: number | null
    diskUsage: number | null
    mt5InstanceCount: number
    createdAt: Date
    updatedAt: Date
    _count: AgentCountAggregateOutputType | null
    _avg: AgentAvgAggregateOutputType | null
    _sum: AgentSumAggregateOutputType | null
    _min: AgentMinAggregateOutputType | null
    _max: AgentMaxAggregateOutputType | null
  }

  type GetAgentGroupByPayload<T extends AgentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgentGroupByOutputType[P]>
            : GetScalarType<T[P], AgentGroupByOutputType[P]>
        }
      >
    >


  export type AgentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    machineId?: boolean
    machineName?: boolean
    isPoolAgent?: boolean
    managedAccounts?: boolean
    maxCapacity?: boolean
    currentLoad?: boolean
    vpsName?: boolean
    vpsRegion?: boolean
    vpsIp?: boolean
    mt5AccountNumber?: boolean
    mt5Broker?: boolean
    mt5ServerName?: boolean
    mt5Version?: boolean
    status?: boolean
    lastHeartbeat?: boolean
    connectedAt?: boolean
    disconnectedAt?: boolean
    eaLoaded?: boolean
    eaRunning?: boolean
    eaName?: boolean
    chartSymbol?: boolean
    chartTimeframe?: boolean
    tradeCopierActive?: boolean
    isMasterAccount?: boolean
    masterAgentId?: boolean
    totalTrades?: boolean
    profitableTrades?: boolean
    losingTrades?: boolean
    totalProfit?: boolean
    winRate?: boolean
    indicatorSettings?: boolean
    aiOptimizationScore?: boolean
    lastOptimizedAt?: boolean
    apiKey?: boolean
    osVersion?: boolean
    agentVersion?: boolean
    cpuUsage?: boolean
    memoryUsage?: boolean
    diskUsage?: boolean
    mt5InstanceCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Agent$userArgs<ExtArgs>
    masterAgent?: boolean | Agent$masterAgentArgs<ExtArgs>
    slaveAgents?: boolean | Agent$slaveAgentsArgs<ExtArgs>
    accountAssignments?: boolean | Agent$accountAssignmentsArgs<ExtArgs>
    _count?: boolean | AgentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agent"]>

  export type AgentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    machineId?: boolean
    machineName?: boolean
    isPoolAgent?: boolean
    managedAccounts?: boolean
    maxCapacity?: boolean
    currentLoad?: boolean
    vpsName?: boolean
    vpsRegion?: boolean
    vpsIp?: boolean
    mt5AccountNumber?: boolean
    mt5Broker?: boolean
    mt5ServerName?: boolean
    mt5Version?: boolean
    status?: boolean
    lastHeartbeat?: boolean
    connectedAt?: boolean
    disconnectedAt?: boolean
    eaLoaded?: boolean
    eaRunning?: boolean
    eaName?: boolean
    chartSymbol?: boolean
    chartTimeframe?: boolean
    tradeCopierActive?: boolean
    isMasterAccount?: boolean
    masterAgentId?: boolean
    totalTrades?: boolean
    profitableTrades?: boolean
    losingTrades?: boolean
    totalProfit?: boolean
    winRate?: boolean
    indicatorSettings?: boolean
    aiOptimizationScore?: boolean
    lastOptimizedAt?: boolean
    apiKey?: boolean
    osVersion?: boolean
    agentVersion?: boolean
    cpuUsage?: boolean
    memoryUsage?: boolean
    diskUsage?: boolean
    mt5InstanceCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Agent$userArgs<ExtArgs>
    masterAgent?: boolean | Agent$masterAgentArgs<ExtArgs>
  }, ExtArgs["result"]["agent"]>

  export type AgentSelectScalar = {
    id?: boolean
    userId?: boolean
    machineId?: boolean
    machineName?: boolean
    isPoolAgent?: boolean
    managedAccounts?: boolean
    maxCapacity?: boolean
    currentLoad?: boolean
    vpsName?: boolean
    vpsRegion?: boolean
    vpsIp?: boolean
    mt5AccountNumber?: boolean
    mt5Broker?: boolean
    mt5ServerName?: boolean
    mt5Version?: boolean
    status?: boolean
    lastHeartbeat?: boolean
    connectedAt?: boolean
    disconnectedAt?: boolean
    eaLoaded?: boolean
    eaRunning?: boolean
    eaName?: boolean
    chartSymbol?: boolean
    chartTimeframe?: boolean
    tradeCopierActive?: boolean
    isMasterAccount?: boolean
    masterAgentId?: boolean
    totalTrades?: boolean
    profitableTrades?: boolean
    losingTrades?: boolean
    totalProfit?: boolean
    winRate?: boolean
    indicatorSettings?: boolean
    aiOptimizationScore?: boolean
    lastOptimizedAt?: boolean
    apiKey?: boolean
    osVersion?: boolean
    agentVersion?: boolean
    cpuUsage?: boolean
    memoryUsage?: boolean
    diskUsage?: boolean
    mt5InstanceCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AgentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Agent$userArgs<ExtArgs>
    masterAgent?: boolean | Agent$masterAgentArgs<ExtArgs>
    slaveAgents?: boolean | Agent$slaveAgentsArgs<ExtArgs>
    accountAssignments?: boolean | Agent$accountAssignmentsArgs<ExtArgs>
    _count?: boolean | AgentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AgentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Agent$userArgs<ExtArgs>
    masterAgent?: boolean | Agent$masterAgentArgs<ExtArgs>
  }

  export type $AgentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Agent"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      masterAgent: Prisma.$AgentPayload<ExtArgs> | null
      slaveAgents: Prisma.$AgentPayload<ExtArgs>[]
      accountAssignments: Prisma.$MT5AccountAssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      machineId: string
      machineName: string | null
      isPoolAgent: boolean
      managedAccounts: string[]
      maxCapacity: number
      currentLoad: number
      vpsName: string | null
      vpsRegion: string | null
      vpsIp: string | null
      mt5AccountNumber: string | null
      mt5Broker: string | null
      mt5ServerName: string | null
      mt5Version: string | null
      status: string
      lastHeartbeat: Date | null
      connectedAt: Date | null
      disconnectedAt: Date | null
      eaLoaded: boolean
      eaRunning: boolean
      eaName: string | null
      chartSymbol: string | null
      chartTimeframe: string | null
      tradeCopierActive: boolean
      isMasterAccount: boolean
      masterAgentId: string | null
      totalTrades: number
      profitableTrades: number
      losingTrades: number
      totalProfit: number
      winRate: number
      indicatorSettings: Prisma.JsonValue | null
      aiOptimizationScore: number
      lastOptimizedAt: Date | null
      apiKey: string | null
      osVersion: string | null
      agentVersion: string | null
      cpuUsage: number | null
      memoryUsage: number | null
      diskUsage: number | null
      mt5InstanceCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["agent"]>
    composites: {}
  }

  type AgentGetPayload<S extends boolean | null | undefined | AgentDefaultArgs> = $Result.GetResult<Prisma.$AgentPayload, S>

  type AgentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AgentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AgentCountAggregateInputType | true
    }

  export interface AgentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Agent'], meta: { name: 'Agent' } }
    /**
     * Find zero or one Agent that matches the filter.
     * @param {AgentFindUniqueArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgentFindUniqueArgs>(args: SelectSubset<T, AgentFindUniqueArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Agent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AgentFindUniqueOrThrowArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgentFindUniqueOrThrowArgs>(args: SelectSubset<T, AgentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Agent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFindFirstArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgentFindFirstArgs>(args?: SelectSubset<T, AgentFindFirstArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Agent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFindFirstOrThrowArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgentFindFirstOrThrowArgs>(args?: SelectSubset<T, AgentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Agents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Agents
     * const agents = await prisma.agent.findMany()
     * 
     * // Get first 10 Agents
     * const agents = await prisma.agent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agentWithIdOnly = await prisma.agent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgentFindManyArgs>(args?: SelectSubset<T, AgentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Agent.
     * @param {AgentCreateArgs} args - Arguments to create a Agent.
     * @example
     * // Create one Agent
     * const Agent = await prisma.agent.create({
     *   data: {
     *     // ... data to create a Agent
     *   }
     * })
     * 
     */
    create<T extends AgentCreateArgs>(args: SelectSubset<T, AgentCreateArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Agents.
     * @param {AgentCreateManyArgs} args - Arguments to create many Agents.
     * @example
     * // Create many Agents
     * const agent = await prisma.agent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgentCreateManyArgs>(args?: SelectSubset<T, AgentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Agents and returns the data saved in the database.
     * @param {AgentCreateManyAndReturnArgs} args - Arguments to create many Agents.
     * @example
     * // Create many Agents
     * const agent = await prisma.agent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Agents and only return the `id`
     * const agentWithIdOnly = await prisma.agent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgentCreateManyAndReturnArgs>(args?: SelectSubset<T, AgentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Agent.
     * @param {AgentDeleteArgs} args - Arguments to delete one Agent.
     * @example
     * // Delete one Agent
     * const Agent = await prisma.agent.delete({
     *   where: {
     *     // ... filter to delete one Agent
     *   }
     * })
     * 
     */
    delete<T extends AgentDeleteArgs>(args: SelectSubset<T, AgentDeleteArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Agent.
     * @param {AgentUpdateArgs} args - Arguments to update one Agent.
     * @example
     * // Update one Agent
     * const agent = await prisma.agent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgentUpdateArgs>(args: SelectSubset<T, AgentUpdateArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Agents.
     * @param {AgentDeleteManyArgs} args - Arguments to filter Agents to delete.
     * @example
     * // Delete a few Agents
     * const { count } = await prisma.agent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgentDeleteManyArgs>(args?: SelectSubset<T, AgentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Agents
     * const agent = await prisma.agent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgentUpdateManyArgs>(args: SelectSubset<T, AgentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Agent.
     * @param {AgentUpsertArgs} args - Arguments to update or create a Agent.
     * @example
     * // Update or create a Agent
     * const agent = await prisma.agent.upsert({
     *   create: {
     *     // ... data to create a Agent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Agent we want to update
     *   }
     * })
     */
    upsert<T extends AgentUpsertArgs>(args: SelectSubset<T, AgentUpsertArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Agents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentCountArgs} args - Arguments to filter Agents to count.
     * @example
     * // Count the number of Agents
     * const count = await prisma.agent.count({
     *   where: {
     *     // ... the filter for the Agents we want to count
     *   }
     * })
    **/
    count<T extends AgentCountArgs>(
      args?: Subset<T, AgentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Agent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgentAggregateArgs>(args: Subset<T, AgentAggregateArgs>): Prisma.PrismaPromise<GetAgentAggregateType<T>>

    /**
     * Group by Agent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgentGroupByArgs['orderBy'] }
        : { orderBy?: AgentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Agent model
   */
  readonly fields: AgentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Agent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Agent$userArgs<ExtArgs> = {}>(args?: Subset<T, Agent$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    masterAgent<T extends Agent$masterAgentArgs<ExtArgs> = {}>(args?: Subset<T, Agent$masterAgentArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    slaveAgents<T extends Agent$slaveAgentsArgs<ExtArgs> = {}>(args?: Subset<T, Agent$slaveAgentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findMany"> | Null>
    accountAssignments<T extends Agent$accountAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Agent$accountAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MT5AccountAssignmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Agent model
   */ 
  interface AgentFieldRefs {
    readonly id: FieldRef<"Agent", 'String'>
    readonly userId: FieldRef<"Agent", 'String'>
    readonly machineId: FieldRef<"Agent", 'String'>
    readonly machineName: FieldRef<"Agent", 'String'>
    readonly isPoolAgent: FieldRef<"Agent", 'Boolean'>
    readonly managedAccounts: FieldRef<"Agent", 'String[]'>
    readonly maxCapacity: FieldRef<"Agent", 'Int'>
    readonly currentLoad: FieldRef<"Agent", 'Int'>
    readonly vpsName: FieldRef<"Agent", 'String'>
    readonly vpsRegion: FieldRef<"Agent", 'String'>
    readonly vpsIp: FieldRef<"Agent", 'String'>
    readonly mt5AccountNumber: FieldRef<"Agent", 'String'>
    readonly mt5Broker: FieldRef<"Agent", 'String'>
    readonly mt5ServerName: FieldRef<"Agent", 'String'>
    readonly mt5Version: FieldRef<"Agent", 'String'>
    readonly status: FieldRef<"Agent", 'String'>
    readonly lastHeartbeat: FieldRef<"Agent", 'DateTime'>
    readonly connectedAt: FieldRef<"Agent", 'DateTime'>
    readonly disconnectedAt: FieldRef<"Agent", 'DateTime'>
    readonly eaLoaded: FieldRef<"Agent", 'Boolean'>
    readonly eaRunning: FieldRef<"Agent", 'Boolean'>
    readonly eaName: FieldRef<"Agent", 'String'>
    readonly chartSymbol: FieldRef<"Agent", 'String'>
    readonly chartTimeframe: FieldRef<"Agent", 'String'>
    readonly tradeCopierActive: FieldRef<"Agent", 'Boolean'>
    readonly isMasterAccount: FieldRef<"Agent", 'Boolean'>
    readonly masterAgentId: FieldRef<"Agent", 'String'>
    readonly totalTrades: FieldRef<"Agent", 'Int'>
    readonly profitableTrades: FieldRef<"Agent", 'Int'>
    readonly losingTrades: FieldRef<"Agent", 'Int'>
    readonly totalProfit: FieldRef<"Agent", 'Float'>
    readonly winRate: FieldRef<"Agent", 'Float'>
    readonly indicatorSettings: FieldRef<"Agent", 'Json'>
    readonly aiOptimizationScore: FieldRef<"Agent", 'Float'>
    readonly lastOptimizedAt: FieldRef<"Agent", 'DateTime'>
    readonly apiKey: FieldRef<"Agent", 'String'>
    readonly osVersion: FieldRef<"Agent", 'String'>
    readonly agentVersion: FieldRef<"Agent", 'String'>
    readonly cpuUsage: FieldRef<"Agent", 'Float'>
    readonly memoryUsage: FieldRef<"Agent", 'Float'>
    readonly diskUsage: FieldRef<"Agent", 'Float'>
    readonly mt5InstanceCount: FieldRef<"Agent", 'Int'>
    readonly createdAt: FieldRef<"Agent", 'DateTime'>
    readonly updatedAt: FieldRef<"Agent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Agent findUnique
   */
  export type AgentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent findUniqueOrThrow
   */
  export type AgentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent findFirst
   */
  export type AgentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agents.
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agents.
     */
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Agent findFirstOrThrow
   */
  export type AgentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agents.
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agents.
     */
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Agent findMany
   */
  export type AgentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agents to fetch.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Agents.
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Agent create
   */
  export type AgentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * The data needed to create a Agent.
     */
    data: XOR<AgentCreateInput, AgentUncheckedCreateInput>
  }

  /**
   * Agent createMany
   */
  export type AgentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Agents.
     */
    data: AgentCreateManyInput | AgentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Agent createManyAndReturn
   */
  export type AgentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Agents.
     */
    data: AgentCreateManyInput | AgentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Agent update
   */
  export type AgentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * The data needed to update a Agent.
     */
    data: XOR<AgentUpdateInput, AgentUncheckedUpdateInput>
    /**
     * Choose, which Agent to update.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent updateMany
   */
  export type AgentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Agents.
     */
    data: XOR<AgentUpdateManyMutationInput, AgentUncheckedUpdateManyInput>
    /**
     * Filter which Agents to update
     */
    where?: AgentWhereInput
  }

  /**
   * Agent upsert
   */
  export type AgentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * The filter to search for the Agent to update in case it exists.
     */
    where: AgentWhereUniqueInput
    /**
     * In case the Agent found by the `where` argument doesn't exist, create a new Agent with this data.
     */
    create: XOR<AgentCreateInput, AgentUncheckedCreateInput>
    /**
     * In case the Agent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgentUpdateInput, AgentUncheckedUpdateInput>
  }

  /**
   * Agent delete
   */
  export type AgentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter which Agent to delete.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent deleteMany
   */
  export type AgentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agents to delete
     */
    where?: AgentWhereInput
  }

  /**
   * Agent.user
   */
  export type Agent$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Agent.masterAgent
   */
  export type Agent$masterAgentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    where?: AgentWhereInput
  }

  /**
   * Agent.slaveAgents
   */
  export type Agent$slaveAgentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    where?: AgentWhereInput
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    cursor?: AgentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Agent.accountAssignments
   */
  export type Agent$accountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5AccountAssignment
     */
    select?: MT5AccountAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5AccountAssignmentInclude<ExtArgs> | null
    where?: MT5AccountAssignmentWhereInput
    orderBy?: MT5AccountAssignmentOrderByWithRelationInput | MT5AccountAssignmentOrderByWithRelationInput[]
    cursor?: MT5AccountAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MT5AccountAssignmentScalarFieldEnum | MT5AccountAssignmentScalarFieldEnum[]
  }

  /**
   * Agent without action
   */
  export type AgentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
  }


  /**
   * Model MT5AccountAssignment
   */

  export type AggregateMT5AccountAssignment = {
    _count: MT5AccountAssignmentCountAggregateOutputType | null
    _avg: MT5AccountAssignmentAvgAggregateOutputType | null
    _sum: MT5AccountAssignmentSumAggregateOutputType | null
    _min: MT5AccountAssignmentMinAggregateOutputType | null
    _max: MT5AccountAssignmentMaxAggregateOutputType | null
  }

  export type MT5AccountAssignmentAvgAggregateOutputType = {
    balance: number | null
    equity: number | null
    margin: number | null
    freeMargin: number | null
    profit: number | null
    totalTrades: number | null
    profitableTrades: number | null
    losingTrades: number | null
    totalProfit: number | null
    winRate: number | null
  }

  export type MT5AccountAssignmentSumAggregateOutputType = {
    balance: number | null
    equity: number | null
    margin: number | null
    freeMargin: number | null
    profit: number | null
    totalTrades: number | null
    profitableTrades: number | null
    losingTrades: number | null
    totalProfit: number | null
    winRate: number | null
  }

  export type MT5AccountAssignmentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    agentId: string | null
    mt5AccountNumber: string | null
    mt5Broker: string | null
    mt5ServerName: string | null
    assignedAt: Date | null
    isActive: boolean | null
    status: string | null
    eaStatus: string | null
    lastHeartbeat: Date | null
    balance: number | null
    equity: number | null
    margin: number | null
    freeMargin: number | null
    profit: number | null
    eaLoaded: boolean | null
    eaRunning: boolean | null
    eaName: string | null
    chartSymbol: string | null
    chartTimeframe: string | null
    totalTrades: number | null
    profitableTrades: number | null
    losingTrades: number | null
    totalProfit: number | null
    winRate: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MT5AccountAssignmentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    agentId: string | null
    mt5AccountNumber: string | null
    mt5Broker: string | null
    mt5ServerName: string | null
    assignedAt: Date | null
    isActive: boolean | null
    status: string | null
    eaStatus: string | null
    lastHeartbeat: Date | null
    balance: number | null
    equity: number | null
    margin: number | null
    freeMargin: number | null
    profit: number | null
    eaLoaded: boolean | null
    eaRunning: boolean | null
    eaName: string | null
    chartSymbol: string | null
    chartTimeframe: string | null
    totalTrades: number | null
    profitableTrades: number | null
    losingTrades: number | null
    totalProfit: number | null
    winRate: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MT5AccountAssignmentCountAggregateOutputType = {
    id: number
    userId: number
    agentId: number
    mt5AccountNumber: number
    mt5Broker: number
    mt5ServerName: number
    assignedAt: number
    isActive: number
    status: number
    eaStatus: number
    lastHeartbeat: number
    balance: number
    equity: number
    margin: number
    freeMargin: number
    profit: number
    eaLoaded: number
    eaRunning: number
    eaName: number
    chartSymbol: number
    chartTimeframe: number
    totalTrades: number
    profitableTrades: number
    losingTrades: number
    totalProfit: number
    winRate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MT5AccountAssignmentAvgAggregateInputType = {
    balance?: true
    equity?: true
    margin?: true
    freeMargin?: true
    profit?: true
    totalTrades?: true
    profitableTrades?: true
    losingTrades?: true
    totalProfit?: true
    winRate?: true
  }

  export type MT5AccountAssignmentSumAggregateInputType = {
    balance?: true
    equity?: true
    margin?: true
    freeMargin?: true
    profit?: true
    totalTrades?: true
    profitableTrades?: true
    losingTrades?: true
    totalProfit?: true
    winRate?: true
  }

  export type MT5AccountAssignmentMinAggregateInputType = {
    id?: true
    userId?: true
    agentId?: true
    mt5AccountNumber?: true
    mt5Broker?: true
    mt5ServerName?: true
    assignedAt?: true
    isActive?: true
    status?: true
    eaStatus?: true
    lastHeartbeat?: true
    balance?: true
    equity?: true
    margin?: true
    freeMargin?: true
    profit?: true
    eaLoaded?: true
    eaRunning?: true
    eaName?: true
    chartSymbol?: true
    chartTimeframe?: true
    totalTrades?: true
    profitableTrades?: true
    losingTrades?: true
    totalProfit?: true
    winRate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MT5AccountAssignmentMaxAggregateInputType = {
    id?: true
    userId?: true
    agentId?: true
    mt5AccountNumber?: true
    mt5Broker?: true
    mt5ServerName?: true
    assignedAt?: true
    isActive?: true
    status?: true
    eaStatus?: true
    lastHeartbeat?: true
    balance?: true
    equity?: true
    margin?: true
    freeMargin?: true
    profit?: true
    eaLoaded?: true
    eaRunning?: true
    eaName?: true
    chartSymbol?: true
    chartTimeframe?: true
    totalTrades?: true
    profitableTrades?: true
    losingTrades?: true
    totalProfit?: true
    winRate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MT5AccountAssignmentCountAggregateInputType = {
    id?: true
    userId?: true
    agentId?: true
    mt5AccountNumber?: true
    mt5Broker?: true
    mt5ServerName?: true
    assignedAt?: true
    isActive?: true
    status?: true
    eaStatus?: true
    lastHeartbeat?: true
    balance?: true
    equity?: true
    margin?: true
    freeMargin?: true
    profit?: true
    eaLoaded?: true
    eaRunning?: true
    eaName?: true
    chartSymbol?: true
    chartTimeframe?: true
    totalTrades?: true
    profitableTrades?: true
    losingTrades?: true
    totalProfit?: true
    winRate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MT5AccountAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MT5AccountAssignment to aggregate.
     */
    where?: MT5AccountAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MT5AccountAssignments to fetch.
     */
    orderBy?: MT5AccountAssignmentOrderByWithRelationInput | MT5AccountAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MT5AccountAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MT5AccountAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MT5AccountAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MT5AccountAssignments
    **/
    _count?: true | MT5AccountAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MT5AccountAssignmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MT5AccountAssignmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MT5AccountAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MT5AccountAssignmentMaxAggregateInputType
  }

  export type GetMT5AccountAssignmentAggregateType<T extends MT5AccountAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateMT5AccountAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMT5AccountAssignment[P]>
      : GetScalarType<T[P], AggregateMT5AccountAssignment[P]>
  }




  export type MT5AccountAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MT5AccountAssignmentWhereInput
    orderBy?: MT5AccountAssignmentOrderByWithAggregationInput | MT5AccountAssignmentOrderByWithAggregationInput[]
    by: MT5AccountAssignmentScalarFieldEnum[] | MT5AccountAssignmentScalarFieldEnum
    having?: MT5AccountAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MT5AccountAssignmentCountAggregateInputType | true
    _avg?: MT5AccountAssignmentAvgAggregateInputType
    _sum?: MT5AccountAssignmentSumAggregateInputType
    _min?: MT5AccountAssignmentMinAggregateInputType
    _max?: MT5AccountAssignmentMaxAggregateInputType
  }

  export type MT5AccountAssignmentGroupByOutputType = {
    id: string
    userId: string
    agentId: string
    mt5AccountNumber: string
    mt5Broker: string | null
    mt5ServerName: string | null
    assignedAt: Date
    isActive: boolean
    status: string
    eaStatus: string
    lastHeartbeat: Date | null
    balance: number
    equity: number
    margin: number
    freeMargin: number
    profit: number
    eaLoaded: boolean
    eaRunning: boolean
    eaName: string | null
    chartSymbol: string | null
    chartTimeframe: string | null
    totalTrades: number
    profitableTrades: number
    losingTrades: number
    totalProfit: number
    winRate: number
    createdAt: Date
    updatedAt: Date
    _count: MT5AccountAssignmentCountAggregateOutputType | null
    _avg: MT5AccountAssignmentAvgAggregateOutputType | null
    _sum: MT5AccountAssignmentSumAggregateOutputType | null
    _min: MT5AccountAssignmentMinAggregateOutputType | null
    _max: MT5AccountAssignmentMaxAggregateOutputType | null
  }

  type GetMT5AccountAssignmentGroupByPayload<T extends MT5AccountAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MT5AccountAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MT5AccountAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MT5AccountAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], MT5AccountAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type MT5AccountAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    agentId?: boolean
    mt5AccountNumber?: boolean
    mt5Broker?: boolean
    mt5ServerName?: boolean
    assignedAt?: boolean
    isActive?: boolean
    status?: boolean
    eaStatus?: boolean
    lastHeartbeat?: boolean
    balance?: boolean
    equity?: boolean
    margin?: boolean
    freeMargin?: boolean
    profit?: boolean
    eaLoaded?: boolean
    eaRunning?: boolean
    eaName?: boolean
    chartSymbol?: boolean
    chartTimeframe?: boolean
    totalTrades?: boolean
    profitableTrades?: boolean
    losingTrades?: boolean
    totalProfit?: boolean
    winRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mT5AccountAssignment"]>

  export type MT5AccountAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    agentId?: boolean
    mt5AccountNumber?: boolean
    mt5Broker?: boolean
    mt5ServerName?: boolean
    assignedAt?: boolean
    isActive?: boolean
    status?: boolean
    eaStatus?: boolean
    lastHeartbeat?: boolean
    balance?: boolean
    equity?: boolean
    margin?: boolean
    freeMargin?: boolean
    profit?: boolean
    eaLoaded?: boolean
    eaRunning?: boolean
    eaName?: boolean
    chartSymbol?: boolean
    chartTimeframe?: boolean
    totalTrades?: boolean
    profitableTrades?: boolean
    losingTrades?: boolean
    totalProfit?: boolean
    winRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mT5AccountAssignment"]>

  export type MT5AccountAssignmentSelectScalar = {
    id?: boolean
    userId?: boolean
    agentId?: boolean
    mt5AccountNumber?: boolean
    mt5Broker?: boolean
    mt5ServerName?: boolean
    assignedAt?: boolean
    isActive?: boolean
    status?: boolean
    eaStatus?: boolean
    lastHeartbeat?: boolean
    balance?: boolean
    equity?: boolean
    margin?: boolean
    freeMargin?: boolean
    profit?: boolean
    eaLoaded?: boolean
    eaRunning?: boolean
    eaName?: boolean
    chartSymbol?: boolean
    chartTimeframe?: boolean
    totalTrades?: boolean
    profitableTrades?: boolean
    losingTrades?: boolean
    totalProfit?: boolean
    winRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MT5AccountAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type MT5AccountAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }

  export type $MT5AccountAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MT5AccountAssignment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      agent: Prisma.$AgentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      agentId: string
      mt5AccountNumber: string
      mt5Broker: string | null
      mt5ServerName: string | null
      assignedAt: Date
      isActive: boolean
      status: string
      eaStatus: string
      lastHeartbeat: Date | null
      balance: number
      equity: number
      margin: number
      freeMargin: number
      profit: number
      eaLoaded: boolean
      eaRunning: boolean
      eaName: string | null
      chartSymbol: string | null
      chartTimeframe: string | null
      totalTrades: number
      profitableTrades: number
      losingTrades: number
      totalProfit: number
      winRate: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["mT5AccountAssignment"]>
    composites: {}
  }

  type MT5AccountAssignmentGetPayload<S extends boolean | null | undefined | MT5AccountAssignmentDefaultArgs> = $Result.GetResult<Prisma.$MT5AccountAssignmentPayload, S>

  type MT5AccountAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MT5AccountAssignmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MT5AccountAssignmentCountAggregateInputType | true
    }

  export interface MT5AccountAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MT5AccountAssignment'], meta: { name: 'MT5AccountAssignment' } }
    /**
     * Find zero or one MT5AccountAssignment that matches the filter.
     * @param {MT5AccountAssignmentFindUniqueArgs} args - Arguments to find a MT5AccountAssignment
     * @example
     * // Get one MT5AccountAssignment
     * const mT5AccountAssignment = await prisma.mT5AccountAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MT5AccountAssignmentFindUniqueArgs>(args: SelectSubset<T, MT5AccountAssignmentFindUniqueArgs<ExtArgs>>): Prisma__MT5AccountAssignmentClient<$Result.GetResult<Prisma.$MT5AccountAssignmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MT5AccountAssignment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MT5AccountAssignmentFindUniqueOrThrowArgs} args - Arguments to find a MT5AccountAssignment
     * @example
     * // Get one MT5AccountAssignment
     * const mT5AccountAssignment = await prisma.mT5AccountAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MT5AccountAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, MT5AccountAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MT5AccountAssignmentClient<$Result.GetResult<Prisma.$MT5AccountAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MT5AccountAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MT5AccountAssignmentFindFirstArgs} args - Arguments to find a MT5AccountAssignment
     * @example
     * // Get one MT5AccountAssignment
     * const mT5AccountAssignment = await prisma.mT5AccountAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MT5AccountAssignmentFindFirstArgs>(args?: SelectSubset<T, MT5AccountAssignmentFindFirstArgs<ExtArgs>>): Prisma__MT5AccountAssignmentClient<$Result.GetResult<Prisma.$MT5AccountAssignmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MT5AccountAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MT5AccountAssignmentFindFirstOrThrowArgs} args - Arguments to find a MT5AccountAssignment
     * @example
     * // Get one MT5AccountAssignment
     * const mT5AccountAssignment = await prisma.mT5AccountAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MT5AccountAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, MT5AccountAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__MT5AccountAssignmentClient<$Result.GetResult<Prisma.$MT5AccountAssignmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MT5AccountAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MT5AccountAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MT5AccountAssignments
     * const mT5AccountAssignments = await prisma.mT5AccountAssignment.findMany()
     * 
     * // Get first 10 MT5AccountAssignments
     * const mT5AccountAssignments = await prisma.mT5AccountAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mT5AccountAssignmentWithIdOnly = await prisma.mT5AccountAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MT5AccountAssignmentFindManyArgs>(args?: SelectSubset<T, MT5AccountAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MT5AccountAssignmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MT5AccountAssignment.
     * @param {MT5AccountAssignmentCreateArgs} args - Arguments to create a MT5AccountAssignment.
     * @example
     * // Create one MT5AccountAssignment
     * const MT5AccountAssignment = await prisma.mT5AccountAssignment.create({
     *   data: {
     *     // ... data to create a MT5AccountAssignment
     *   }
     * })
     * 
     */
    create<T extends MT5AccountAssignmentCreateArgs>(args: SelectSubset<T, MT5AccountAssignmentCreateArgs<ExtArgs>>): Prisma__MT5AccountAssignmentClient<$Result.GetResult<Prisma.$MT5AccountAssignmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MT5AccountAssignments.
     * @param {MT5AccountAssignmentCreateManyArgs} args - Arguments to create many MT5AccountAssignments.
     * @example
     * // Create many MT5AccountAssignments
     * const mT5AccountAssignment = await prisma.mT5AccountAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MT5AccountAssignmentCreateManyArgs>(args?: SelectSubset<T, MT5AccountAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MT5AccountAssignments and returns the data saved in the database.
     * @param {MT5AccountAssignmentCreateManyAndReturnArgs} args - Arguments to create many MT5AccountAssignments.
     * @example
     * // Create many MT5AccountAssignments
     * const mT5AccountAssignment = await prisma.mT5AccountAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MT5AccountAssignments and only return the `id`
     * const mT5AccountAssignmentWithIdOnly = await prisma.mT5AccountAssignment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MT5AccountAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, MT5AccountAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MT5AccountAssignmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MT5AccountAssignment.
     * @param {MT5AccountAssignmentDeleteArgs} args - Arguments to delete one MT5AccountAssignment.
     * @example
     * // Delete one MT5AccountAssignment
     * const MT5AccountAssignment = await prisma.mT5AccountAssignment.delete({
     *   where: {
     *     // ... filter to delete one MT5AccountAssignment
     *   }
     * })
     * 
     */
    delete<T extends MT5AccountAssignmentDeleteArgs>(args: SelectSubset<T, MT5AccountAssignmentDeleteArgs<ExtArgs>>): Prisma__MT5AccountAssignmentClient<$Result.GetResult<Prisma.$MT5AccountAssignmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MT5AccountAssignment.
     * @param {MT5AccountAssignmentUpdateArgs} args - Arguments to update one MT5AccountAssignment.
     * @example
     * // Update one MT5AccountAssignment
     * const mT5AccountAssignment = await prisma.mT5AccountAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MT5AccountAssignmentUpdateArgs>(args: SelectSubset<T, MT5AccountAssignmentUpdateArgs<ExtArgs>>): Prisma__MT5AccountAssignmentClient<$Result.GetResult<Prisma.$MT5AccountAssignmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MT5AccountAssignments.
     * @param {MT5AccountAssignmentDeleteManyArgs} args - Arguments to filter MT5AccountAssignments to delete.
     * @example
     * // Delete a few MT5AccountAssignments
     * const { count } = await prisma.mT5AccountAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MT5AccountAssignmentDeleteManyArgs>(args?: SelectSubset<T, MT5AccountAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MT5AccountAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MT5AccountAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MT5AccountAssignments
     * const mT5AccountAssignment = await prisma.mT5AccountAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MT5AccountAssignmentUpdateManyArgs>(args: SelectSubset<T, MT5AccountAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MT5AccountAssignment.
     * @param {MT5AccountAssignmentUpsertArgs} args - Arguments to update or create a MT5AccountAssignment.
     * @example
     * // Update or create a MT5AccountAssignment
     * const mT5AccountAssignment = await prisma.mT5AccountAssignment.upsert({
     *   create: {
     *     // ... data to create a MT5AccountAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MT5AccountAssignment we want to update
     *   }
     * })
     */
    upsert<T extends MT5AccountAssignmentUpsertArgs>(args: SelectSubset<T, MT5AccountAssignmentUpsertArgs<ExtArgs>>): Prisma__MT5AccountAssignmentClient<$Result.GetResult<Prisma.$MT5AccountAssignmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MT5AccountAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MT5AccountAssignmentCountArgs} args - Arguments to filter MT5AccountAssignments to count.
     * @example
     * // Count the number of MT5AccountAssignments
     * const count = await prisma.mT5AccountAssignment.count({
     *   where: {
     *     // ... the filter for the MT5AccountAssignments we want to count
     *   }
     * })
    **/
    count<T extends MT5AccountAssignmentCountArgs>(
      args?: Subset<T, MT5AccountAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MT5AccountAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MT5AccountAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MT5AccountAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MT5AccountAssignmentAggregateArgs>(args: Subset<T, MT5AccountAssignmentAggregateArgs>): Prisma.PrismaPromise<GetMT5AccountAssignmentAggregateType<T>>

    /**
     * Group by MT5AccountAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MT5AccountAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MT5AccountAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MT5AccountAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: MT5AccountAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MT5AccountAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMT5AccountAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MT5AccountAssignment model
   */
  readonly fields: MT5AccountAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MT5AccountAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MT5AccountAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    agent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MT5AccountAssignment model
   */ 
  interface MT5AccountAssignmentFieldRefs {
    readonly id: FieldRef<"MT5AccountAssignment", 'String'>
    readonly userId: FieldRef<"MT5AccountAssignment", 'String'>
    readonly agentId: FieldRef<"MT5AccountAssignment", 'String'>
    readonly mt5AccountNumber: FieldRef<"MT5AccountAssignment", 'String'>
    readonly mt5Broker: FieldRef<"MT5AccountAssignment", 'String'>
    readonly mt5ServerName: FieldRef<"MT5AccountAssignment", 'String'>
    readonly assignedAt: FieldRef<"MT5AccountAssignment", 'DateTime'>
    readonly isActive: FieldRef<"MT5AccountAssignment", 'Boolean'>
    readonly status: FieldRef<"MT5AccountAssignment", 'String'>
    readonly eaStatus: FieldRef<"MT5AccountAssignment", 'String'>
    readonly lastHeartbeat: FieldRef<"MT5AccountAssignment", 'DateTime'>
    readonly balance: FieldRef<"MT5AccountAssignment", 'Float'>
    readonly equity: FieldRef<"MT5AccountAssignment", 'Float'>
    readonly margin: FieldRef<"MT5AccountAssignment", 'Float'>
    readonly freeMargin: FieldRef<"MT5AccountAssignment", 'Float'>
    readonly profit: FieldRef<"MT5AccountAssignment", 'Float'>
    readonly eaLoaded: FieldRef<"MT5AccountAssignment", 'Boolean'>
    readonly eaRunning: FieldRef<"MT5AccountAssignment", 'Boolean'>
    readonly eaName: FieldRef<"MT5AccountAssignment", 'String'>
    readonly chartSymbol: FieldRef<"MT5AccountAssignment", 'String'>
    readonly chartTimeframe: FieldRef<"MT5AccountAssignment", 'String'>
    readonly totalTrades: FieldRef<"MT5AccountAssignment", 'Int'>
    readonly profitableTrades: FieldRef<"MT5AccountAssignment", 'Int'>
    readonly losingTrades: FieldRef<"MT5AccountAssignment", 'Int'>
    readonly totalProfit: FieldRef<"MT5AccountAssignment", 'Float'>
    readonly winRate: FieldRef<"MT5AccountAssignment", 'Float'>
    readonly createdAt: FieldRef<"MT5AccountAssignment", 'DateTime'>
    readonly updatedAt: FieldRef<"MT5AccountAssignment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MT5AccountAssignment findUnique
   */
  export type MT5AccountAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5AccountAssignment
     */
    select?: MT5AccountAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5AccountAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which MT5AccountAssignment to fetch.
     */
    where: MT5AccountAssignmentWhereUniqueInput
  }

  /**
   * MT5AccountAssignment findUniqueOrThrow
   */
  export type MT5AccountAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5AccountAssignment
     */
    select?: MT5AccountAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5AccountAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which MT5AccountAssignment to fetch.
     */
    where: MT5AccountAssignmentWhereUniqueInput
  }

  /**
   * MT5AccountAssignment findFirst
   */
  export type MT5AccountAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5AccountAssignment
     */
    select?: MT5AccountAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5AccountAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which MT5AccountAssignment to fetch.
     */
    where?: MT5AccountAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MT5AccountAssignments to fetch.
     */
    orderBy?: MT5AccountAssignmentOrderByWithRelationInput | MT5AccountAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MT5AccountAssignments.
     */
    cursor?: MT5AccountAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MT5AccountAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MT5AccountAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MT5AccountAssignments.
     */
    distinct?: MT5AccountAssignmentScalarFieldEnum | MT5AccountAssignmentScalarFieldEnum[]
  }

  /**
   * MT5AccountAssignment findFirstOrThrow
   */
  export type MT5AccountAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5AccountAssignment
     */
    select?: MT5AccountAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5AccountAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which MT5AccountAssignment to fetch.
     */
    where?: MT5AccountAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MT5AccountAssignments to fetch.
     */
    orderBy?: MT5AccountAssignmentOrderByWithRelationInput | MT5AccountAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MT5AccountAssignments.
     */
    cursor?: MT5AccountAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MT5AccountAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MT5AccountAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MT5AccountAssignments.
     */
    distinct?: MT5AccountAssignmentScalarFieldEnum | MT5AccountAssignmentScalarFieldEnum[]
  }

  /**
   * MT5AccountAssignment findMany
   */
  export type MT5AccountAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5AccountAssignment
     */
    select?: MT5AccountAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5AccountAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which MT5AccountAssignments to fetch.
     */
    where?: MT5AccountAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MT5AccountAssignments to fetch.
     */
    orderBy?: MT5AccountAssignmentOrderByWithRelationInput | MT5AccountAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MT5AccountAssignments.
     */
    cursor?: MT5AccountAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MT5AccountAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MT5AccountAssignments.
     */
    skip?: number
    distinct?: MT5AccountAssignmentScalarFieldEnum | MT5AccountAssignmentScalarFieldEnum[]
  }

  /**
   * MT5AccountAssignment create
   */
  export type MT5AccountAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5AccountAssignment
     */
    select?: MT5AccountAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5AccountAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a MT5AccountAssignment.
     */
    data: XOR<MT5AccountAssignmentCreateInput, MT5AccountAssignmentUncheckedCreateInput>
  }

  /**
   * MT5AccountAssignment createMany
   */
  export type MT5AccountAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MT5AccountAssignments.
     */
    data: MT5AccountAssignmentCreateManyInput | MT5AccountAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MT5AccountAssignment createManyAndReturn
   */
  export type MT5AccountAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5AccountAssignment
     */
    select?: MT5AccountAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MT5AccountAssignments.
     */
    data: MT5AccountAssignmentCreateManyInput | MT5AccountAssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5AccountAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MT5AccountAssignment update
   */
  export type MT5AccountAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5AccountAssignment
     */
    select?: MT5AccountAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5AccountAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a MT5AccountAssignment.
     */
    data: XOR<MT5AccountAssignmentUpdateInput, MT5AccountAssignmentUncheckedUpdateInput>
    /**
     * Choose, which MT5AccountAssignment to update.
     */
    where: MT5AccountAssignmentWhereUniqueInput
  }

  /**
   * MT5AccountAssignment updateMany
   */
  export type MT5AccountAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MT5AccountAssignments.
     */
    data: XOR<MT5AccountAssignmentUpdateManyMutationInput, MT5AccountAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which MT5AccountAssignments to update
     */
    where?: MT5AccountAssignmentWhereInput
  }

  /**
   * MT5AccountAssignment upsert
   */
  export type MT5AccountAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5AccountAssignment
     */
    select?: MT5AccountAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5AccountAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the MT5AccountAssignment to update in case it exists.
     */
    where: MT5AccountAssignmentWhereUniqueInput
    /**
     * In case the MT5AccountAssignment found by the `where` argument doesn't exist, create a new MT5AccountAssignment with this data.
     */
    create: XOR<MT5AccountAssignmentCreateInput, MT5AccountAssignmentUncheckedCreateInput>
    /**
     * In case the MT5AccountAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MT5AccountAssignmentUpdateInput, MT5AccountAssignmentUncheckedUpdateInput>
  }

  /**
   * MT5AccountAssignment delete
   */
  export type MT5AccountAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5AccountAssignment
     */
    select?: MT5AccountAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5AccountAssignmentInclude<ExtArgs> | null
    /**
     * Filter which MT5AccountAssignment to delete.
     */
    where: MT5AccountAssignmentWhereUniqueInput
  }

  /**
   * MT5AccountAssignment deleteMany
   */
  export type MT5AccountAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MT5AccountAssignments to delete
     */
    where?: MT5AccountAssignmentWhereInput
  }

  /**
   * MT5AccountAssignment without action
   */
  export type MT5AccountAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5AccountAssignment
     */
    select?: MT5AccountAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5AccountAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model Prize
   */

  export type AggregatePrize = {
    _count: PrizeCountAggregateOutputType | null
    _avg: PrizeAvgAggregateOutputType | null
    _sum: PrizeSumAggregateOutputType | null
    _min: PrizeMinAggregateOutputType | null
    _max: PrizeMaxAggregateOutputType | null
  }

  export type PrizeAvgAggregateOutputType = {
    rank: number | null
    amount: number | null
  }

  export type PrizeSumAggregateOutputType = {
    rank: number | null
    amount: number | null
  }

  export type PrizeMinAggregateOutputType = {
    id: string | null
    period: string | null
    rank: number | null
    amount: number | null
    isActive: boolean | null
    updatedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PrizeMaxAggregateOutputType = {
    id: string | null
    period: string | null
    rank: number | null
    amount: number | null
    isActive: boolean | null
    updatedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PrizeCountAggregateOutputType = {
    id: number
    period: number
    rank: number
    amount: number
    isActive: number
    updatedBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PrizeAvgAggregateInputType = {
    rank?: true
    amount?: true
  }

  export type PrizeSumAggregateInputType = {
    rank?: true
    amount?: true
  }

  export type PrizeMinAggregateInputType = {
    id?: true
    period?: true
    rank?: true
    amount?: true
    isActive?: true
    updatedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PrizeMaxAggregateInputType = {
    id?: true
    period?: true
    rank?: true
    amount?: true
    isActive?: true
    updatedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PrizeCountAggregateInputType = {
    id?: true
    period?: true
    rank?: true
    amount?: true
    isActive?: true
    updatedBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PrizeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prize to aggregate.
     */
    where?: PrizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prizes to fetch.
     */
    orderBy?: PrizeOrderByWithRelationInput | PrizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Prizes
    **/
    _count?: true | PrizeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PrizeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PrizeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrizeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrizeMaxAggregateInputType
  }

  export type GetPrizeAggregateType<T extends PrizeAggregateArgs> = {
        [P in keyof T & keyof AggregatePrize]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrize[P]>
      : GetScalarType<T[P], AggregatePrize[P]>
  }




  export type PrizeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrizeWhereInput
    orderBy?: PrizeOrderByWithAggregationInput | PrizeOrderByWithAggregationInput[]
    by: PrizeScalarFieldEnum[] | PrizeScalarFieldEnum
    having?: PrizeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrizeCountAggregateInputType | true
    _avg?: PrizeAvgAggregateInputType
    _sum?: PrizeSumAggregateInputType
    _min?: PrizeMinAggregateInputType
    _max?: PrizeMaxAggregateInputType
  }

  export type PrizeGroupByOutputType = {
    id: string
    period: string
    rank: number
    amount: number
    isActive: boolean
    updatedBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: PrizeCountAggregateOutputType | null
    _avg: PrizeAvgAggregateOutputType | null
    _sum: PrizeSumAggregateOutputType | null
    _min: PrizeMinAggregateOutputType | null
    _max: PrizeMaxAggregateOutputType | null
  }

  type GetPrizeGroupByPayload<T extends PrizeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrizeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrizeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrizeGroupByOutputType[P]>
            : GetScalarType<T[P], PrizeGroupByOutputType[P]>
        }
      >
    >


  export type PrizeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    period?: boolean
    rank?: boolean
    amount?: boolean
    isActive?: boolean
    updatedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["prize"]>

  export type PrizeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    period?: boolean
    rank?: boolean
    amount?: boolean
    isActive?: boolean
    updatedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["prize"]>

  export type PrizeSelectScalar = {
    id?: boolean
    period?: boolean
    rank?: boolean
    amount?: boolean
    isActive?: boolean
    updatedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $PrizePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Prize"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      period: string
      rank: number
      amount: number
      isActive: boolean
      updatedBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["prize"]>
    composites: {}
  }

  type PrizeGetPayload<S extends boolean | null | undefined | PrizeDefaultArgs> = $Result.GetResult<Prisma.$PrizePayload, S>

  type PrizeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PrizeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PrizeCountAggregateInputType | true
    }

  export interface PrizeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Prize'], meta: { name: 'Prize' } }
    /**
     * Find zero or one Prize that matches the filter.
     * @param {PrizeFindUniqueArgs} args - Arguments to find a Prize
     * @example
     * // Get one Prize
     * const prize = await prisma.prize.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrizeFindUniqueArgs>(args: SelectSubset<T, PrizeFindUniqueArgs<ExtArgs>>): Prisma__PrizeClient<$Result.GetResult<Prisma.$PrizePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Prize that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PrizeFindUniqueOrThrowArgs} args - Arguments to find a Prize
     * @example
     * // Get one Prize
     * const prize = await prisma.prize.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrizeFindUniqueOrThrowArgs>(args: SelectSubset<T, PrizeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrizeClient<$Result.GetResult<Prisma.$PrizePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Prize that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrizeFindFirstArgs} args - Arguments to find a Prize
     * @example
     * // Get one Prize
     * const prize = await prisma.prize.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrizeFindFirstArgs>(args?: SelectSubset<T, PrizeFindFirstArgs<ExtArgs>>): Prisma__PrizeClient<$Result.GetResult<Prisma.$PrizePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Prize that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrizeFindFirstOrThrowArgs} args - Arguments to find a Prize
     * @example
     * // Get one Prize
     * const prize = await prisma.prize.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrizeFindFirstOrThrowArgs>(args?: SelectSubset<T, PrizeFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrizeClient<$Result.GetResult<Prisma.$PrizePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Prizes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrizeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prizes
     * const prizes = await prisma.prize.findMany()
     * 
     * // Get first 10 Prizes
     * const prizes = await prisma.prize.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const prizeWithIdOnly = await prisma.prize.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PrizeFindManyArgs>(args?: SelectSubset<T, PrizeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrizePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Prize.
     * @param {PrizeCreateArgs} args - Arguments to create a Prize.
     * @example
     * // Create one Prize
     * const Prize = await prisma.prize.create({
     *   data: {
     *     // ... data to create a Prize
     *   }
     * })
     * 
     */
    create<T extends PrizeCreateArgs>(args: SelectSubset<T, PrizeCreateArgs<ExtArgs>>): Prisma__PrizeClient<$Result.GetResult<Prisma.$PrizePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Prizes.
     * @param {PrizeCreateManyArgs} args - Arguments to create many Prizes.
     * @example
     * // Create many Prizes
     * const prize = await prisma.prize.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrizeCreateManyArgs>(args?: SelectSubset<T, PrizeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Prizes and returns the data saved in the database.
     * @param {PrizeCreateManyAndReturnArgs} args - Arguments to create many Prizes.
     * @example
     * // Create many Prizes
     * const prize = await prisma.prize.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Prizes and only return the `id`
     * const prizeWithIdOnly = await prisma.prize.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PrizeCreateManyAndReturnArgs>(args?: SelectSubset<T, PrizeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrizePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Prize.
     * @param {PrizeDeleteArgs} args - Arguments to delete one Prize.
     * @example
     * // Delete one Prize
     * const Prize = await prisma.prize.delete({
     *   where: {
     *     // ... filter to delete one Prize
     *   }
     * })
     * 
     */
    delete<T extends PrizeDeleteArgs>(args: SelectSubset<T, PrizeDeleteArgs<ExtArgs>>): Prisma__PrizeClient<$Result.GetResult<Prisma.$PrizePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Prize.
     * @param {PrizeUpdateArgs} args - Arguments to update one Prize.
     * @example
     * // Update one Prize
     * const prize = await prisma.prize.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrizeUpdateArgs>(args: SelectSubset<T, PrizeUpdateArgs<ExtArgs>>): Prisma__PrizeClient<$Result.GetResult<Prisma.$PrizePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Prizes.
     * @param {PrizeDeleteManyArgs} args - Arguments to filter Prizes to delete.
     * @example
     * // Delete a few Prizes
     * const { count } = await prisma.prize.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrizeDeleteManyArgs>(args?: SelectSubset<T, PrizeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prizes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrizeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prizes
     * const prize = await prisma.prize.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrizeUpdateManyArgs>(args: SelectSubset<T, PrizeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Prize.
     * @param {PrizeUpsertArgs} args - Arguments to update or create a Prize.
     * @example
     * // Update or create a Prize
     * const prize = await prisma.prize.upsert({
     *   create: {
     *     // ... data to create a Prize
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prize we want to update
     *   }
     * })
     */
    upsert<T extends PrizeUpsertArgs>(args: SelectSubset<T, PrizeUpsertArgs<ExtArgs>>): Prisma__PrizeClient<$Result.GetResult<Prisma.$PrizePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Prizes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrizeCountArgs} args - Arguments to filter Prizes to count.
     * @example
     * // Count the number of Prizes
     * const count = await prisma.prize.count({
     *   where: {
     *     // ... the filter for the Prizes we want to count
     *   }
     * })
    **/
    count<T extends PrizeCountArgs>(
      args?: Subset<T, PrizeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrizeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prize.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrizeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrizeAggregateArgs>(args: Subset<T, PrizeAggregateArgs>): Prisma.PrismaPromise<GetPrizeAggregateType<T>>

    /**
     * Group by Prize.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrizeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrizeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrizeGroupByArgs['orderBy'] }
        : { orderBy?: PrizeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrizeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrizeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Prize model
   */
  readonly fields: PrizeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Prize.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrizeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Prize model
   */ 
  interface PrizeFieldRefs {
    readonly id: FieldRef<"Prize", 'String'>
    readonly period: FieldRef<"Prize", 'String'>
    readonly rank: FieldRef<"Prize", 'Int'>
    readonly amount: FieldRef<"Prize", 'Float'>
    readonly isActive: FieldRef<"Prize", 'Boolean'>
    readonly updatedBy: FieldRef<"Prize", 'String'>
    readonly createdAt: FieldRef<"Prize", 'DateTime'>
    readonly updatedAt: FieldRef<"Prize", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Prize findUnique
   */
  export type PrizeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prize
     */
    select?: PrizeSelect<ExtArgs> | null
    /**
     * Filter, which Prize to fetch.
     */
    where: PrizeWhereUniqueInput
  }

  /**
   * Prize findUniqueOrThrow
   */
  export type PrizeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prize
     */
    select?: PrizeSelect<ExtArgs> | null
    /**
     * Filter, which Prize to fetch.
     */
    where: PrizeWhereUniqueInput
  }

  /**
   * Prize findFirst
   */
  export type PrizeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prize
     */
    select?: PrizeSelect<ExtArgs> | null
    /**
     * Filter, which Prize to fetch.
     */
    where?: PrizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prizes to fetch.
     */
    orderBy?: PrizeOrderByWithRelationInput | PrizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prizes.
     */
    cursor?: PrizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prizes.
     */
    distinct?: PrizeScalarFieldEnum | PrizeScalarFieldEnum[]
  }

  /**
   * Prize findFirstOrThrow
   */
  export type PrizeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prize
     */
    select?: PrizeSelect<ExtArgs> | null
    /**
     * Filter, which Prize to fetch.
     */
    where?: PrizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prizes to fetch.
     */
    orderBy?: PrizeOrderByWithRelationInput | PrizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prizes.
     */
    cursor?: PrizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prizes.
     */
    distinct?: PrizeScalarFieldEnum | PrizeScalarFieldEnum[]
  }

  /**
   * Prize findMany
   */
  export type PrizeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prize
     */
    select?: PrizeSelect<ExtArgs> | null
    /**
     * Filter, which Prizes to fetch.
     */
    where?: PrizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prizes to fetch.
     */
    orderBy?: PrizeOrderByWithRelationInput | PrizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Prizes.
     */
    cursor?: PrizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prizes.
     */
    skip?: number
    distinct?: PrizeScalarFieldEnum | PrizeScalarFieldEnum[]
  }

  /**
   * Prize create
   */
  export type PrizeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prize
     */
    select?: PrizeSelect<ExtArgs> | null
    /**
     * The data needed to create a Prize.
     */
    data: XOR<PrizeCreateInput, PrizeUncheckedCreateInput>
  }

  /**
   * Prize createMany
   */
  export type PrizeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Prizes.
     */
    data: PrizeCreateManyInput | PrizeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Prize createManyAndReturn
   */
  export type PrizeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prize
     */
    select?: PrizeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Prizes.
     */
    data: PrizeCreateManyInput | PrizeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Prize update
   */
  export type PrizeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prize
     */
    select?: PrizeSelect<ExtArgs> | null
    /**
     * The data needed to update a Prize.
     */
    data: XOR<PrizeUpdateInput, PrizeUncheckedUpdateInput>
    /**
     * Choose, which Prize to update.
     */
    where: PrizeWhereUniqueInput
  }

  /**
   * Prize updateMany
   */
  export type PrizeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Prizes.
     */
    data: XOR<PrizeUpdateManyMutationInput, PrizeUncheckedUpdateManyInput>
    /**
     * Filter which Prizes to update
     */
    where?: PrizeWhereInput
  }

  /**
   * Prize upsert
   */
  export type PrizeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prize
     */
    select?: PrizeSelect<ExtArgs> | null
    /**
     * The filter to search for the Prize to update in case it exists.
     */
    where: PrizeWhereUniqueInput
    /**
     * In case the Prize found by the `where` argument doesn't exist, create a new Prize with this data.
     */
    create: XOR<PrizeCreateInput, PrizeUncheckedCreateInput>
    /**
     * In case the Prize was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrizeUpdateInput, PrizeUncheckedUpdateInput>
  }

  /**
   * Prize delete
   */
  export type PrizeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prize
     */
    select?: PrizeSelect<ExtArgs> | null
    /**
     * Filter which Prize to delete.
     */
    where: PrizeWhereUniqueInput
  }

  /**
   * Prize deleteMany
   */
  export type PrizeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prizes to delete
     */
    where?: PrizeWhereInput
  }

  /**
   * Prize without action
   */
  export type PrizeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prize
     */
    select?: PrizeSelect<ExtArgs> | null
  }


  /**
   * Model GlobalSettings
   */

  export type AggregateGlobalSettings = {
    _count: GlobalSettingsCountAggregateOutputType | null
    _min: GlobalSettingsMinAggregateOutputType | null
    _max: GlobalSettingsMaxAggregateOutputType | null
  }

  export type GlobalSettingsMinAggregateOutputType = {
    id: string | null
    settingKey: string | null
    settingValue: string | null
    description: string | null
    updatedBy: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type GlobalSettingsMaxAggregateOutputType = {
    id: string | null
    settingKey: string | null
    settingValue: string | null
    description: string | null
    updatedBy: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type GlobalSettingsCountAggregateOutputType = {
    id: number
    settingKey: number
    settingValue: number
    description: number
    updatedBy: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type GlobalSettingsMinAggregateInputType = {
    id?: true
    settingKey?: true
    settingValue?: true
    description?: true
    updatedBy?: true
    updatedAt?: true
    createdAt?: true
  }

  export type GlobalSettingsMaxAggregateInputType = {
    id?: true
    settingKey?: true
    settingValue?: true
    description?: true
    updatedBy?: true
    updatedAt?: true
    createdAt?: true
  }

  export type GlobalSettingsCountAggregateInputType = {
    id?: true
    settingKey?: true
    settingValue?: true
    description?: true
    updatedBy?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type GlobalSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GlobalSettings to aggregate.
     */
    where?: GlobalSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GlobalSettings to fetch.
     */
    orderBy?: GlobalSettingsOrderByWithRelationInput | GlobalSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GlobalSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GlobalSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GlobalSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GlobalSettings
    **/
    _count?: true | GlobalSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GlobalSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GlobalSettingsMaxAggregateInputType
  }

  export type GetGlobalSettingsAggregateType<T extends GlobalSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateGlobalSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGlobalSettings[P]>
      : GetScalarType<T[P], AggregateGlobalSettings[P]>
  }




  export type GlobalSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GlobalSettingsWhereInput
    orderBy?: GlobalSettingsOrderByWithAggregationInput | GlobalSettingsOrderByWithAggregationInput[]
    by: GlobalSettingsScalarFieldEnum[] | GlobalSettingsScalarFieldEnum
    having?: GlobalSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GlobalSettingsCountAggregateInputType | true
    _min?: GlobalSettingsMinAggregateInputType
    _max?: GlobalSettingsMaxAggregateInputType
  }

  export type GlobalSettingsGroupByOutputType = {
    id: string
    settingKey: string
    settingValue: string
    description: string | null
    updatedBy: string | null
    updatedAt: Date
    createdAt: Date
    _count: GlobalSettingsCountAggregateOutputType | null
    _min: GlobalSettingsMinAggregateOutputType | null
    _max: GlobalSettingsMaxAggregateOutputType | null
  }

  type GetGlobalSettingsGroupByPayload<T extends GlobalSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GlobalSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GlobalSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GlobalSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], GlobalSettingsGroupByOutputType[P]>
        }
      >
    >


  export type GlobalSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    settingKey?: boolean
    settingValue?: boolean
    description?: boolean
    updatedBy?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["globalSettings"]>

  export type GlobalSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    settingKey?: boolean
    settingValue?: boolean
    description?: boolean
    updatedBy?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["globalSettings"]>

  export type GlobalSettingsSelectScalar = {
    id?: boolean
    settingKey?: boolean
    settingValue?: boolean
    description?: boolean
    updatedBy?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }


  export type $GlobalSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GlobalSettings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      settingKey: string
      settingValue: string
      description: string | null
      updatedBy: string | null
      updatedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["globalSettings"]>
    composites: {}
  }

  type GlobalSettingsGetPayload<S extends boolean | null | undefined | GlobalSettingsDefaultArgs> = $Result.GetResult<Prisma.$GlobalSettingsPayload, S>

  type GlobalSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GlobalSettingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GlobalSettingsCountAggregateInputType | true
    }

  export interface GlobalSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GlobalSettings'], meta: { name: 'GlobalSettings' } }
    /**
     * Find zero or one GlobalSettings that matches the filter.
     * @param {GlobalSettingsFindUniqueArgs} args - Arguments to find a GlobalSettings
     * @example
     * // Get one GlobalSettings
     * const globalSettings = await prisma.globalSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GlobalSettingsFindUniqueArgs>(args: SelectSubset<T, GlobalSettingsFindUniqueArgs<ExtArgs>>): Prisma__GlobalSettingsClient<$Result.GetResult<Prisma.$GlobalSettingsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one GlobalSettings that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GlobalSettingsFindUniqueOrThrowArgs} args - Arguments to find a GlobalSettings
     * @example
     * // Get one GlobalSettings
     * const globalSettings = await prisma.globalSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GlobalSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, GlobalSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GlobalSettingsClient<$Result.GetResult<Prisma.$GlobalSettingsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first GlobalSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalSettingsFindFirstArgs} args - Arguments to find a GlobalSettings
     * @example
     * // Get one GlobalSettings
     * const globalSettings = await prisma.globalSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GlobalSettingsFindFirstArgs>(args?: SelectSubset<T, GlobalSettingsFindFirstArgs<ExtArgs>>): Prisma__GlobalSettingsClient<$Result.GetResult<Prisma.$GlobalSettingsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first GlobalSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalSettingsFindFirstOrThrowArgs} args - Arguments to find a GlobalSettings
     * @example
     * // Get one GlobalSettings
     * const globalSettings = await prisma.globalSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GlobalSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, GlobalSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__GlobalSettingsClient<$Result.GetResult<Prisma.$GlobalSettingsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more GlobalSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GlobalSettings
     * const globalSettings = await prisma.globalSettings.findMany()
     * 
     * // Get first 10 GlobalSettings
     * const globalSettings = await prisma.globalSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const globalSettingsWithIdOnly = await prisma.globalSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GlobalSettingsFindManyArgs>(args?: SelectSubset<T, GlobalSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GlobalSettingsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a GlobalSettings.
     * @param {GlobalSettingsCreateArgs} args - Arguments to create a GlobalSettings.
     * @example
     * // Create one GlobalSettings
     * const GlobalSettings = await prisma.globalSettings.create({
     *   data: {
     *     // ... data to create a GlobalSettings
     *   }
     * })
     * 
     */
    create<T extends GlobalSettingsCreateArgs>(args: SelectSubset<T, GlobalSettingsCreateArgs<ExtArgs>>): Prisma__GlobalSettingsClient<$Result.GetResult<Prisma.$GlobalSettingsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many GlobalSettings.
     * @param {GlobalSettingsCreateManyArgs} args - Arguments to create many GlobalSettings.
     * @example
     * // Create many GlobalSettings
     * const globalSettings = await prisma.globalSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GlobalSettingsCreateManyArgs>(args?: SelectSubset<T, GlobalSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GlobalSettings and returns the data saved in the database.
     * @param {GlobalSettingsCreateManyAndReturnArgs} args - Arguments to create many GlobalSettings.
     * @example
     * // Create many GlobalSettings
     * const globalSettings = await prisma.globalSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GlobalSettings and only return the `id`
     * const globalSettingsWithIdOnly = await prisma.globalSettings.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GlobalSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, GlobalSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GlobalSettingsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a GlobalSettings.
     * @param {GlobalSettingsDeleteArgs} args - Arguments to delete one GlobalSettings.
     * @example
     * // Delete one GlobalSettings
     * const GlobalSettings = await prisma.globalSettings.delete({
     *   where: {
     *     // ... filter to delete one GlobalSettings
     *   }
     * })
     * 
     */
    delete<T extends GlobalSettingsDeleteArgs>(args: SelectSubset<T, GlobalSettingsDeleteArgs<ExtArgs>>): Prisma__GlobalSettingsClient<$Result.GetResult<Prisma.$GlobalSettingsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one GlobalSettings.
     * @param {GlobalSettingsUpdateArgs} args - Arguments to update one GlobalSettings.
     * @example
     * // Update one GlobalSettings
     * const globalSettings = await prisma.globalSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GlobalSettingsUpdateArgs>(args: SelectSubset<T, GlobalSettingsUpdateArgs<ExtArgs>>): Prisma__GlobalSettingsClient<$Result.GetResult<Prisma.$GlobalSettingsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more GlobalSettings.
     * @param {GlobalSettingsDeleteManyArgs} args - Arguments to filter GlobalSettings to delete.
     * @example
     * // Delete a few GlobalSettings
     * const { count } = await prisma.globalSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GlobalSettingsDeleteManyArgs>(args?: SelectSubset<T, GlobalSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GlobalSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GlobalSettings
     * const globalSettings = await prisma.globalSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GlobalSettingsUpdateManyArgs>(args: SelectSubset<T, GlobalSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GlobalSettings.
     * @param {GlobalSettingsUpsertArgs} args - Arguments to update or create a GlobalSettings.
     * @example
     * // Update or create a GlobalSettings
     * const globalSettings = await prisma.globalSettings.upsert({
     *   create: {
     *     // ... data to create a GlobalSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GlobalSettings we want to update
     *   }
     * })
     */
    upsert<T extends GlobalSettingsUpsertArgs>(args: SelectSubset<T, GlobalSettingsUpsertArgs<ExtArgs>>): Prisma__GlobalSettingsClient<$Result.GetResult<Prisma.$GlobalSettingsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of GlobalSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalSettingsCountArgs} args - Arguments to filter GlobalSettings to count.
     * @example
     * // Count the number of GlobalSettings
     * const count = await prisma.globalSettings.count({
     *   where: {
     *     // ... the filter for the GlobalSettings we want to count
     *   }
     * })
    **/
    count<T extends GlobalSettingsCountArgs>(
      args?: Subset<T, GlobalSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GlobalSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GlobalSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GlobalSettingsAggregateArgs>(args: Subset<T, GlobalSettingsAggregateArgs>): Prisma.PrismaPromise<GetGlobalSettingsAggregateType<T>>

    /**
     * Group by GlobalSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GlobalSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GlobalSettingsGroupByArgs['orderBy'] }
        : { orderBy?: GlobalSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GlobalSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGlobalSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GlobalSettings model
   */
  readonly fields: GlobalSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GlobalSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GlobalSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GlobalSettings model
   */ 
  interface GlobalSettingsFieldRefs {
    readonly id: FieldRef<"GlobalSettings", 'String'>
    readonly settingKey: FieldRef<"GlobalSettings", 'String'>
    readonly settingValue: FieldRef<"GlobalSettings", 'String'>
    readonly description: FieldRef<"GlobalSettings", 'String'>
    readonly updatedBy: FieldRef<"GlobalSettings", 'String'>
    readonly updatedAt: FieldRef<"GlobalSettings", 'DateTime'>
    readonly createdAt: FieldRef<"GlobalSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GlobalSettings findUnique
   */
  export type GlobalSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalSettings
     */
    select?: GlobalSettingsSelect<ExtArgs> | null
    /**
     * Filter, which GlobalSettings to fetch.
     */
    where: GlobalSettingsWhereUniqueInput
  }

  /**
   * GlobalSettings findUniqueOrThrow
   */
  export type GlobalSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalSettings
     */
    select?: GlobalSettingsSelect<ExtArgs> | null
    /**
     * Filter, which GlobalSettings to fetch.
     */
    where: GlobalSettingsWhereUniqueInput
  }

  /**
   * GlobalSettings findFirst
   */
  export type GlobalSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalSettings
     */
    select?: GlobalSettingsSelect<ExtArgs> | null
    /**
     * Filter, which GlobalSettings to fetch.
     */
    where?: GlobalSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GlobalSettings to fetch.
     */
    orderBy?: GlobalSettingsOrderByWithRelationInput | GlobalSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GlobalSettings.
     */
    cursor?: GlobalSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GlobalSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GlobalSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GlobalSettings.
     */
    distinct?: GlobalSettingsScalarFieldEnum | GlobalSettingsScalarFieldEnum[]
  }

  /**
   * GlobalSettings findFirstOrThrow
   */
  export type GlobalSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalSettings
     */
    select?: GlobalSettingsSelect<ExtArgs> | null
    /**
     * Filter, which GlobalSettings to fetch.
     */
    where?: GlobalSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GlobalSettings to fetch.
     */
    orderBy?: GlobalSettingsOrderByWithRelationInput | GlobalSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GlobalSettings.
     */
    cursor?: GlobalSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GlobalSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GlobalSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GlobalSettings.
     */
    distinct?: GlobalSettingsScalarFieldEnum | GlobalSettingsScalarFieldEnum[]
  }

  /**
   * GlobalSettings findMany
   */
  export type GlobalSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalSettings
     */
    select?: GlobalSettingsSelect<ExtArgs> | null
    /**
     * Filter, which GlobalSettings to fetch.
     */
    where?: GlobalSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GlobalSettings to fetch.
     */
    orderBy?: GlobalSettingsOrderByWithRelationInput | GlobalSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GlobalSettings.
     */
    cursor?: GlobalSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GlobalSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GlobalSettings.
     */
    skip?: number
    distinct?: GlobalSettingsScalarFieldEnum | GlobalSettingsScalarFieldEnum[]
  }

  /**
   * GlobalSettings create
   */
  export type GlobalSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalSettings
     */
    select?: GlobalSettingsSelect<ExtArgs> | null
    /**
     * The data needed to create a GlobalSettings.
     */
    data: XOR<GlobalSettingsCreateInput, GlobalSettingsUncheckedCreateInput>
  }

  /**
   * GlobalSettings createMany
   */
  export type GlobalSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GlobalSettings.
     */
    data: GlobalSettingsCreateManyInput | GlobalSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GlobalSettings createManyAndReturn
   */
  export type GlobalSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalSettings
     */
    select?: GlobalSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many GlobalSettings.
     */
    data: GlobalSettingsCreateManyInput | GlobalSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GlobalSettings update
   */
  export type GlobalSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalSettings
     */
    select?: GlobalSettingsSelect<ExtArgs> | null
    /**
     * The data needed to update a GlobalSettings.
     */
    data: XOR<GlobalSettingsUpdateInput, GlobalSettingsUncheckedUpdateInput>
    /**
     * Choose, which GlobalSettings to update.
     */
    where: GlobalSettingsWhereUniqueInput
  }

  /**
   * GlobalSettings updateMany
   */
  export type GlobalSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GlobalSettings.
     */
    data: XOR<GlobalSettingsUpdateManyMutationInput, GlobalSettingsUncheckedUpdateManyInput>
    /**
     * Filter which GlobalSettings to update
     */
    where?: GlobalSettingsWhereInput
  }

  /**
   * GlobalSettings upsert
   */
  export type GlobalSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalSettings
     */
    select?: GlobalSettingsSelect<ExtArgs> | null
    /**
     * The filter to search for the GlobalSettings to update in case it exists.
     */
    where: GlobalSettingsWhereUniqueInput
    /**
     * In case the GlobalSettings found by the `where` argument doesn't exist, create a new GlobalSettings with this data.
     */
    create: XOR<GlobalSettingsCreateInput, GlobalSettingsUncheckedCreateInput>
    /**
     * In case the GlobalSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GlobalSettingsUpdateInput, GlobalSettingsUncheckedUpdateInput>
  }

  /**
   * GlobalSettings delete
   */
  export type GlobalSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalSettings
     */
    select?: GlobalSettingsSelect<ExtArgs> | null
    /**
     * Filter which GlobalSettings to delete.
     */
    where: GlobalSettingsWhereUniqueInput
  }

  /**
   * GlobalSettings deleteMany
   */
  export type GlobalSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GlobalSettings to delete
     */
    where?: GlobalSettingsWhereInput
  }

  /**
   * GlobalSettings without action
   */
  export type GlobalSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalSettings
     */
    select?: GlobalSettingsSelect<ExtArgs> | null
  }


  /**
   * Model AnonymousAccount
   */

  export type AggregateAnonymousAccount = {
    _count: AnonymousAccountCountAggregateOutputType | null
    _min: AnonymousAccountMinAggregateOutputType | null
    _max: AnonymousAccountMaxAggregateOutputType | null
  }

  export type AnonymousAccountMinAggregateOutputType = {
    id: string | null
    anonymousId: string | null
    userId: string | null
    mt5AccountNumber: string | null
    ibPartnerId: string | null
    isActive: boolean | null
    registeredAt: Date | null
  }

  export type AnonymousAccountMaxAggregateOutputType = {
    id: string | null
    anonymousId: string | null
    userId: string | null
    mt5AccountNumber: string | null
    ibPartnerId: string | null
    isActive: boolean | null
    registeredAt: Date | null
  }

  export type AnonymousAccountCountAggregateOutputType = {
    id: number
    anonymousId: number
    userId: number
    mt5AccountNumber: number
    ibPartnerId: number
    isActive: number
    registeredAt: number
    _all: number
  }


  export type AnonymousAccountMinAggregateInputType = {
    id?: true
    anonymousId?: true
    userId?: true
    mt5AccountNumber?: true
    ibPartnerId?: true
    isActive?: true
    registeredAt?: true
  }

  export type AnonymousAccountMaxAggregateInputType = {
    id?: true
    anonymousId?: true
    userId?: true
    mt5AccountNumber?: true
    ibPartnerId?: true
    isActive?: true
    registeredAt?: true
  }

  export type AnonymousAccountCountAggregateInputType = {
    id?: true
    anonymousId?: true
    userId?: true
    mt5AccountNumber?: true
    ibPartnerId?: true
    isActive?: true
    registeredAt?: true
    _all?: true
  }

  export type AnonymousAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnonymousAccount to aggregate.
     */
    where?: AnonymousAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnonymousAccounts to fetch.
     */
    orderBy?: AnonymousAccountOrderByWithRelationInput | AnonymousAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnonymousAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnonymousAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnonymousAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AnonymousAccounts
    **/
    _count?: true | AnonymousAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnonymousAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnonymousAccountMaxAggregateInputType
  }

  export type GetAnonymousAccountAggregateType<T extends AnonymousAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAnonymousAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnonymousAccount[P]>
      : GetScalarType<T[P], AggregateAnonymousAccount[P]>
  }




  export type AnonymousAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnonymousAccountWhereInput
    orderBy?: AnonymousAccountOrderByWithAggregationInput | AnonymousAccountOrderByWithAggregationInput[]
    by: AnonymousAccountScalarFieldEnum[] | AnonymousAccountScalarFieldEnum
    having?: AnonymousAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnonymousAccountCountAggregateInputType | true
    _min?: AnonymousAccountMinAggregateInputType
    _max?: AnonymousAccountMaxAggregateInputType
  }

  export type AnonymousAccountGroupByOutputType = {
    id: string
    anonymousId: string
    userId: string
    mt5AccountNumber: string
    ibPartnerId: string
    isActive: boolean
    registeredAt: Date
    _count: AnonymousAccountCountAggregateOutputType | null
    _min: AnonymousAccountMinAggregateOutputType | null
    _max: AnonymousAccountMaxAggregateOutputType | null
  }

  type GetAnonymousAccountGroupByPayload<T extends AnonymousAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnonymousAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnonymousAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnonymousAccountGroupByOutputType[P]>
            : GetScalarType<T[P], AnonymousAccountGroupByOutputType[P]>
        }
      >
    >


  export type AnonymousAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    anonymousId?: boolean
    userId?: boolean
    mt5AccountNumber?: boolean
    ibPartnerId?: boolean
    isActive?: boolean
    registeredAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    ibPartner?: boolean | IBPartnerDefaultArgs<ExtArgs>
    commissions?: boolean | AnonymousAccount$commissionsArgs<ExtArgs>
    _count?: boolean | AnonymousAccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["anonymousAccount"]>

  export type AnonymousAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    anonymousId?: boolean
    userId?: boolean
    mt5AccountNumber?: boolean
    ibPartnerId?: boolean
    isActive?: boolean
    registeredAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    ibPartner?: boolean | IBPartnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["anonymousAccount"]>

  export type AnonymousAccountSelectScalar = {
    id?: boolean
    anonymousId?: boolean
    userId?: boolean
    mt5AccountNumber?: boolean
    ibPartnerId?: boolean
    isActive?: boolean
    registeredAt?: boolean
  }

  export type AnonymousAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    ibPartner?: boolean | IBPartnerDefaultArgs<ExtArgs>
    commissions?: boolean | AnonymousAccount$commissionsArgs<ExtArgs>
    _count?: boolean | AnonymousAccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AnonymousAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    ibPartner?: boolean | IBPartnerDefaultArgs<ExtArgs>
  }

  export type $AnonymousAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AnonymousAccount"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      ibPartner: Prisma.$IBPartnerPayload<ExtArgs>
      commissions: Prisma.$IBCommissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      anonymousId: string
      userId: string
      mt5AccountNumber: string
      ibPartnerId: string
      isActive: boolean
      registeredAt: Date
    }, ExtArgs["result"]["anonymousAccount"]>
    composites: {}
  }

  type AnonymousAccountGetPayload<S extends boolean | null | undefined | AnonymousAccountDefaultArgs> = $Result.GetResult<Prisma.$AnonymousAccountPayload, S>

  type AnonymousAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AnonymousAccountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AnonymousAccountCountAggregateInputType | true
    }

  export interface AnonymousAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AnonymousAccount'], meta: { name: 'AnonymousAccount' } }
    /**
     * Find zero or one AnonymousAccount that matches the filter.
     * @param {AnonymousAccountFindUniqueArgs} args - Arguments to find a AnonymousAccount
     * @example
     * // Get one AnonymousAccount
     * const anonymousAccount = await prisma.anonymousAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnonymousAccountFindUniqueArgs>(args: SelectSubset<T, AnonymousAccountFindUniqueArgs<ExtArgs>>): Prisma__AnonymousAccountClient<$Result.GetResult<Prisma.$AnonymousAccountPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AnonymousAccount that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AnonymousAccountFindUniqueOrThrowArgs} args - Arguments to find a AnonymousAccount
     * @example
     * // Get one AnonymousAccount
     * const anonymousAccount = await prisma.anonymousAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnonymousAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AnonymousAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnonymousAccountClient<$Result.GetResult<Prisma.$AnonymousAccountPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AnonymousAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnonymousAccountFindFirstArgs} args - Arguments to find a AnonymousAccount
     * @example
     * // Get one AnonymousAccount
     * const anonymousAccount = await prisma.anonymousAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnonymousAccountFindFirstArgs>(args?: SelectSubset<T, AnonymousAccountFindFirstArgs<ExtArgs>>): Prisma__AnonymousAccountClient<$Result.GetResult<Prisma.$AnonymousAccountPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AnonymousAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnonymousAccountFindFirstOrThrowArgs} args - Arguments to find a AnonymousAccount
     * @example
     * // Get one AnonymousAccount
     * const anonymousAccount = await prisma.anonymousAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnonymousAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AnonymousAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnonymousAccountClient<$Result.GetResult<Prisma.$AnonymousAccountPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AnonymousAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnonymousAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnonymousAccounts
     * const anonymousAccounts = await prisma.anonymousAccount.findMany()
     * 
     * // Get first 10 AnonymousAccounts
     * const anonymousAccounts = await prisma.anonymousAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const anonymousAccountWithIdOnly = await prisma.anonymousAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnonymousAccountFindManyArgs>(args?: SelectSubset<T, AnonymousAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnonymousAccountPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AnonymousAccount.
     * @param {AnonymousAccountCreateArgs} args - Arguments to create a AnonymousAccount.
     * @example
     * // Create one AnonymousAccount
     * const AnonymousAccount = await prisma.anonymousAccount.create({
     *   data: {
     *     // ... data to create a AnonymousAccount
     *   }
     * })
     * 
     */
    create<T extends AnonymousAccountCreateArgs>(args: SelectSubset<T, AnonymousAccountCreateArgs<ExtArgs>>): Prisma__AnonymousAccountClient<$Result.GetResult<Prisma.$AnonymousAccountPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AnonymousAccounts.
     * @param {AnonymousAccountCreateManyArgs} args - Arguments to create many AnonymousAccounts.
     * @example
     * // Create many AnonymousAccounts
     * const anonymousAccount = await prisma.anonymousAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnonymousAccountCreateManyArgs>(args?: SelectSubset<T, AnonymousAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AnonymousAccounts and returns the data saved in the database.
     * @param {AnonymousAccountCreateManyAndReturnArgs} args - Arguments to create many AnonymousAccounts.
     * @example
     * // Create many AnonymousAccounts
     * const anonymousAccount = await prisma.anonymousAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AnonymousAccounts and only return the `id`
     * const anonymousAccountWithIdOnly = await prisma.anonymousAccount.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnonymousAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AnonymousAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnonymousAccountPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AnonymousAccount.
     * @param {AnonymousAccountDeleteArgs} args - Arguments to delete one AnonymousAccount.
     * @example
     * // Delete one AnonymousAccount
     * const AnonymousAccount = await prisma.anonymousAccount.delete({
     *   where: {
     *     // ... filter to delete one AnonymousAccount
     *   }
     * })
     * 
     */
    delete<T extends AnonymousAccountDeleteArgs>(args: SelectSubset<T, AnonymousAccountDeleteArgs<ExtArgs>>): Prisma__AnonymousAccountClient<$Result.GetResult<Prisma.$AnonymousAccountPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AnonymousAccount.
     * @param {AnonymousAccountUpdateArgs} args - Arguments to update one AnonymousAccount.
     * @example
     * // Update one AnonymousAccount
     * const anonymousAccount = await prisma.anonymousAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnonymousAccountUpdateArgs>(args: SelectSubset<T, AnonymousAccountUpdateArgs<ExtArgs>>): Prisma__AnonymousAccountClient<$Result.GetResult<Prisma.$AnonymousAccountPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AnonymousAccounts.
     * @param {AnonymousAccountDeleteManyArgs} args - Arguments to filter AnonymousAccounts to delete.
     * @example
     * // Delete a few AnonymousAccounts
     * const { count } = await prisma.anonymousAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnonymousAccountDeleteManyArgs>(args?: SelectSubset<T, AnonymousAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnonymousAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnonymousAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnonymousAccounts
     * const anonymousAccount = await prisma.anonymousAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnonymousAccountUpdateManyArgs>(args: SelectSubset<T, AnonymousAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AnonymousAccount.
     * @param {AnonymousAccountUpsertArgs} args - Arguments to update or create a AnonymousAccount.
     * @example
     * // Update or create a AnonymousAccount
     * const anonymousAccount = await prisma.anonymousAccount.upsert({
     *   create: {
     *     // ... data to create a AnonymousAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnonymousAccount we want to update
     *   }
     * })
     */
    upsert<T extends AnonymousAccountUpsertArgs>(args: SelectSubset<T, AnonymousAccountUpsertArgs<ExtArgs>>): Prisma__AnonymousAccountClient<$Result.GetResult<Prisma.$AnonymousAccountPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AnonymousAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnonymousAccountCountArgs} args - Arguments to filter AnonymousAccounts to count.
     * @example
     * // Count the number of AnonymousAccounts
     * const count = await prisma.anonymousAccount.count({
     *   where: {
     *     // ... the filter for the AnonymousAccounts we want to count
     *   }
     * })
    **/
    count<T extends AnonymousAccountCountArgs>(
      args?: Subset<T, AnonymousAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnonymousAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnonymousAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnonymousAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnonymousAccountAggregateArgs>(args: Subset<T, AnonymousAccountAggregateArgs>): Prisma.PrismaPromise<GetAnonymousAccountAggregateType<T>>

    /**
     * Group by AnonymousAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnonymousAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnonymousAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnonymousAccountGroupByArgs['orderBy'] }
        : { orderBy?: AnonymousAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnonymousAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnonymousAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AnonymousAccount model
   */
  readonly fields: AnonymousAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnonymousAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnonymousAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    ibPartner<T extends IBPartnerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IBPartnerDefaultArgs<ExtArgs>>): Prisma__IBPartnerClient<$Result.GetResult<Prisma.$IBPartnerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    commissions<T extends AnonymousAccount$commissionsArgs<ExtArgs> = {}>(args?: Subset<T, AnonymousAccount$commissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IBCommissionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AnonymousAccount model
   */ 
  interface AnonymousAccountFieldRefs {
    readonly id: FieldRef<"AnonymousAccount", 'String'>
    readonly anonymousId: FieldRef<"AnonymousAccount", 'String'>
    readonly userId: FieldRef<"AnonymousAccount", 'String'>
    readonly mt5AccountNumber: FieldRef<"AnonymousAccount", 'String'>
    readonly ibPartnerId: FieldRef<"AnonymousAccount", 'String'>
    readonly isActive: FieldRef<"AnonymousAccount", 'Boolean'>
    readonly registeredAt: FieldRef<"AnonymousAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AnonymousAccount findUnique
   */
  export type AnonymousAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousAccount
     */
    select?: AnonymousAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnonymousAccountInclude<ExtArgs> | null
    /**
     * Filter, which AnonymousAccount to fetch.
     */
    where: AnonymousAccountWhereUniqueInput
  }

  /**
   * AnonymousAccount findUniqueOrThrow
   */
  export type AnonymousAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousAccount
     */
    select?: AnonymousAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnonymousAccountInclude<ExtArgs> | null
    /**
     * Filter, which AnonymousAccount to fetch.
     */
    where: AnonymousAccountWhereUniqueInput
  }

  /**
   * AnonymousAccount findFirst
   */
  export type AnonymousAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousAccount
     */
    select?: AnonymousAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnonymousAccountInclude<ExtArgs> | null
    /**
     * Filter, which AnonymousAccount to fetch.
     */
    where?: AnonymousAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnonymousAccounts to fetch.
     */
    orderBy?: AnonymousAccountOrderByWithRelationInput | AnonymousAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnonymousAccounts.
     */
    cursor?: AnonymousAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnonymousAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnonymousAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnonymousAccounts.
     */
    distinct?: AnonymousAccountScalarFieldEnum | AnonymousAccountScalarFieldEnum[]
  }

  /**
   * AnonymousAccount findFirstOrThrow
   */
  export type AnonymousAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousAccount
     */
    select?: AnonymousAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnonymousAccountInclude<ExtArgs> | null
    /**
     * Filter, which AnonymousAccount to fetch.
     */
    where?: AnonymousAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnonymousAccounts to fetch.
     */
    orderBy?: AnonymousAccountOrderByWithRelationInput | AnonymousAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnonymousAccounts.
     */
    cursor?: AnonymousAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnonymousAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnonymousAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnonymousAccounts.
     */
    distinct?: AnonymousAccountScalarFieldEnum | AnonymousAccountScalarFieldEnum[]
  }

  /**
   * AnonymousAccount findMany
   */
  export type AnonymousAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousAccount
     */
    select?: AnonymousAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnonymousAccountInclude<ExtArgs> | null
    /**
     * Filter, which AnonymousAccounts to fetch.
     */
    where?: AnonymousAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnonymousAccounts to fetch.
     */
    orderBy?: AnonymousAccountOrderByWithRelationInput | AnonymousAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AnonymousAccounts.
     */
    cursor?: AnonymousAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnonymousAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnonymousAccounts.
     */
    skip?: number
    distinct?: AnonymousAccountScalarFieldEnum | AnonymousAccountScalarFieldEnum[]
  }

  /**
   * AnonymousAccount create
   */
  export type AnonymousAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousAccount
     */
    select?: AnonymousAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnonymousAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a AnonymousAccount.
     */
    data: XOR<AnonymousAccountCreateInput, AnonymousAccountUncheckedCreateInput>
  }

  /**
   * AnonymousAccount createMany
   */
  export type AnonymousAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AnonymousAccounts.
     */
    data: AnonymousAccountCreateManyInput | AnonymousAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnonymousAccount createManyAndReturn
   */
  export type AnonymousAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousAccount
     */
    select?: AnonymousAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AnonymousAccounts.
     */
    data: AnonymousAccountCreateManyInput | AnonymousAccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnonymousAccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AnonymousAccount update
   */
  export type AnonymousAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousAccount
     */
    select?: AnonymousAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnonymousAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a AnonymousAccount.
     */
    data: XOR<AnonymousAccountUpdateInput, AnonymousAccountUncheckedUpdateInput>
    /**
     * Choose, which AnonymousAccount to update.
     */
    where: AnonymousAccountWhereUniqueInput
  }

  /**
   * AnonymousAccount updateMany
   */
  export type AnonymousAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AnonymousAccounts.
     */
    data: XOR<AnonymousAccountUpdateManyMutationInput, AnonymousAccountUncheckedUpdateManyInput>
    /**
     * Filter which AnonymousAccounts to update
     */
    where?: AnonymousAccountWhereInput
  }

  /**
   * AnonymousAccount upsert
   */
  export type AnonymousAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousAccount
     */
    select?: AnonymousAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnonymousAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the AnonymousAccount to update in case it exists.
     */
    where: AnonymousAccountWhereUniqueInput
    /**
     * In case the AnonymousAccount found by the `where` argument doesn't exist, create a new AnonymousAccount with this data.
     */
    create: XOR<AnonymousAccountCreateInput, AnonymousAccountUncheckedCreateInput>
    /**
     * In case the AnonymousAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnonymousAccountUpdateInput, AnonymousAccountUncheckedUpdateInput>
  }

  /**
   * AnonymousAccount delete
   */
  export type AnonymousAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousAccount
     */
    select?: AnonymousAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnonymousAccountInclude<ExtArgs> | null
    /**
     * Filter which AnonymousAccount to delete.
     */
    where: AnonymousAccountWhereUniqueInput
  }

  /**
   * AnonymousAccount deleteMany
   */
  export type AnonymousAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnonymousAccounts to delete
     */
    where?: AnonymousAccountWhereInput
  }

  /**
   * AnonymousAccount.commissions
   */
  export type AnonymousAccount$commissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IBCommission
     */
    select?: IBCommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IBCommissionInclude<ExtArgs> | null
    where?: IBCommissionWhereInput
    orderBy?: IBCommissionOrderByWithRelationInput | IBCommissionOrderByWithRelationInput[]
    cursor?: IBCommissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IBCommissionScalarFieldEnum | IBCommissionScalarFieldEnum[]
  }

  /**
   * AnonymousAccount without action
   */
  export type AnonymousAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousAccount
     */
    select?: AnonymousAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnonymousAccountInclude<ExtArgs> | null
  }


  /**
   * Model IBCommission
   */

  export type AggregateIBCommission = {
    _count: IBCommissionCountAggregateOutputType | null
    _avg: IBCommissionAvgAggregateOutputType | null
    _sum: IBCommissionSumAggregateOutputType | null
    _min: IBCommissionMinAggregateOutputType | null
    _max: IBCommissionMaxAggregateOutputType | null
  }

  export type IBCommissionAvgAggregateOutputType = {
    tradingVolume: number | null
    numberOfTrades: number | null
    averageSpread: number | null
    commissionRate: number | null
    grossCommission: number | null
    platformFee: number | null
    netCommission: number | null
  }

  export type IBCommissionSumAggregateOutputType = {
    tradingVolume: number | null
    numberOfTrades: number | null
    averageSpread: number | null
    commissionRate: number | null
    grossCommission: number | null
    platformFee: number | null
    netCommission: number | null
  }

  export type IBCommissionMinAggregateOutputType = {
    id: string | null
    ibPartnerId: string | null
    anonymousAccountId: string | null
    period: Date | null
    periodEnd: Date | null
    tradingVolume: number | null
    numberOfTrades: number | null
    averageSpread: number | null
    commissionRate: number | null
    grossCommission: number | null
    platformFee: number | null
    netCommission: number | null
    isPaid: boolean | null
    paidAt: Date | null
    paymentReference: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IBCommissionMaxAggregateOutputType = {
    id: string | null
    ibPartnerId: string | null
    anonymousAccountId: string | null
    period: Date | null
    periodEnd: Date | null
    tradingVolume: number | null
    numberOfTrades: number | null
    averageSpread: number | null
    commissionRate: number | null
    grossCommission: number | null
    platformFee: number | null
    netCommission: number | null
    isPaid: boolean | null
    paidAt: Date | null
    paymentReference: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IBCommissionCountAggregateOutputType = {
    id: number
    ibPartnerId: number
    anonymousAccountId: number
    period: number
    periodEnd: number
    tradingVolume: number
    numberOfTrades: number
    averageSpread: number
    commissionRate: number
    grossCommission: number
    platformFee: number
    netCommission: number
    isPaid: number
    paidAt: number
    paymentReference: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IBCommissionAvgAggregateInputType = {
    tradingVolume?: true
    numberOfTrades?: true
    averageSpread?: true
    commissionRate?: true
    grossCommission?: true
    platformFee?: true
    netCommission?: true
  }

  export type IBCommissionSumAggregateInputType = {
    tradingVolume?: true
    numberOfTrades?: true
    averageSpread?: true
    commissionRate?: true
    grossCommission?: true
    platformFee?: true
    netCommission?: true
  }

  export type IBCommissionMinAggregateInputType = {
    id?: true
    ibPartnerId?: true
    anonymousAccountId?: true
    period?: true
    periodEnd?: true
    tradingVolume?: true
    numberOfTrades?: true
    averageSpread?: true
    commissionRate?: true
    grossCommission?: true
    platformFee?: true
    netCommission?: true
    isPaid?: true
    paidAt?: true
    paymentReference?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IBCommissionMaxAggregateInputType = {
    id?: true
    ibPartnerId?: true
    anonymousAccountId?: true
    period?: true
    periodEnd?: true
    tradingVolume?: true
    numberOfTrades?: true
    averageSpread?: true
    commissionRate?: true
    grossCommission?: true
    platformFee?: true
    netCommission?: true
    isPaid?: true
    paidAt?: true
    paymentReference?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IBCommissionCountAggregateInputType = {
    id?: true
    ibPartnerId?: true
    anonymousAccountId?: true
    period?: true
    periodEnd?: true
    tradingVolume?: true
    numberOfTrades?: true
    averageSpread?: true
    commissionRate?: true
    grossCommission?: true
    platformFee?: true
    netCommission?: true
    isPaid?: true
    paidAt?: true
    paymentReference?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IBCommissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IBCommission to aggregate.
     */
    where?: IBCommissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IBCommissions to fetch.
     */
    orderBy?: IBCommissionOrderByWithRelationInput | IBCommissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IBCommissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IBCommissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IBCommissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IBCommissions
    **/
    _count?: true | IBCommissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IBCommissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IBCommissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IBCommissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IBCommissionMaxAggregateInputType
  }

  export type GetIBCommissionAggregateType<T extends IBCommissionAggregateArgs> = {
        [P in keyof T & keyof AggregateIBCommission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIBCommission[P]>
      : GetScalarType<T[P], AggregateIBCommission[P]>
  }




  export type IBCommissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IBCommissionWhereInput
    orderBy?: IBCommissionOrderByWithAggregationInput | IBCommissionOrderByWithAggregationInput[]
    by: IBCommissionScalarFieldEnum[] | IBCommissionScalarFieldEnum
    having?: IBCommissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IBCommissionCountAggregateInputType | true
    _avg?: IBCommissionAvgAggregateInputType
    _sum?: IBCommissionSumAggregateInputType
    _min?: IBCommissionMinAggregateInputType
    _max?: IBCommissionMaxAggregateInputType
  }

  export type IBCommissionGroupByOutputType = {
    id: string
    ibPartnerId: string
    anonymousAccountId: string
    period: Date
    periodEnd: Date
    tradingVolume: number
    numberOfTrades: number
    averageSpread: number
    commissionRate: number
    grossCommission: number
    platformFee: number
    netCommission: number
    isPaid: boolean
    paidAt: Date | null
    paymentReference: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: IBCommissionCountAggregateOutputType | null
    _avg: IBCommissionAvgAggregateOutputType | null
    _sum: IBCommissionSumAggregateOutputType | null
    _min: IBCommissionMinAggregateOutputType | null
    _max: IBCommissionMaxAggregateOutputType | null
  }

  type GetIBCommissionGroupByPayload<T extends IBCommissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IBCommissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IBCommissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IBCommissionGroupByOutputType[P]>
            : GetScalarType<T[P], IBCommissionGroupByOutputType[P]>
        }
      >
    >


  export type IBCommissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ibPartnerId?: boolean
    anonymousAccountId?: boolean
    period?: boolean
    periodEnd?: boolean
    tradingVolume?: boolean
    numberOfTrades?: boolean
    averageSpread?: boolean
    commissionRate?: boolean
    grossCommission?: boolean
    platformFee?: boolean
    netCommission?: boolean
    isPaid?: boolean
    paidAt?: boolean
    paymentReference?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ibPartner?: boolean | IBPartnerDefaultArgs<ExtArgs>
    anonymousAccount?: boolean | AnonymousAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["iBCommission"]>

  export type IBCommissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ibPartnerId?: boolean
    anonymousAccountId?: boolean
    period?: boolean
    periodEnd?: boolean
    tradingVolume?: boolean
    numberOfTrades?: boolean
    averageSpread?: boolean
    commissionRate?: boolean
    grossCommission?: boolean
    platformFee?: boolean
    netCommission?: boolean
    isPaid?: boolean
    paidAt?: boolean
    paymentReference?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ibPartner?: boolean | IBPartnerDefaultArgs<ExtArgs>
    anonymousAccount?: boolean | AnonymousAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["iBCommission"]>

  export type IBCommissionSelectScalar = {
    id?: boolean
    ibPartnerId?: boolean
    anonymousAccountId?: boolean
    period?: boolean
    periodEnd?: boolean
    tradingVolume?: boolean
    numberOfTrades?: boolean
    averageSpread?: boolean
    commissionRate?: boolean
    grossCommission?: boolean
    platformFee?: boolean
    netCommission?: boolean
    isPaid?: boolean
    paidAt?: boolean
    paymentReference?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IBCommissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ibPartner?: boolean | IBPartnerDefaultArgs<ExtArgs>
    anonymousAccount?: boolean | AnonymousAccountDefaultArgs<ExtArgs>
  }
  export type IBCommissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ibPartner?: boolean | IBPartnerDefaultArgs<ExtArgs>
    anonymousAccount?: boolean | AnonymousAccountDefaultArgs<ExtArgs>
  }

  export type $IBCommissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IBCommission"
    objects: {
      ibPartner: Prisma.$IBPartnerPayload<ExtArgs>
      anonymousAccount: Prisma.$AnonymousAccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ibPartnerId: string
      anonymousAccountId: string
      period: Date
      periodEnd: Date
      tradingVolume: number
      numberOfTrades: number
      averageSpread: number
      commissionRate: number
      grossCommission: number
      platformFee: number
      netCommission: number
      isPaid: boolean
      paidAt: Date | null
      paymentReference: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["iBCommission"]>
    composites: {}
  }

  type IBCommissionGetPayload<S extends boolean | null | undefined | IBCommissionDefaultArgs> = $Result.GetResult<Prisma.$IBCommissionPayload, S>

  type IBCommissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IBCommissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IBCommissionCountAggregateInputType | true
    }

  export interface IBCommissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IBCommission'], meta: { name: 'IBCommission' } }
    /**
     * Find zero or one IBCommission that matches the filter.
     * @param {IBCommissionFindUniqueArgs} args - Arguments to find a IBCommission
     * @example
     * // Get one IBCommission
     * const iBCommission = await prisma.iBCommission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IBCommissionFindUniqueArgs>(args: SelectSubset<T, IBCommissionFindUniqueArgs<ExtArgs>>): Prisma__IBCommissionClient<$Result.GetResult<Prisma.$IBCommissionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one IBCommission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IBCommissionFindUniqueOrThrowArgs} args - Arguments to find a IBCommission
     * @example
     * // Get one IBCommission
     * const iBCommission = await prisma.iBCommission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IBCommissionFindUniqueOrThrowArgs>(args: SelectSubset<T, IBCommissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IBCommissionClient<$Result.GetResult<Prisma.$IBCommissionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first IBCommission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IBCommissionFindFirstArgs} args - Arguments to find a IBCommission
     * @example
     * // Get one IBCommission
     * const iBCommission = await prisma.iBCommission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IBCommissionFindFirstArgs>(args?: SelectSubset<T, IBCommissionFindFirstArgs<ExtArgs>>): Prisma__IBCommissionClient<$Result.GetResult<Prisma.$IBCommissionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first IBCommission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IBCommissionFindFirstOrThrowArgs} args - Arguments to find a IBCommission
     * @example
     * // Get one IBCommission
     * const iBCommission = await prisma.iBCommission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IBCommissionFindFirstOrThrowArgs>(args?: SelectSubset<T, IBCommissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__IBCommissionClient<$Result.GetResult<Prisma.$IBCommissionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more IBCommissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IBCommissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IBCommissions
     * const iBCommissions = await prisma.iBCommission.findMany()
     * 
     * // Get first 10 IBCommissions
     * const iBCommissions = await prisma.iBCommission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const iBCommissionWithIdOnly = await prisma.iBCommission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IBCommissionFindManyArgs>(args?: SelectSubset<T, IBCommissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IBCommissionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a IBCommission.
     * @param {IBCommissionCreateArgs} args - Arguments to create a IBCommission.
     * @example
     * // Create one IBCommission
     * const IBCommission = await prisma.iBCommission.create({
     *   data: {
     *     // ... data to create a IBCommission
     *   }
     * })
     * 
     */
    create<T extends IBCommissionCreateArgs>(args: SelectSubset<T, IBCommissionCreateArgs<ExtArgs>>): Prisma__IBCommissionClient<$Result.GetResult<Prisma.$IBCommissionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many IBCommissions.
     * @param {IBCommissionCreateManyArgs} args - Arguments to create many IBCommissions.
     * @example
     * // Create many IBCommissions
     * const iBCommission = await prisma.iBCommission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IBCommissionCreateManyArgs>(args?: SelectSubset<T, IBCommissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IBCommissions and returns the data saved in the database.
     * @param {IBCommissionCreateManyAndReturnArgs} args - Arguments to create many IBCommissions.
     * @example
     * // Create many IBCommissions
     * const iBCommission = await prisma.iBCommission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IBCommissions and only return the `id`
     * const iBCommissionWithIdOnly = await prisma.iBCommission.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IBCommissionCreateManyAndReturnArgs>(args?: SelectSubset<T, IBCommissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IBCommissionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a IBCommission.
     * @param {IBCommissionDeleteArgs} args - Arguments to delete one IBCommission.
     * @example
     * // Delete one IBCommission
     * const IBCommission = await prisma.iBCommission.delete({
     *   where: {
     *     // ... filter to delete one IBCommission
     *   }
     * })
     * 
     */
    delete<T extends IBCommissionDeleteArgs>(args: SelectSubset<T, IBCommissionDeleteArgs<ExtArgs>>): Prisma__IBCommissionClient<$Result.GetResult<Prisma.$IBCommissionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one IBCommission.
     * @param {IBCommissionUpdateArgs} args - Arguments to update one IBCommission.
     * @example
     * // Update one IBCommission
     * const iBCommission = await prisma.iBCommission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IBCommissionUpdateArgs>(args: SelectSubset<T, IBCommissionUpdateArgs<ExtArgs>>): Prisma__IBCommissionClient<$Result.GetResult<Prisma.$IBCommissionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more IBCommissions.
     * @param {IBCommissionDeleteManyArgs} args - Arguments to filter IBCommissions to delete.
     * @example
     * // Delete a few IBCommissions
     * const { count } = await prisma.iBCommission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IBCommissionDeleteManyArgs>(args?: SelectSubset<T, IBCommissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IBCommissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IBCommissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IBCommissions
     * const iBCommission = await prisma.iBCommission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IBCommissionUpdateManyArgs>(args: SelectSubset<T, IBCommissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IBCommission.
     * @param {IBCommissionUpsertArgs} args - Arguments to update or create a IBCommission.
     * @example
     * // Update or create a IBCommission
     * const iBCommission = await prisma.iBCommission.upsert({
     *   create: {
     *     // ... data to create a IBCommission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IBCommission we want to update
     *   }
     * })
     */
    upsert<T extends IBCommissionUpsertArgs>(args: SelectSubset<T, IBCommissionUpsertArgs<ExtArgs>>): Prisma__IBCommissionClient<$Result.GetResult<Prisma.$IBCommissionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of IBCommissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IBCommissionCountArgs} args - Arguments to filter IBCommissions to count.
     * @example
     * // Count the number of IBCommissions
     * const count = await prisma.iBCommission.count({
     *   where: {
     *     // ... the filter for the IBCommissions we want to count
     *   }
     * })
    **/
    count<T extends IBCommissionCountArgs>(
      args?: Subset<T, IBCommissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IBCommissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IBCommission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IBCommissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IBCommissionAggregateArgs>(args: Subset<T, IBCommissionAggregateArgs>): Prisma.PrismaPromise<GetIBCommissionAggregateType<T>>

    /**
     * Group by IBCommission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IBCommissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IBCommissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IBCommissionGroupByArgs['orderBy'] }
        : { orderBy?: IBCommissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IBCommissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIBCommissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IBCommission model
   */
  readonly fields: IBCommissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IBCommission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IBCommissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ibPartner<T extends IBPartnerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IBPartnerDefaultArgs<ExtArgs>>): Prisma__IBPartnerClient<$Result.GetResult<Prisma.$IBPartnerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    anonymousAccount<T extends AnonymousAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AnonymousAccountDefaultArgs<ExtArgs>>): Prisma__AnonymousAccountClient<$Result.GetResult<Prisma.$AnonymousAccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IBCommission model
   */ 
  interface IBCommissionFieldRefs {
    readonly id: FieldRef<"IBCommission", 'String'>
    readonly ibPartnerId: FieldRef<"IBCommission", 'String'>
    readonly anonymousAccountId: FieldRef<"IBCommission", 'String'>
    readonly period: FieldRef<"IBCommission", 'DateTime'>
    readonly periodEnd: FieldRef<"IBCommission", 'DateTime'>
    readonly tradingVolume: FieldRef<"IBCommission", 'Float'>
    readonly numberOfTrades: FieldRef<"IBCommission", 'Int'>
    readonly averageSpread: FieldRef<"IBCommission", 'Float'>
    readonly commissionRate: FieldRef<"IBCommission", 'Float'>
    readonly grossCommission: FieldRef<"IBCommission", 'Float'>
    readonly platformFee: FieldRef<"IBCommission", 'Float'>
    readonly netCommission: FieldRef<"IBCommission", 'Float'>
    readonly isPaid: FieldRef<"IBCommission", 'Boolean'>
    readonly paidAt: FieldRef<"IBCommission", 'DateTime'>
    readonly paymentReference: FieldRef<"IBCommission", 'String'>
    readonly notes: FieldRef<"IBCommission", 'String'>
    readonly createdAt: FieldRef<"IBCommission", 'DateTime'>
    readonly updatedAt: FieldRef<"IBCommission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IBCommission findUnique
   */
  export type IBCommissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IBCommission
     */
    select?: IBCommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IBCommissionInclude<ExtArgs> | null
    /**
     * Filter, which IBCommission to fetch.
     */
    where: IBCommissionWhereUniqueInput
  }

  /**
   * IBCommission findUniqueOrThrow
   */
  export type IBCommissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IBCommission
     */
    select?: IBCommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IBCommissionInclude<ExtArgs> | null
    /**
     * Filter, which IBCommission to fetch.
     */
    where: IBCommissionWhereUniqueInput
  }

  /**
   * IBCommission findFirst
   */
  export type IBCommissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IBCommission
     */
    select?: IBCommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IBCommissionInclude<ExtArgs> | null
    /**
     * Filter, which IBCommission to fetch.
     */
    where?: IBCommissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IBCommissions to fetch.
     */
    orderBy?: IBCommissionOrderByWithRelationInput | IBCommissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IBCommissions.
     */
    cursor?: IBCommissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IBCommissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IBCommissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IBCommissions.
     */
    distinct?: IBCommissionScalarFieldEnum | IBCommissionScalarFieldEnum[]
  }

  /**
   * IBCommission findFirstOrThrow
   */
  export type IBCommissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IBCommission
     */
    select?: IBCommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IBCommissionInclude<ExtArgs> | null
    /**
     * Filter, which IBCommission to fetch.
     */
    where?: IBCommissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IBCommissions to fetch.
     */
    orderBy?: IBCommissionOrderByWithRelationInput | IBCommissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IBCommissions.
     */
    cursor?: IBCommissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IBCommissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IBCommissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IBCommissions.
     */
    distinct?: IBCommissionScalarFieldEnum | IBCommissionScalarFieldEnum[]
  }

  /**
   * IBCommission findMany
   */
  export type IBCommissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IBCommission
     */
    select?: IBCommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IBCommissionInclude<ExtArgs> | null
    /**
     * Filter, which IBCommissions to fetch.
     */
    where?: IBCommissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IBCommissions to fetch.
     */
    orderBy?: IBCommissionOrderByWithRelationInput | IBCommissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IBCommissions.
     */
    cursor?: IBCommissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IBCommissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IBCommissions.
     */
    skip?: number
    distinct?: IBCommissionScalarFieldEnum | IBCommissionScalarFieldEnum[]
  }

  /**
   * IBCommission create
   */
  export type IBCommissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IBCommission
     */
    select?: IBCommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IBCommissionInclude<ExtArgs> | null
    /**
     * The data needed to create a IBCommission.
     */
    data: XOR<IBCommissionCreateInput, IBCommissionUncheckedCreateInput>
  }

  /**
   * IBCommission createMany
   */
  export type IBCommissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IBCommissions.
     */
    data: IBCommissionCreateManyInput | IBCommissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IBCommission createManyAndReturn
   */
  export type IBCommissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IBCommission
     */
    select?: IBCommissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many IBCommissions.
     */
    data: IBCommissionCreateManyInput | IBCommissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IBCommissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IBCommission update
   */
  export type IBCommissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IBCommission
     */
    select?: IBCommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IBCommissionInclude<ExtArgs> | null
    /**
     * The data needed to update a IBCommission.
     */
    data: XOR<IBCommissionUpdateInput, IBCommissionUncheckedUpdateInput>
    /**
     * Choose, which IBCommission to update.
     */
    where: IBCommissionWhereUniqueInput
  }

  /**
   * IBCommission updateMany
   */
  export type IBCommissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IBCommissions.
     */
    data: XOR<IBCommissionUpdateManyMutationInput, IBCommissionUncheckedUpdateManyInput>
    /**
     * Filter which IBCommissions to update
     */
    where?: IBCommissionWhereInput
  }

  /**
   * IBCommission upsert
   */
  export type IBCommissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IBCommission
     */
    select?: IBCommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IBCommissionInclude<ExtArgs> | null
    /**
     * The filter to search for the IBCommission to update in case it exists.
     */
    where: IBCommissionWhereUniqueInput
    /**
     * In case the IBCommission found by the `where` argument doesn't exist, create a new IBCommission with this data.
     */
    create: XOR<IBCommissionCreateInput, IBCommissionUncheckedCreateInput>
    /**
     * In case the IBCommission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IBCommissionUpdateInput, IBCommissionUncheckedUpdateInput>
  }

  /**
   * IBCommission delete
   */
  export type IBCommissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IBCommission
     */
    select?: IBCommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IBCommissionInclude<ExtArgs> | null
    /**
     * Filter which IBCommission to delete.
     */
    where: IBCommissionWhereUniqueInput
  }

  /**
   * IBCommission deleteMany
   */
  export type IBCommissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IBCommissions to delete
     */
    where?: IBCommissionWhereInput
  }

  /**
   * IBCommission without action
   */
  export type IBCommissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IBCommission
     */
    select?: IBCommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IBCommissionInclude<ExtArgs> | null
  }


  /**
   * Model IBCommissionRate
   */

  export type AggregateIBCommissionRate = {
    _count: IBCommissionRateCountAggregateOutputType | null
    _avg: IBCommissionRateAvgAggregateOutputType | null
    _sum: IBCommissionRateSumAggregateOutputType | null
    _min: IBCommissionRateMinAggregateOutputType | null
    _max: IBCommissionRateMaxAggregateOutputType | null
  }

  export type IBCommissionRateAvgAggregateOutputType = {
    commissionRate: number | null
    minVolume: number | null
    maxVolume: number | null
  }

  export type IBCommissionRateSumAggregateOutputType = {
    commissionRate: number | null
    minVolume: number | null
    maxVolume: number | null
  }

  export type IBCommissionRateMinAggregateOutputType = {
    id: string | null
    ibPartnerId: string | null
    commissionRate: number | null
    minVolume: number | null
    maxVolume: number | null
    effectiveFrom: Date | null
    effectiveTo: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IBCommissionRateMaxAggregateOutputType = {
    id: string | null
    ibPartnerId: string | null
    commissionRate: number | null
    minVolume: number | null
    maxVolume: number | null
    effectiveFrom: Date | null
    effectiveTo: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IBCommissionRateCountAggregateOutputType = {
    id: number
    ibPartnerId: number
    commissionRate: number
    minVolume: number
    maxVolume: number
    effectiveFrom: number
    effectiveTo: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IBCommissionRateAvgAggregateInputType = {
    commissionRate?: true
    minVolume?: true
    maxVolume?: true
  }

  export type IBCommissionRateSumAggregateInputType = {
    commissionRate?: true
    minVolume?: true
    maxVolume?: true
  }

  export type IBCommissionRateMinAggregateInputType = {
    id?: true
    ibPartnerId?: true
    commissionRate?: true
    minVolume?: true
    maxVolume?: true
    effectiveFrom?: true
    effectiveTo?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IBCommissionRateMaxAggregateInputType = {
    id?: true
    ibPartnerId?: true
    commissionRate?: true
    minVolume?: true
    maxVolume?: true
    effectiveFrom?: true
    effectiveTo?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IBCommissionRateCountAggregateInputType = {
    id?: true
    ibPartnerId?: true
    commissionRate?: true
    minVolume?: true
    maxVolume?: true
    effectiveFrom?: true
    effectiveTo?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IBCommissionRateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IBCommissionRate to aggregate.
     */
    where?: IBCommissionRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IBCommissionRates to fetch.
     */
    orderBy?: IBCommissionRateOrderByWithRelationInput | IBCommissionRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IBCommissionRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IBCommissionRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IBCommissionRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IBCommissionRates
    **/
    _count?: true | IBCommissionRateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IBCommissionRateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IBCommissionRateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IBCommissionRateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IBCommissionRateMaxAggregateInputType
  }

  export type GetIBCommissionRateAggregateType<T extends IBCommissionRateAggregateArgs> = {
        [P in keyof T & keyof AggregateIBCommissionRate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIBCommissionRate[P]>
      : GetScalarType<T[P], AggregateIBCommissionRate[P]>
  }




  export type IBCommissionRateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IBCommissionRateWhereInput
    orderBy?: IBCommissionRateOrderByWithAggregationInput | IBCommissionRateOrderByWithAggregationInput[]
    by: IBCommissionRateScalarFieldEnum[] | IBCommissionRateScalarFieldEnum
    having?: IBCommissionRateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IBCommissionRateCountAggregateInputType | true
    _avg?: IBCommissionRateAvgAggregateInputType
    _sum?: IBCommissionRateSumAggregateInputType
    _min?: IBCommissionRateMinAggregateInputType
    _max?: IBCommissionRateMaxAggregateInputType
  }

  export type IBCommissionRateGroupByOutputType = {
    id: string
    ibPartnerId: string
    commissionRate: number
    minVolume: number
    maxVolume: number | null
    effectiveFrom: Date
    effectiveTo: Date | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: IBCommissionRateCountAggregateOutputType | null
    _avg: IBCommissionRateAvgAggregateOutputType | null
    _sum: IBCommissionRateSumAggregateOutputType | null
    _min: IBCommissionRateMinAggregateOutputType | null
    _max: IBCommissionRateMaxAggregateOutputType | null
  }

  type GetIBCommissionRateGroupByPayload<T extends IBCommissionRateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IBCommissionRateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IBCommissionRateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IBCommissionRateGroupByOutputType[P]>
            : GetScalarType<T[P], IBCommissionRateGroupByOutputType[P]>
        }
      >
    >


  export type IBCommissionRateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ibPartnerId?: boolean
    commissionRate?: boolean
    minVolume?: boolean
    maxVolume?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ibPartner?: boolean | IBPartnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["iBCommissionRate"]>

  export type IBCommissionRateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ibPartnerId?: boolean
    commissionRate?: boolean
    minVolume?: boolean
    maxVolume?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ibPartner?: boolean | IBPartnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["iBCommissionRate"]>

  export type IBCommissionRateSelectScalar = {
    id?: boolean
    ibPartnerId?: boolean
    commissionRate?: boolean
    minVolume?: boolean
    maxVolume?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IBCommissionRateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ibPartner?: boolean | IBPartnerDefaultArgs<ExtArgs>
  }
  export type IBCommissionRateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ibPartner?: boolean | IBPartnerDefaultArgs<ExtArgs>
  }

  export type $IBCommissionRatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IBCommissionRate"
    objects: {
      ibPartner: Prisma.$IBPartnerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ibPartnerId: string
      commissionRate: number
      minVolume: number
      maxVolume: number | null
      effectiveFrom: Date
      effectiveTo: Date | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["iBCommissionRate"]>
    composites: {}
  }

  type IBCommissionRateGetPayload<S extends boolean | null | undefined | IBCommissionRateDefaultArgs> = $Result.GetResult<Prisma.$IBCommissionRatePayload, S>

  type IBCommissionRateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IBCommissionRateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IBCommissionRateCountAggregateInputType | true
    }

  export interface IBCommissionRateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IBCommissionRate'], meta: { name: 'IBCommissionRate' } }
    /**
     * Find zero or one IBCommissionRate that matches the filter.
     * @param {IBCommissionRateFindUniqueArgs} args - Arguments to find a IBCommissionRate
     * @example
     * // Get one IBCommissionRate
     * const iBCommissionRate = await prisma.iBCommissionRate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IBCommissionRateFindUniqueArgs>(args: SelectSubset<T, IBCommissionRateFindUniqueArgs<ExtArgs>>): Prisma__IBCommissionRateClient<$Result.GetResult<Prisma.$IBCommissionRatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one IBCommissionRate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IBCommissionRateFindUniqueOrThrowArgs} args - Arguments to find a IBCommissionRate
     * @example
     * // Get one IBCommissionRate
     * const iBCommissionRate = await prisma.iBCommissionRate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IBCommissionRateFindUniqueOrThrowArgs>(args: SelectSubset<T, IBCommissionRateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IBCommissionRateClient<$Result.GetResult<Prisma.$IBCommissionRatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first IBCommissionRate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IBCommissionRateFindFirstArgs} args - Arguments to find a IBCommissionRate
     * @example
     * // Get one IBCommissionRate
     * const iBCommissionRate = await prisma.iBCommissionRate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IBCommissionRateFindFirstArgs>(args?: SelectSubset<T, IBCommissionRateFindFirstArgs<ExtArgs>>): Prisma__IBCommissionRateClient<$Result.GetResult<Prisma.$IBCommissionRatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first IBCommissionRate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IBCommissionRateFindFirstOrThrowArgs} args - Arguments to find a IBCommissionRate
     * @example
     * // Get one IBCommissionRate
     * const iBCommissionRate = await prisma.iBCommissionRate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IBCommissionRateFindFirstOrThrowArgs>(args?: SelectSubset<T, IBCommissionRateFindFirstOrThrowArgs<ExtArgs>>): Prisma__IBCommissionRateClient<$Result.GetResult<Prisma.$IBCommissionRatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more IBCommissionRates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IBCommissionRateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IBCommissionRates
     * const iBCommissionRates = await prisma.iBCommissionRate.findMany()
     * 
     * // Get first 10 IBCommissionRates
     * const iBCommissionRates = await prisma.iBCommissionRate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const iBCommissionRateWithIdOnly = await prisma.iBCommissionRate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IBCommissionRateFindManyArgs>(args?: SelectSubset<T, IBCommissionRateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IBCommissionRatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a IBCommissionRate.
     * @param {IBCommissionRateCreateArgs} args - Arguments to create a IBCommissionRate.
     * @example
     * // Create one IBCommissionRate
     * const IBCommissionRate = await prisma.iBCommissionRate.create({
     *   data: {
     *     // ... data to create a IBCommissionRate
     *   }
     * })
     * 
     */
    create<T extends IBCommissionRateCreateArgs>(args: SelectSubset<T, IBCommissionRateCreateArgs<ExtArgs>>): Prisma__IBCommissionRateClient<$Result.GetResult<Prisma.$IBCommissionRatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many IBCommissionRates.
     * @param {IBCommissionRateCreateManyArgs} args - Arguments to create many IBCommissionRates.
     * @example
     * // Create many IBCommissionRates
     * const iBCommissionRate = await prisma.iBCommissionRate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IBCommissionRateCreateManyArgs>(args?: SelectSubset<T, IBCommissionRateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IBCommissionRates and returns the data saved in the database.
     * @param {IBCommissionRateCreateManyAndReturnArgs} args - Arguments to create many IBCommissionRates.
     * @example
     * // Create many IBCommissionRates
     * const iBCommissionRate = await prisma.iBCommissionRate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IBCommissionRates and only return the `id`
     * const iBCommissionRateWithIdOnly = await prisma.iBCommissionRate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IBCommissionRateCreateManyAndReturnArgs>(args?: SelectSubset<T, IBCommissionRateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IBCommissionRatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a IBCommissionRate.
     * @param {IBCommissionRateDeleteArgs} args - Arguments to delete one IBCommissionRate.
     * @example
     * // Delete one IBCommissionRate
     * const IBCommissionRate = await prisma.iBCommissionRate.delete({
     *   where: {
     *     // ... filter to delete one IBCommissionRate
     *   }
     * })
     * 
     */
    delete<T extends IBCommissionRateDeleteArgs>(args: SelectSubset<T, IBCommissionRateDeleteArgs<ExtArgs>>): Prisma__IBCommissionRateClient<$Result.GetResult<Prisma.$IBCommissionRatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one IBCommissionRate.
     * @param {IBCommissionRateUpdateArgs} args - Arguments to update one IBCommissionRate.
     * @example
     * // Update one IBCommissionRate
     * const iBCommissionRate = await prisma.iBCommissionRate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IBCommissionRateUpdateArgs>(args: SelectSubset<T, IBCommissionRateUpdateArgs<ExtArgs>>): Prisma__IBCommissionRateClient<$Result.GetResult<Prisma.$IBCommissionRatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more IBCommissionRates.
     * @param {IBCommissionRateDeleteManyArgs} args - Arguments to filter IBCommissionRates to delete.
     * @example
     * // Delete a few IBCommissionRates
     * const { count } = await prisma.iBCommissionRate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IBCommissionRateDeleteManyArgs>(args?: SelectSubset<T, IBCommissionRateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IBCommissionRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IBCommissionRateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IBCommissionRates
     * const iBCommissionRate = await prisma.iBCommissionRate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IBCommissionRateUpdateManyArgs>(args: SelectSubset<T, IBCommissionRateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IBCommissionRate.
     * @param {IBCommissionRateUpsertArgs} args - Arguments to update or create a IBCommissionRate.
     * @example
     * // Update or create a IBCommissionRate
     * const iBCommissionRate = await prisma.iBCommissionRate.upsert({
     *   create: {
     *     // ... data to create a IBCommissionRate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IBCommissionRate we want to update
     *   }
     * })
     */
    upsert<T extends IBCommissionRateUpsertArgs>(args: SelectSubset<T, IBCommissionRateUpsertArgs<ExtArgs>>): Prisma__IBCommissionRateClient<$Result.GetResult<Prisma.$IBCommissionRatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of IBCommissionRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IBCommissionRateCountArgs} args - Arguments to filter IBCommissionRates to count.
     * @example
     * // Count the number of IBCommissionRates
     * const count = await prisma.iBCommissionRate.count({
     *   where: {
     *     // ... the filter for the IBCommissionRates we want to count
     *   }
     * })
    **/
    count<T extends IBCommissionRateCountArgs>(
      args?: Subset<T, IBCommissionRateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IBCommissionRateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IBCommissionRate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IBCommissionRateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IBCommissionRateAggregateArgs>(args: Subset<T, IBCommissionRateAggregateArgs>): Prisma.PrismaPromise<GetIBCommissionRateAggregateType<T>>

    /**
     * Group by IBCommissionRate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IBCommissionRateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IBCommissionRateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IBCommissionRateGroupByArgs['orderBy'] }
        : { orderBy?: IBCommissionRateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IBCommissionRateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIBCommissionRateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IBCommissionRate model
   */
  readonly fields: IBCommissionRateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IBCommissionRate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IBCommissionRateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ibPartner<T extends IBPartnerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IBPartnerDefaultArgs<ExtArgs>>): Prisma__IBPartnerClient<$Result.GetResult<Prisma.$IBPartnerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IBCommissionRate model
   */ 
  interface IBCommissionRateFieldRefs {
    readonly id: FieldRef<"IBCommissionRate", 'String'>
    readonly ibPartnerId: FieldRef<"IBCommissionRate", 'String'>
    readonly commissionRate: FieldRef<"IBCommissionRate", 'Float'>
    readonly minVolume: FieldRef<"IBCommissionRate", 'Float'>
    readonly maxVolume: FieldRef<"IBCommissionRate", 'Float'>
    readonly effectiveFrom: FieldRef<"IBCommissionRate", 'DateTime'>
    readonly effectiveTo: FieldRef<"IBCommissionRate", 'DateTime'>
    readonly isActive: FieldRef<"IBCommissionRate", 'Boolean'>
    readonly createdAt: FieldRef<"IBCommissionRate", 'DateTime'>
    readonly updatedAt: FieldRef<"IBCommissionRate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IBCommissionRate findUnique
   */
  export type IBCommissionRateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IBCommissionRate
     */
    select?: IBCommissionRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IBCommissionRateInclude<ExtArgs> | null
    /**
     * Filter, which IBCommissionRate to fetch.
     */
    where: IBCommissionRateWhereUniqueInput
  }

  /**
   * IBCommissionRate findUniqueOrThrow
   */
  export type IBCommissionRateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IBCommissionRate
     */
    select?: IBCommissionRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IBCommissionRateInclude<ExtArgs> | null
    /**
     * Filter, which IBCommissionRate to fetch.
     */
    where: IBCommissionRateWhereUniqueInput
  }

  /**
   * IBCommissionRate findFirst
   */
  export type IBCommissionRateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IBCommissionRate
     */
    select?: IBCommissionRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IBCommissionRateInclude<ExtArgs> | null
    /**
     * Filter, which IBCommissionRate to fetch.
     */
    where?: IBCommissionRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IBCommissionRates to fetch.
     */
    orderBy?: IBCommissionRateOrderByWithRelationInput | IBCommissionRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IBCommissionRates.
     */
    cursor?: IBCommissionRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IBCommissionRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IBCommissionRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IBCommissionRates.
     */
    distinct?: IBCommissionRateScalarFieldEnum | IBCommissionRateScalarFieldEnum[]
  }

  /**
   * IBCommissionRate findFirstOrThrow
   */
  export type IBCommissionRateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IBCommissionRate
     */
    select?: IBCommissionRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IBCommissionRateInclude<ExtArgs> | null
    /**
     * Filter, which IBCommissionRate to fetch.
     */
    where?: IBCommissionRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IBCommissionRates to fetch.
     */
    orderBy?: IBCommissionRateOrderByWithRelationInput | IBCommissionRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IBCommissionRates.
     */
    cursor?: IBCommissionRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IBCommissionRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IBCommissionRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IBCommissionRates.
     */
    distinct?: IBCommissionRateScalarFieldEnum | IBCommissionRateScalarFieldEnum[]
  }

  /**
   * IBCommissionRate findMany
   */
  export type IBCommissionRateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IBCommissionRate
     */
    select?: IBCommissionRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IBCommissionRateInclude<ExtArgs> | null
    /**
     * Filter, which IBCommissionRates to fetch.
     */
    where?: IBCommissionRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IBCommissionRates to fetch.
     */
    orderBy?: IBCommissionRateOrderByWithRelationInput | IBCommissionRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IBCommissionRates.
     */
    cursor?: IBCommissionRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IBCommissionRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IBCommissionRates.
     */
    skip?: number
    distinct?: IBCommissionRateScalarFieldEnum | IBCommissionRateScalarFieldEnum[]
  }

  /**
   * IBCommissionRate create
   */
  export type IBCommissionRateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IBCommissionRate
     */
    select?: IBCommissionRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IBCommissionRateInclude<ExtArgs> | null
    /**
     * The data needed to create a IBCommissionRate.
     */
    data: XOR<IBCommissionRateCreateInput, IBCommissionRateUncheckedCreateInput>
  }

  /**
   * IBCommissionRate createMany
   */
  export type IBCommissionRateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IBCommissionRates.
     */
    data: IBCommissionRateCreateManyInput | IBCommissionRateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IBCommissionRate createManyAndReturn
   */
  export type IBCommissionRateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IBCommissionRate
     */
    select?: IBCommissionRateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many IBCommissionRates.
     */
    data: IBCommissionRateCreateManyInput | IBCommissionRateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IBCommissionRateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IBCommissionRate update
   */
  export type IBCommissionRateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IBCommissionRate
     */
    select?: IBCommissionRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IBCommissionRateInclude<ExtArgs> | null
    /**
     * The data needed to update a IBCommissionRate.
     */
    data: XOR<IBCommissionRateUpdateInput, IBCommissionRateUncheckedUpdateInput>
    /**
     * Choose, which IBCommissionRate to update.
     */
    where: IBCommissionRateWhereUniqueInput
  }

  /**
   * IBCommissionRate updateMany
   */
  export type IBCommissionRateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IBCommissionRates.
     */
    data: XOR<IBCommissionRateUpdateManyMutationInput, IBCommissionRateUncheckedUpdateManyInput>
    /**
     * Filter which IBCommissionRates to update
     */
    where?: IBCommissionRateWhereInput
  }

  /**
   * IBCommissionRate upsert
   */
  export type IBCommissionRateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IBCommissionRate
     */
    select?: IBCommissionRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IBCommissionRateInclude<ExtArgs> | null
    /**
     * The filter to search for the IBCommissionRate to update in case it exists.
     */
    where: IBCommissionRateWhereUniqueInput
    /**
     * In case the IBCommissionRate found by the `where` argument doesn't exist, create a new IBCommissionRate with this data.
     */
    create: XOR<IBCommissionRateCreateInput, IBCommissionRateUncheckedCreateInput>
    /**
     * In case the IBCommissionRate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IBCommissionRateUpdateInput, IBCommissionRateUncheckedUpdateInput>
  }

  /**
   * IBCommissionRate delete
   */
  export type IBCommissionRateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IBCommissionRate
     */
    select?: IBCommissionRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IBCommissionRateInclude<ExtArgs> | null
    /**
     * Filter which IBCommissionRate to delete.
     */
    where: IBCommissionRateWhereUniqueInput
  }

  /**
   * IBCommissionRate deleteMany
   */
  export type IBCommissionRateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IBCommissionRates to delete
     */
    where?: IBCommissionRateWhereInput
  }

  /**
   * IBCommissionRate without action
   */
  export type IBCommissionRateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IBCommissionRate
     */
    select?: IBCommissionRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IBCommissionRateInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    firstName: 'firstName',
    lastName: 'lastName',
    role: 'role',
    phone: 'phone',
    ibCode: 'ibCode',
    ibPartnerId: 'ibPartnerId',
    subscriptionTier: 'subscriptionTier',
    subscriptionStart: 'subscriptionStart',
    subscriptionEnd: 'subscriptionEnd',
    monthlyFee: 'monthlyFee',
    totalTrades: 'totalTrades',
    winningTrades: 'winningTrades',
    losingTrades: 'losingTrades',
    totalProfit: 'totalProfit',
    totalVolume: 'totalVolume',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastLoginAt: 'lastLoginAt',
    lastActiveAt: 'lastActiveAt',
    isActive: 'isActive',
    status: 'status',
    emailVerified: 'emailVerified',
    verificationCode: 'verificationCode',
    verificationExpiry: 'verificationExpiry'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const MT5AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    accountNumber: 'accountNumber',
    broker: 'broker',
    serverName: 'serverName',
    login: 'login',
    password: 'password',
    vpsIp: 'vpsIp',
    vpsPort: 'vpsPort',
    status: 'status',
    balance: 'balance',
    equity: 'equity',
    margin: 'margin',
    freeMargin: 'freeMargin',
    isEnabledForTrading: 'isEnabledForTrading',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastSyncAt: 'lastSyncAt'
  };

  export type MT5AccountScalarFieldEnum = (typeof MT5AccountScalarFieldEnum)[keyof typeof MT5AccountScalarFieldEnum]


  export const EAScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    mt5AccountId: 'mt5AccountId',
    name: 'name',
    version: 'version',
    magicNumber: 'magicNumber',
    status: 'status',
    safetyIndicator: 'safetyIndicator',
    indicatorScore: 'indicatorScore',
    stoppedByIndicator: 'stoppedByIndicator',
    stoppedByIndicatorAt: 'stoppedByIndicatorAt',
    maxLotSize: 'maxLotSize',
    riskPercent: 'riskPercent',
    settings: 'settings',
    lastStartAt: 'lastStartAt',
    lastStopAt: 'lastStopAt',
    uptime: 'uptime',
    totalTrades: 'totalTrades',
    winningTrades: 'winningTrades',
    totalProfit: 'totalProfit',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EAScalarFieldEnum = (typeof EAScalarFieldEnum)[keyof typeof EAScalarFieldEnum]


  export const TradeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    mt5AccountId: 'mt5AccountId',
    ticket: 'ticket',
    symbol: 'symbol',
    type: 'type',
    volume: 'volume',
    openPrice: 'openPrice',
    openTime: 'openTime',
    closePrice: 'closePrice',
    closeTime: 'closeTime',
    profit: 'profit',
    commission: 'commission',
    swap: 'swap',
    magicNumber: 'magicNumber',
    comment: 'comment',
    isClosed: 'isClosed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TradeScalarFieldEnum = (typeof TradeScalarFieldEnum)[keyof typeof TradeScalarFieldEnum]


  export const AutomationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    userId: 'userId',
    triggerType: 'triggerType',
    triggerValue: 'triggerValue',
    triggerData: 'triggerData',
    actionTypes: 'actionTypes',
    actionData: 'actionData',
    messageSubject: 'messageSubject',
    messageBody: 'messageBody',
    status: 'status',
    priority: 'priority',
    isUserEnabled: 'isUserEnabled',
    totalTriggered: 'totalTriggered',
    totalSent: 'totalSent',
    totalFailed: 'totalFailed',
    lastTriggered: 'lastTriggered',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy'
  };

  export type AutomationScalarFieldEnum = (typeof AutomationScalarFieldEnum)[keyof typeof AutomationScalarFieldEnum]


  export const NotificationLogScalarFieldEnum: {
    id: 'id',
    automationId: 'automationId',
    userId: 'userId',
    channel: 'channel',
    recipient: 'recipient',
    subject: 'subject',
    message: 'message',
    status: 'status',
    sentAt: 'sentAt',
    deliveredAt: 'deliveredAt',
    failedAt: 'failedAt',
    errorMessage: 'errorMessage',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type NotificationLogScalarFieldEnum = (typeof NotificationLogScalarFieldEnum)[keyof typeof NotificationLogScalarFieldEnum]


  export const UserInsightScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    winRate: 'winRate',
    avgProfitPerTrade: 'avgProfitPerTrade',
    avgLossPerTrade: 'avgLossPerTrade',
    profitFactor: 'profitFactor',
    maxDrawdown: 'maxDrawdown',
    sharpeRatio: 'sharpeRatio',
    tradingDaysActive: 'tradingDaysActive',
    avgTradesPerDay: 'avgTradesPerDay',
    preferredTimeframe: 'preferredTimeframe',
    riskLevel: 'riskLevel',
    lastTradeDate: 'lastTradeDate',
    consecutiveWins: 'consecutiveWins',
    consecutiveLosses: 'consecutiveLosses',
    daysSinceLastTrade: 'daysSinceLastTrade',
    lifetimeValue: 'lifetimeValue',
    totalRevenue: 'totalRevenue',
    churnRisk: 'churnRisk',
    engagementScore: 'engagementScore',
    predictedNextAction: 'predictedNextAction',
    retentionProbability: 'retentionProbability',
    upsellProbability: 'upsellProbability',
    updatedAt: 'updatedAt'
  };

  export type UserInsightScalarFieldEnum = (typeof UserInsightScalarFieldEnum)[keyof typeof UserInsightScalarFieldEnum]


  export const SystemLogScalarFieldEnum: {
    id: 'id',
    level: 'level',
    component: 'component',
    message: 'message',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type SystemLogScalarFieldEnum = (typeof SystemLogScalarFieldEnum)[keyof typeof SystemLogScalarFieldEnum]


  export const MarketConditionScalarFieldEnum: {
    id: 'id',
    volatility: 'volatility',
    spread: 'spread',
    trend: 'trend',
    newsImpact: 'newsImpact',
    safetyIndicator: 'safetyIndicator',
    reason: 'reason',
    timestamp: 'timestamp'
  };

  export type MarketConditionScalarFieldEnum = (typeof MarketConditionScalarFieldEnum)[keyof typeof MarketConditionScalarFieldEnum]


  export const LeaderboardEntryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    period: 'period',
    periodDate: 'periodDate',
    trades: 'trades',
    winningTrades: 'winningTrades',
    losingTrades: 'losingTrades',
    profit: 'profit',
    volume: 'volume',
    winRate: 'winRate',
    rank: 'rank',
    previousRank: 'previousRank',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LeaderboardEntryScalarFieldEnum = (typeof LeaderboardEntryScalarFieldEnum)[keyof typeof LeaderboardEntryScalarFieldEnum]


  export const IBPartnerScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    companyName: 'companyName',
    contactName: 'contactName',
    phone: 'phone',
    ibCode: 'ibCode',
    domain: 'domain',
    logo: 'logo',
    favicon: 'favicon',
    brandColor: 'brandColor',
    brandName: 'brandName',
    isActive: 'isActive',
    isApproved: 'isApproved',
    currentTraders: 'currentTraders',
    message: 'message',
    companyDocument: 'companyDocument',
    idDocument: 'idDocument',
    kycDocument: 'kycDocument',
    kycStatus: 'kycStatus',
    emailVerified: 'emailVerified',
    verificationCode: 'verificationCode',
    verificationExpiry: 'verificationExpiry',
    pricingTier: 'pricingTier',
    monthlyFee: 'monthlyFee',
    traderLimit: 'traderLimit',
    spreadRevShare: 'spreadRevShare',
    totalTraders: 'totalTraders',
    activeTraders: 'activeTraders',
    monthlyRevenue: 'monthlyRevenue',
    lifetimeRevenue: 'lifetimeRevenue',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    approvedAt: 'approvedAt',
    approvedBy: 'approvedBy'
  };

  export type IBPartnerScalarFieldEnum = (typeof IBPartnerScalarFieldEnum)[keyof typeof IBPartnerScalarFieldEnum]


  export const AgentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    machineId: 'machineId',
    machineName: 'machineName',
    isPoolAgent: 'isPoolAgent',
    managedAccounts: 'managedAccounts',
    maxCapacity: 'maxCapacity',
    currentLoad: 'currentLoad',
    vpsName: 'vpsName',
    vpsRegion: 'vpsRegion',
    vpsIp: 'vpsIp',
    mt5AccountNumber: 'mt5AccountNumber',
    mt5Broker: 'mt5Broker',
    mt5ServerName: 'mt5ServerName',
    mt5Version: 'mt5Version',
    status: 'status',
    lastHeartbeat: 'lastHeartbeat',
    connectedAt: 'connectedAt',
    disconnectedAt: 'disconnectedAt',
    eaLoaded: 'eaLoaded',
    eaRunning: 'eaRunning',
    eaName: 'eaName',
    chartSymbol: 'chartSymbol',
    chartTimeframe: 'chartTimeframe',
    tradeCopierActive: 'tradeCopierActive',
    isMasterAccount: 'isMasterAccount',
    masterAgentId: 'masterAgentId',
    totalTrades: 'totalTrades',
    profitableTrades: 'profitableTrades',
    losingTrades: 'losingTrades',
    totalProfit: 'totalProfit',
    winRate: 'winRate',
    indicatorSettings: 'indicatorSettings',
    aiOptimizationScore: 'aiOptimizationScore',
    lastOptimizedAt: 'lastOptimizedAt',
    apiKey: 'apiKey',
    osVersion: 'osVersion',
    agentVersion: 'agentVersion',
    cpuUsage: 'cpuUsage',
    memoryUsage: 'memoryUsage',
    diskUsage: 'diskUsage',
    mt5InstanceCount: 'mt5InstanceCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AgentScalarFieldEnum = (typeof AgentScalarFieldEnum)[keyof typeof AgentScalarFieldEnum]


  export const MT5AccountAssignmentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    agentId: 'agentId',
    mt5AccountNumber: 'mt5AccountNumber',
    mt5Broker: 'mt5Broker',
    mt5ServerName: 'mt5ServerName',
    assignedAt: 'assignedAt',
    isActive: 'isActive',
    status: 'status',
    eaStatus: 'eaStatus',
    lastHeartbeat: 'lastHeartbeat',
    balance: 'balance',
    equity: 'equity',
    margin: 'margin',
    freeMargin: 'freeMargin',
    profit: 'profit',
    eaLoaded: 'eaLoaded',
    eaRunning: 'eaRunning',
    eaName: 'eaName',
    chartSymbol: 'chartSymbol',
    chartTimeframe: 'chartTimeframe',
    totalTrades: 'totalTrades',
    profitableTrades: 'profitableTrades',
    losingTrades: 'losingTrades',
    totalProfit: 'totalProfit',
    winRate: 'winRate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MT5AccountAssignmentScalarFieldEnum = (typeof MT5AccountAssignmentScalarFieldEnum)[keyof typeof MT5AccountAssignmentScalarFieldEnum]


  export const PrizeScalarFieldEnum: {
    id: 'id',
    period: 'period',
    rank: 'rank',
    amount: 'amount',
    isActive: 'isActive',
    updatedBy: 'updatedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PrizeScalarFieldEnum = (typeof PrizeScalarFieldEnum)[keyof typeof PrizeScalarFieldEnum]


  export const GlobalSettingsScalarFieldEnum: {
    id: 'id',
    settingKey: 'settingKey',
    settingValue: 'settingValue',
    description: 'description',
    updatedBy: 'updatedBy',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type GlobalSettingsScalarFieldEnum = (typeof GlobalSettingsScalarFieldEnum)[keyof typeof GlobalSettingsScalarFieldEnum]


  export const AnonymousAccountScalarFieldEnum: {
    id: 'id',
    anonymousId: 'anonymousId',
    userId: 'userId',
    mt5AccountNumber: 'mt5AccountNumber',
    ibPartnerId: 'ibPartnerId',
    isActive: 'isActive',
    registeredAt: 'registeredAt'
  };

  export type AnonymousAccountScalarFieldEnum = (typeof AnonymousAccountScalarFieldEnum)[keyof typeof AnonymousAccountScalarFieldEnum]


  export const IBCommissionScalarFieldEnum: {
    id: 'id',
    ibPartnerId: 'ibPartnerId',
    anonymousAccountId: 'anonymousAccountId',
    period: 'period',
    periodEnd: 'periodEnd',
    tradingVolume: 'tradingVolume',
    numberOfTrades: 'numberOfTrades',
    averageSpread: 'averageSpread',
    commissionRate: 'commissionRate',
    grossCommission: 'grossCommission',
    platformFee: 'platformFee',
    netCommission: 'netCommission',
    isPaid: 'isPaid',
    paidAt: 'paidAt',
    paymentReference: 'paymentReference',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IBCommissionScalarFieldEnum = (typeof IBCommissionScalarFieldEnum)[keyof typeof IBCommissionScalarFieldEnum]


  export const IBCommissionRateScalarFieldEnum: {
    id: 'id',
    ibPartnerId: 'ibPartnerId',
    commissionRate: 'commissionRate',
    minVolume: 'minVolume',
    maxVolume: 'maxVolume',
    effectiveFrom: 'effectiveFrom',
    effectiveTo: 'effectiveTo',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IBCommissionRateScalarFieldEnum = (typeof IBCommissionRateScalarFieldEnum)[keyof typeof IBCommissionRateScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'SubscriptionTier'
   */
  export type EnumSubscriptionTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionTier'>
    


  /**
   * Reference to a field of type 'SubscriptionTier[]'
   */
  export type ListEnumSubscriptionTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionTier[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'AccountStatus'
   */
  export type EnumAccountStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountStatus'>
    


  /**
   * Reference to a field of type 'AccountStatus[]'
   */
  export type ListEnumAccountStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountStatus[]'>
    


  /**
   * Reference to a field of type 'EAStatus'
   */
  export type EnumEAStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EAStatus'>
    


  /**
   * Reference to a field of type 'EAStatus[]'
   */
  export type ListEnumEAStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EAStatus[]'>
    


  /**
   * Reference to a field of type 'SafetyIndicator'
   */
  export type EnumSafetyIndicatorFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SafetyIndicator'>
    


  /**
   * Reference to a field of type 'SafetyIndicator[]'
   */
  export type ListEnumSafetyIndicatorFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SafetyIndicator[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'AutomationTriggerType'
   */
  export type EnumAutomationTriggerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AutomationTriggerType'>
    


  /**
   * Reference to a field of type 'AutomationTriggerType[]'
   */
  export type ListEnumAutomationTriggerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AutomationTriggerType[]'>
    


  /**
   * Reference to a field of type 'AutomationActionType[]'
   */
  export type ListEnumAutomationActionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AutomationActionType[]'>
    


  /**
   * Reference to a field of type 'AutomationActionType'
   */
  export type EnumAutomationActionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AutomationActionType'>
    


  /**
   * Reference to a field of type 'AutomationStatus'
   */
  export type EnumAutomationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AutomationStatus'>
    


  /**
   * Reference to a field of type 'AutomationStatus[]'
   */
  export type ListEnumAutomationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AutomationStatus[]'>
    


  /**
   * Reference to a field of type 'NotificationStatus'
   */
  export type EnumNotificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationStatus'>
    


  /**
   * Reference to a field of type 'NotificationStatus[]'
   */
  export type ListEnumNotificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    phone?: StringNullableFilter<"User"> | string | null
    ibCode?: StringNullableFilter<"User"> | string | null
    ibPartnerId?: StringNullableFilter<"User"> | string | null
    subscriptionTier?: EnumSubscriptionTierFilter<"User"> | $Enums.SubscriptionTier
    subscriptionStart?: DateTimeNullableFilter<"User"> | Date | string | null
    subscriptionEnd?: DateTimeNullableFilter<"User"> | Date | string | null
    monthlyFee?: FloatFilter<"User"> | number
    totalTrades?: IntFilter<"User"> | number
    winningTrades?: IntFilter<"User"> | number
    losingTrades?: IntFilter<"User"> | number
    totalProfit?: FloatFilter<"User"> | number
    totalVolume?: FloatFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    lastActiveAt?: DateTimeNullableFilter<"User"> | Date | string | null
    isActive?: BoolFilter<"User"> | boolean
    status?: EnumAccountStatusFilter<"User"> | $Enums.AccountStatus
    emailVerified?: BoolFilter<"User"> | boolean
    verificationCode?: StringNullableFilter<"User"> | string | null
    verificationExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    ibPartner?: XOR<IBPartnerNullableRelationFilter, IBPartnerWhereInput> | null
    mt5Accounts?: MT5AccountListRelationFilter
    eas?: EAListRelationFilter
    trades?: TradeListRelationFilter
    notifications?: NotificationLogListRelationFilter
    insights?: XOR<UserInsightNullableRelationFilter, UserInsightWhereInput> | null
    automations?: AutomationListRelationFilter
    leaderboardStats?: LeaderboardEntryListRelationFilter
    agents?: AgentListRelationFilter
    accountAssignments?: MT5AccountAssignmentListRelationFilter
    anonymousAccounts?: AnonymousAccountListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    phone?: SortOrderInput | SortOrder
    ibCode?: SortOrderInput | SortOrder
    ibPartnerId?: SortOrderInput | SortOrder
    subscriptionTier?: SortOrder
    subscriptionStart?: SortOrderInput | SortOrder
    subscriptionEnd?: SortOrderInput | SortOrder
    monthlyFee?: SortOrder
    totalTrades?: SortOrder
    winningTrades?: SortOrder
    losingTrades?: SortOrder
    totalProfit?: SortOrder
    totalVolume?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    lastActiveAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    status?: SortOrder
    emailVerified?: SortOrder
    verificationCode?: SortOrderInput | SortOrder
    verificationExpiry?: SortOrderInput | SortOrder
    ibPartner?: IBPartnerOrderByWithRelationInput
    mt5Accounts?: MT5AccountOrderByRelationAggregateInput
    eas?: EAOrderByRelationAggregateInput
    trades?: TradeOrderByRelationAggregateInput
    notifications?: NotificationLogOrderByRelationAggregateInput
    insights?: UserInsightOrderByWithRelationInput
    automations?: AutomationOrderByRelationAggregateInput
    leaderboardStats?: LeaderboardEntryOrderByRelationAggregateInput
    agents?: AgentOrderByRelationAggregateInput
    accountAssignments?: MT5AccountAssignmentOrderByRelationAggregateInput
    anonymousAccounts?: AnonymousAccountOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    phone?: StringNullableFilter<"User"> | string | null
    ibCode?: StringNullableFilter<"User"> | string | null
    ibPartnerId?: StringNullableFilter<"User"> | string | null
    subscriptionTier?: EnumSubscriptionTierFilter<"User"> | $Enums.SubscriptionTier
    subscriptionStart?: DateTimeNullableFilter<"User"> | Date | string | null
    subscriptionEnd?: DateTimeNullableFilter<"User"> | Date | string | null
    monthlyFee?: FloatFilter<"User"> | number
    totalTrades?: IntFilter<"User"> | number
    winningTrades?: IntFilter<"User"> | number
    losingTrades?: IntFilter<"User"> | number
    totalProfit?: FloatFilter<"User"> | number
    totalVolume?: FloatFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    lastActiveAt?: DateTimeNullableFilter<"User"> | Date | string | null
    isActive?: BoolFilter<"User"> | boolean
    status?: EnumAccountStatusFilter<"User"> | $Enums.AccountStatus
    emailVerified?: BoolFilter<"User"> | boolean
    verificationCode?: StringNullableFilter<"User"> | string | null
    verificationExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    ibPartner?: XOR<IBPartnerNullableRelationFilter, IBPartnerWhereInput> | null
    mt5Accounts?: MT5AccountListRelationFilter
    eas?: EAListRelationFilter
    trades?: TradeListRelationFilter
    notifications?: NotificationLogListRelationFilter
    insights?: XOR<UserInsightNullableRelationFilter, UserInsightWhereInput> | null
    automations?: AutomationListRelationFilter
    leaderboardStats?: LeaderboardEntryListRelationFilter
    agents?: AgentListRelationFilter
    accountAssignments?: MT5AccountAssignmentListRelationFilter
    anonymousAccounts?: AnonymousAccountListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    phone?: SortOrderInput | SortOrder
    ibCode?: SortOrderInput | SortOrder
    ibPartnerId?: SortOrderInput | SortOrder
    subscriptionTier?: SortOrder
    subscriptionStart?: SortOrderInput | SortOrder
    subscriptionEnd?: SortOrderInput | SortOrder
    monthlyFee?: SortOrder
    totalTrades?: SortOrder
    winningTrades?: SortOrder
    losingTrades?: SortOrder
    totalProfit?: SortOrder
    totalVolume?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    lastActiveAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    status?: SortOrder
    emailVerified?: SortOrder
    verificationCode?: SortOrderInput | SortOrder
    verificationExpiry?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    ibCode?: StringNullableWithAggregatesFilter<"User"> | string | null
    ibPartnerId?: StringNullableWithAggregatesFilter<"User"> | string | null
    subscriptionTier?: EnumSubscriptionTierWithAggregatesFilter<"User"> | $Enums.SubscriptionTier
    subscriptionStart?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    subscriptionEnd?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    monthlyFee?: FloatWithAggregatesFilter<"User"> | number
    totalTrades?: IntWithAggregatesFilter<"User"> | number
    winningTrades?: IntWithAggregatesFilter<"User"> | number
    losingTrades?: IntWithAggregatesFilter<"User"> | number
    totalProfit?: FloatWithAggregatesFilter<"User"> | number
    totalVolume?: FloatWithAggregatesFilter<"User"> | number
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    lastActiveAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    status?: EnumAccountStatusWithAggregatesFilter<"User"> | $Enums.AccountStatus
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    verificationCode?: StringNullableWithAggregatesFilter<"User"> | string | null
    verificationExpiry?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type MT5AccountWhereInput = {
    AND?: MT5AccountWhereInput | MT5AccountWhereInput[]
    OR?: MT5AccountWhereInput[]
    NOT?: MT5AccountWhereInput | MT5AccountWhereInput[]
    id?: StringFilter<"MT5Account"> | string
    userId?: StringFilter<"MT5Account"> | string
    accountNumber?: StringFilter<"MT5Account"> | string
    broker?: StringFilter<"MT5Account"> | string
    serverName?: StringFilter<"MT5Account"> | string
    login?: StringFilter<"MT5Account"> | string
    password?: StringNullableFilter<"MT5Account"> | string | null
    vpsIp?: StringNullableFilter<"MT5Account"> | string | null
    vpsPort?: IntNullableFilter<"MT5Account"> | number | null
    status?: EnumAccountStatusFilter<"MT5Account"> | $Enums.AccountStatus
    balance?: FloatFilter<"MT5Account"> | number
    equity?: FloatFilter<"MT5Account"> | number
    margin?: FloatFilter<"MT5Account"> | number
    freeMargin?: FloatFilter<"MT5Account"> | number
    isEnabledForTrading?: BoolFilter<"MT5Account"> | boolean
    createdAt?: DateTimeFilter<"MT5Account"> | Date | string
    updatedAt?: DateTimeFilter<"MT5Account"> | Date | string
    lastSyncAt?: DateTimeNullableFilter<"MT5Account"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    eas?: EAListRelationFilter
    trades?: TradeListRelationFilter
  }

  export type MT5AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    accountNumber?: SortOrder
    broker?: SortOrder
    serverName?: SortOrder
    login?: SortOrder
    password?: SortOrderInput | SortOrder
    vpsIp?: SortOrderInput | SortOrder
    vpsPort?: SortOrderInput | SortOrder
    status?: SortOrder
    balance?: SortOrder
    equity?: SortOrder
    margin?: SortOrder
    freeMargin?: SortOrder
    isEnabledForTrading?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastSyncAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    eas?: EAOrderByRelationAggregateInput
    trades?: TradeOrderByRelationAggregateInput
  }

  export type MT5AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    accountNumber?: string
    AND?: MT5AccountWhereInput | MT5AccountWhereInput[]
    OR?: MT5AccountWhereInput[]
    NOT?: MT5AccountWhereInput | MT5AccountWhereInput[]
    userId?: StringFilter<"MT5Account"> | string
    broker?: StringFilter<"MT5Account"> | string
    serverName?: StringFilter<"MT5Account"> | string
    login?: StringFilter<"MT5Account"> | string
    password?: StringNullableFilter<"MT5Account"> | string | null
    vpsIp?: StringNullableFilter<"MT5Account"> | string | null
    vpsPort?: IntNullableFilter<"MT5Account"> | number | null
    status?: EnumAccountStatusFilter<"MT5Account"> | $Enums.AccountStatus
    balance?: FloatFilter<"MT5Account"> | number
    equity?: FloatFilter<"MT5Account"> | number
    margin?: FloatFilter<"MT5Account"> | number
    freeMargin?: FloatFilter<"MT5Account"> | number
    isEnabledForTrading?: BoolFilter<"MT5Account"> | boolean
    createdAt?: DateTimeFilter<"MT5Account"> | Date | string
    updatedAt?: DateTimeFilter<"MT5Account"> | Date | string
    lastSyncAt?: DateTimeNullableFilter<"MT5Account"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    eas?: EAListRelationFilter
    trades?: TradeListRelationFilter
  }, "id" | "accountNumber">

  export type MT5AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    accountNumber?: SortOrder
    broker?: SortOrder
    serverName?: SortOrder
    login?: SortOrder
    password?: SortOrderInput | SortOrder
    vpsIp?: SortOrderInput | SortOrder
    vpsPort?: SortOrderInput | SortOrder
    status?: SortOrder
    balance?: SortOrder
    equity?: SortOrder
    margin?: SortOrder
    freeMargin?: SortOrder
    isEnabledForTrading?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastSyncAt?: SortOrderInput | SortOrder
    _count?: MT5AccountCountOrderByAggregateInput
    _avg?: MT5AccountAvgOrderByAggregateInput
    _max?: MT5AccountMaxOrderByAggregateInput
    _min?: MT5AccountMinOrderByAggregateInput
    _sum?: MT5AccountSumOrderByAggregateInput
  }

  export type MT5AccountScalarWhereWithAggregatesInput = {
    AND?: MT5AccountScalarWhereWithAggregatesInput | MT5AccountScalarWhereWithAggregatesInput[]
    OR?: MT5AccountScalarWhereWithAggregatesInput[]
    NOT?: MT5AccountScalarWhereWithAggregatesInput | MT5AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MT5Account"> | string
    userId?: StringWithAggregatesFilter<"MT5Account"> | string
    accountNumber?: StringWithAggregatesFilter<"MT5Account"> | string
    broker?: StringWithAggregatesFilter<"MT5Account"> | string
    serverName?: StringWithAggregatesFilter<"MT5Account"> | string
    login?: StringWithAggregatesFilter<"MT5Account"> | string
    password?: StringNullableWithAggregatesFilter<"MT5Account"> | string | null
    vpsIp?: StringNullableWithAggregatesFilter<"MT5Account"> | string | null
    vpsPort?: IntNullableWithAggregatesFilter<"MT5Account"> | number | null
    status?: EnumAccountStatusWithAggregatesFilter<"MT5Account"> | $Enums.AccountStatus
    balance?: FloatWithAggregatesFilter<"MT5Account"> | number
    equity?: FloatWithAggregatesFilter<"MT5Account"> | number
    margin?: FloatWithAggregatesFilter<"MT5Account"> | number
    freeMargin?: FloatWithAggregatesFilter<"MT5Account"> | number
    isEnabledForTrading?: BoolWithAggregatesFilter<"MT5Account"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"MT5Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MT5Account"> | Date | string
    lastSyncAt?: DateTimeNullableWithAggregatesFilter<"MT5Account"> | Date | string | null
  }

  export type EAWhereInput = {
    AND?: EAWhereInput | EAWhereInput[]
    OR?: EAWhereInput[]
    NOT?: EAWhereInput | EAWhereInput[]
    id?: StringFilter<"EA"> | string
    userId?: StringFilter<"EA"> | string
    mt5AccountId?: StringFilter<"EA"> | string
    name?: StringFilter<"EA"> | string
    version?: StringNullableFilter<"EA"> | string | null
    magicNumber?: IntNullableFilter<"EA"> | number | null
    status?: EnumEAStatusFilter<"EA"> | $Enums.EAStatus
    safetyIndicator?: EnumSafetyIndicatorFilter<"EA"> | $Enums.SafetyIndicator
    indicatorScore?: FloatFilter<"EA"> | number
    stoppedByIndicator?: BoolFilter<"EA"> | boolean
    stoppedByIndicatorAt?: DateTimeNullableFilter<"EA"> | Date | string | null
    maxLotSize?: FloatFilter<"EA"> | number
    riskPercent?: FloatFilter<"EA"> | number
    settings?: JsonNullableFilter<"EA">
    lastStartAt?: DateTimeNullableFilter<"EA"> | Date | string | null
    lastStopAt?: DateTimeNullableFilter<"EA"> | Date | string | null
    uptime?: IntFilter<"EA"> | number
    totalTrades?: IntFilter<"EA"> | number
    winningTrades?: IntFilter<"EA"> | number
    totalProfit?: FloatFilter<"EA"> | number
    createdAt?: DateTimeFilter<"EA"> | Date | string
    updatedAt?: DateTimeFilter<"EA"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    mt5Account?: XOR<MT5AccountRelationFilter, MT5AccountWhereInput>
  }

  export type EAOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    mt5AccountId?: SortOrder
    name?: SortOrder
    version?: SortOrderInput | SortOrder
    magicNumber?: SortOrderInput | SortOrder
    status?: SortOrder
    safetyIndicator?: SortOrder
    indicatorScore?: SortOrder
    stoppedByIndicator?: SortOrder
    stoppedByIndicatorAt?: SortOrderInput | SortOrder
    maxLotSize?: SortOrder
    riskPercent?: SortOrder
    settings?: SortOrderInput | SortOrder
    lastStartAt?: SortOrderInput | SortOrder
    lastStopAt?: SortOrderInput | SortOrder
    uptime?: SortOrder
    totalTrades?: SortOrder
    winningTrades?: SortOrder
    totalProfit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    mt5Account?: MT5AccountOrderByWithRelationInput
  }

  export type EAWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EAWhereInput | EAWhereInput[]
    OR?: EAWhereInput[]
    NOT?: EAWhereInput | EAWhereInput[]
    userId?: StringFilter<"EA"> | string
    mt5AccountId?: StringFilter<"EA"> | string
    name?: StringFilter<"EA"> | string
    version?: StringNullableFilter<"EA"> | string | null
    magicNumber?: IntNullableFilter<"EA"> | number | null
    status?: EnumEAStatusFilter<"EA"> | $Enums.EAStatus
    safetyIndicator?: EnumSafetyIndicatorFilter<"EA"> | $Enums.SafetyIndicator
    indicatorScore?: FloatFilter<"EA"> | number
    stoppedByIndicator?: BoolFilter<"EA"> | boolean
    stoppedByIndicatorAt?: DateTimeNullableFilter<"EA"> | Date | string | null
    maxLotSize?: FloatFilter<"EA"> | number
    riskPercent?: FloatFilter<"EA"> | number
    settings?: JsonNullableFilter<"EA">
    lastStartAt?: DateTimeNullableFilter<"EA"> | Date | string | null
    lastStopAt?: DateTimeNullableFilter<"EA"> | Date | string | null
    uptime?: IntFilter<"EA"> | number
    totalTrades?: IntFilter<"EA"> | number
    winningTrades?: IntFilter<"EA"> | number
    totalProfit?: FloatFilter<"EA"> | number
    createdAt?: DateTimeFilter<"EA"> | Date | string
    updatedAt?: DateTimeFilter<"EA"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    mt5Account?: XOR<MT5AccountRelationFilter, MT5AccountWhereInput>
  }, "id">

  export type EAOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    mt5AccountId?: SortOrder
    name?: SortOrder
    version?: SortOrderInput | SortOrder
    magicNumber?: SortOrderInput | SortOrder
    status?: SortOrder
    safetyIndicator?: SortOrder
    indicatorScore?: SortOrder
    stoppedByIndicator?: SortOrder
    stoppedByIndicatorAt?: SortOrderInput | SortOrder
    maxLotSize?: SortOrder
    riskPercent?: SortOrder
    settings?: SortOrderInput | SortOrder
    lastStartAt?: SortOrderInput | SortOrder
    lastStopAt?: SortOrderInput | SortOrder
    uptime?: SortOrder
    totalTrades?: SortOrder
    winningTrades?: SortOrder
    totalProfit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EACountOrderByAggregateInput
    _avg?: EAAvgOrderByAggregateInput
    _max?: EAMaxOrderByAggregateInput
    _min?: EAMinOrderByAggregateInput
    _sum?: EASumOrderByAggregateInput
  }

  export type EAScalarWhereWithAggregatesInput = {
    AND?: EAScalarWhereWithAggregatesInput | EAScalarWhereWithAggregatesInput[]
    OR?: EAScalarWhereWithAggregatesInput[]
    NOT?: EAScalarWhereWithAggregatesInput | EAScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EA"> | string
    userId?: StringWithAggregatesFilter<"EA"> | string
    mt5AccountId?: StringWithAggregatesFilter<"EA"> | string
    name?: StringWithAggregatesFilter<"EA"> | string
    version?: StringNullableWithAggregatesFilter<"EA"> | string | null
    magicNumber?: IntNullableWithAggregatesFilter<"EA"> | number | null
    status?: EnumEAStatusWithAggregatesFilter<"EA"> | $Enums.EAStatus
    safetyIndicator?: EnumSafetyIndicatorWithAggregatesFilter<"EA"> | $Enums.SafetyIndicator
    indicatorScore?: FloatWithAggregatesFilter<"EA"> | number
    stoppedByIndicator?: BoolWithAggregatesFilter<"EA"> | boolean
    stoppedByIndicatorAt?: DateTimeNullableWithAggregatesFilter<"EA"> | Date | string | null
    maxLotSize?: FloatWithAggregatesFilter<"EA"> | number
    riskPercent?: FloatWithAggregatesFilter<"EA"> | number
    settings?: JsonNullableWithAggregatesFilter<"EA">
    lastStartAt?: DateTimeNullableWithAggregatesFilter<"EA"> | Date | string | null
    lastStopAt?: DateTimeNullableWithAggregatesFilter<"EA"> | Date | string | null
    uptime?: IntWithAggregatesFilter<"EA"> | number
    totalTrades?: IntWithAggregatesFilter<"EA"> | number
    winningTrades?: IntWithAggregatesFilter<"EA"> | number
    totalProfit?: FloatWithAggregatesFilter<"EA"> | number
    createdAt?: DateTimeWithAggregatesFilter<"EA"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EA"> | Date | string
  }

  export type TradeWhereInput = {
    AND?: TradeWhereInput | TradeWhereInput[]
    OR?: TradeWhereInput[]
    NOT?: TradeWhereInput | TradeWhereInput[]
    id?: StringFilter<"Trade"> | string
    userId?: StringFilter<"Trade"> | string
    mt5AccountId?: StringFilter<"Trade"> | string
    ticket?: StringFilter<"Trade"> | string
    symbol?: StringFilter<"Trade"> | string
    type?: StringFilter<"Trade"> | string
    volume?: FloatFilter<"Trade"> | number
    openPrice?: FloatFilter<"Trade"> | number
    openTime?: DateTimeFilter<"Trade"> | Date | string
    closePrice?: FloatNullableFilter<"Trade"> | number | null
    closeTime?: DateTimeNullableFilter<"Trade"> | Date | string | null
    profit?: FloatFilter<"Trade"> | number
    commission?: FloatFilter<"Trade"> | number
    swap?: FloatFilter<"Trade"> | number
    magicNumber?: IntNullableFilter<"Trade"> | number | null
    comment?: StringNullableFilter<"Trade"> | string | null
    isClosed?: BoolFilter<"Trade"> | boolean
    createdAt?: DateTimeFilter<"Trade"> | Date | string
    updatedAt?: DateTimeFilter<"Trade"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    mt5Account?: XOR<MT5AccountRelationFilter, MT5AccountWhereInput>
  }

  export type TradeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    mt5AccountId?: SortOrder
    ticket?: SortOrder
    symbol?: SortOrder
    type?: SortOrder
    volume?: SortOrder
    openPrice?: SortOrder
    openTime?: SortOrder
    closePrice?: SortOrderInput | SortOrder
    closeTime?: SortOrderInput | SortOrder
    profit?: SortOrder
    commission?: SortOrder
    swap?: SortOrder
    magicNumber?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    isClosed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    mt5Account?: MT5AccountOrderByWithRelationInput
  }

  export type TradeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    ticket?: string
    AND?: TradeWhereInput | TradeWhereInput[]
    OR?: TradeWhereInput[]
    NOT?: TradeWhereInput | TradeWhereInput[]
    userId?: StringFilter<"Trade"> | string
    mt5AccountId?: StringFilter<"Trade"> | string
    symbol?: StringFilter<"Trade"> | string
    type?: StringFilter<"Trade"> | string
    volume?: FloatFilter<"Trade"> | number
    openPrice?: FloatFilter<"Trade"> | number
    openTime?: DateTimeFilter<"Trade"> | Date | string
    closePrice?: FloatNullableFilter<"Trade"> | number | null
    closeTime?: DateTimeNullableFilter<"Trade"> | Date | string | null
    profit?: FloatFilter<"Trade"> | number
    commission?: FloatFilter<"Trade"> | number
    swap?: FloatFilter<"Trade"> | number
    magicNumber?: IntNullableFilter<"Trade"> | number | null
    comment?: StringNullableFilter<"Trade"> | string | null
    isClosed?: BoolFilter<"Trade"> | boolean
    createdAt?: DateTimeFilter<"Trade"> | Date | string
    updatedAt?: DateTimeFilter<"Trade"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    mt5Account?: XOR<MT5AccountRelationFilter, MT5AccountWhereInput>
  }, "id" | "ticket">

  export type TradeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    mt5AccountId?: SortOrder
    ticket?: SortOrder
    symbol?: SortOrder
    type?: SortOrder
    volume?: SortOrder
    openPrice?: SortOrder
    openTime?: SortOrder
    closePrice?: SortOrderInput | SortOrder
    closeTime?: SortOrderInput | SortOrder
    profit?: SortOrder
    commission?: SortOrder
    swap?: SortOrder
    magicNumber?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    isClosed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TradeCountOrderByAggregateInput
    _avg?: TradeAvgOrderByAggregateInput
    _max?: TradeMaxOrderByAggregateInput
    _min?: TradeMinOrderByAggregateInput
    _sum?: TradeSumOrderByAggregateInput
  }

  export type TradeScalarWhereWithAggregatesInput = {
    AND?: TradeScalarWhereWithAggregatesInput | TradeScalarWhereWithAggregatesInput[]
    OR?: TradeScalarWhereWithAggregatesInput[]
    NOT?: TradeScalarWhereWithAggregatesInput | TradeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Trade"> | string
    userId?: StringWithAggregatesFilter<"Trade"> | string
    mt5AccountId?: StringWithAggregatesFilter<"Trade"> | string
    ticket?: StringWithAggregatesFilter<"Trade"> | string
    symbol?: StringWithAggregatesFilter<"Trade"> | string
    type?: StringWithAggregatesFilter<"Trade"> | string
    volume?: FloatWithAggregatesFilter<"Trade"> | number
    openPrice?: FloatWithAggregatesFilter<"Trade"> | number
    openTime?: DateTimeWithAggregatesFilter<"Trade"> | Date | string
    closePrice?: FloatNullableWithAggregatesFilter<"Trade"> | number | null
    closeTime?: DateTimeNullableWithAggregatesFilter<"Trade"> | Date | string | null
    profit?: FloatWithAggregatesFilter<"Trade"> | number
    commission?: FloatWithAggregatesFilter<"Trade"> | number
    swap?: FloatWithAggregatesFilter<"Trade"> | number
    magicNumber?: IntNullableWithAggregatesFilter<"Trade"> | number | null
    comment?: StringNullableWithAggregatesFilter<"Trade"> | string | null
    isClosed?: BoolWithAggregatesFilter<"Trade"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Trade"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Trade"> | Date | string
  }

  export type AutomationWhereInput = {
    AND?: AutomationWhereInput | AutomationWhereInput[]
    OR?: AutomationWhereInput[]
    NOT?: AutomationWhereInput | AutomationWhereInput[]
    id?: StringFilter<"Automation"> | string
    name?: StringFilter<"Automation"> | string
    description?: StringNullableFilter<"Automation"> | string | null
    userId?: StringNullableFilter<"Automation"> | string | null
    triggerType?: EnumAutomationTriggerTypeFilter<"Automation"> | $Enums.AutomationTriggerType
    triggerValue?: IntNullableFilter<"Automation"> | number | null
    triggerData?: JsonNullableFilter<"Automation">
    actionTypes?: EnumAutomationActionTypeNullableListFilter<"Automation">
    actionData?: JsonNullableFilter<"Automation">
    messageSubject?: StringNullableFilter<"Automation"> | string | null
    messageBody?: StringFilter<"Automation"> | string
    status?: EnumAutomationStatusFilter<"Automation"> | $Enums.AutomationStatus
    priority?: IntFilter<"Automation"> | number
    isUserEnabled?: BoolFilter<"Automation"> | boolean
    totalTriggered?: IntFilter<"Automation"> | number
    totalSent?: IntFilter<"Automation"> | number
    totalFailed?: IntFilter<"Automation"> | number
    lastTriggered?: DateTimeNullableFilter<"Automation"> | Date | string | null
    createdAt?: DateTimeFilter<"Automation"> | Date | string
    updatedAt?: DateTimeFilter<"Automation"> | Date | string
    createdBy?: StringNullableFilter<"Automation"> | string | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    logs?: NotificationLogListRelationFilter
  }

  export type AutomationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    triggerType?: SortOrder
    triggerValue?: SortOrderInput | SortOrder
    triggerData?: SortOrderInput | SortOrder
    actionTypes?: SortOrder
    actionData?: SortOrderInput | SortOrder
    messageSubject?: SortOrderInput | SortOrder
    messageBody?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    isUserEnabled?: SortOrder
    totalTriggered?: SortOrder
    totalSent?: SortOrder
    totalFailed?: SortOrder
    lastTriggered?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    logs?: NotificationLogOrderByRelationAggregateInput
  }

  export type AutomationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AutomationWhereInput | AutomationWhereInput[]
    OR?: AutomationWhereInput[]
    NOT?: AutomationWhereInput | AutomationWhereInput[]
    name?: StringFilter<"Automation"> | string
    description?: StringNullableFilter<"Automation"> | string | null
    userId?: StringNullableFilter<"Automation"> | string | null
    triggerType?: EnumAutomationTriggerTypeFilter<"Automation"> | $Enums.AutomationTriggerType
    triggerValue?: IntNullableFilter<"Automation"> | number | null
    triggerData?: JsonNullableFilter<"Automation">
    actionTypes?: EnumAutomationActionTypeNullableListFilter<"Automation">
    actionData?: JsonNullableFilter<"Automation">
    messageSubject?: StringNullableFilter<"Automation"> | string | null
    messageBody?: StringFilter<"Automation"> | string
    status?: EnumAutomationStatusFilter<"Automation"> | $Enums.AutomationStatus
    priority?: IntFilter<"Automation"> | number
    isUserEnabled?: BoolFilter<"Automation"> | boolean
    totalTriggered?: IntFilter<"Automation"> | number
    totalSent?: IntFilter<"Automation"> | number
    totalFailed?: IntFilter<"Automation"> | number
    lastTriggered?: DateTimeNullableFilter<"Automation"> | Date | string | null
    createdAt?: DateTimeFilter<"Automation"> | Date | string
    updatedAt?: DateTimeFilter<"Automation"> | Date | string
    createdBy?: StringNullableFilter<"Automation"> | string | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    logs?: NotificationLogListRelationFilter
  }, "id">

  export type AutomationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    triggerType?: SortOrder
    triggerValue?: SortOrderInput | SortOrder
    triggerData?: SortOrderInput | SortOrder
    actionTypes?: SortOrder
    actionData?: SortOrderInput | SortOrder
    messageSubject?: SortOrderInput | SortOrder
    messageBody?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    isUserEnabled?: SortOrder
    totalTriggered?: SortOrder
    totalSent?: SortOrder
    totalFailed?: SortOrder
    lastTriggered?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    _count?: AutomationCountOrderByAggregateInput
    _avg?: AutomationAvgOrderByAggregateInput
    _max?: AutomationMaxOrderByAggregateInput
    _min?: AutomationMinOrderByAggregateInput
    _sum?: AutomationSumOrderByAggregateInput
  }

  export type AutomationScalarWhereWithAggregatesInput = {
    AND?: AutomationScalarWhereWithAggregatesInput | AutomationScalarWhereWithAggregatesInput[]
    OR?: AutomationScalarWhereWithAggregatesInput[]
    NOT?: AutomationScalarWhereWithAggregatesInput | AutomationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Automation"> | string
    name?: StringWithAggregatesFilter<"Automation"> | string
    description?: StringNullableWithAggregatesFilter<"Automation"> | string | null
    userId?: StringNullableWithAggregatesFilter<"Automation"> | string | null
    triggerType?: EnumAutomationTriggerTypeWithAggregatesFilter<"Automation"> | $Enums.AutomationTriggerType
    triggerValue?: IntNullableWithAggregatesFilter<"Automation"> | number | null
    triggerData?: JsonNullableWithAggregatesFilter<"Automation">
    actionTypes?: EnumAutomationActionTypeNullableListFilter<"Automation">
    actionData?: JsonNullableWithAggregatesFilter<"Automation">
    messageSubject?: StringNullableWithAggregatesFilter<"Automation"> | string | null
    messageBody?: StringWithAggregatesFilter<"Automation"> | string
    status?: EnumAutomationStatusWithAggregatesFilter<"Automation"> | $Enums.AutomationStatus
    priority?: IntWithAggregatesFilter<"Automation"> | number
    isUserEnabled?: BoolWithAggregatesFilter<"Automation"> | boolean
    totalTriggered?: IntWithAggregatesFilter<"Automation"> | number
    totalSent?: IntWithAggregatesFilter<"Automation"> | number
    totalFailed?: IntWithAggregatesFilter<"Automation"> | number
    lastTriggered?: DateTimeNullableWithAggregatesFilter<"Automation"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Automation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Automation"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"Automation"> | string | null
  }

  export type NotificationLogWhereInput = {
    AND?: NotificationLogWhereInput | NotificationLogWhereInput[]
    OR?: NotificationLogWhereInput[]
    NOT?: NotificationLogWhereInput | NotificationLogWhereInput[]
    id?: StringFilter<"NotificationLog"> | string
    automationId?: StringFilter<"NotificationLog"> | string
    userId?: StringFilter<"NotificationLog"> | string
    channel?: EnumAutomationActionTypeFilter<"NotificationLog"> | $Enums.AutomationActionType
    recipient?: StringFilter<"NotificationLog"> | string
    subject?: StringNullableFilter<"NotificationLog"> | string | null
    message?: StringFilter<"NotificationLog"> | string
    status?: EnumNotificationStatusFilter<"NotificationLog"> | $Enums.NotificationStatus
    sentAt?: DateTimeNullableFilter<"NotificationLog"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"NotificationLog"> | Date | string | null
    failedAt?: DateTimeNullableFilter<"NotificationLog"> | Date | string | null
    errorMessage?: StringNullableFilter<"NotificationLog"> | string | null
    metadata?: JsonNullableFilter<"NotificationLog">
    createdAt?: DateTimeFilter<"NotificationLog"> | Date | string
    automation?: XOR<AutomationRelationFilter, AutomationWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationLogOrderByWithRelationInput = {
    id?: SortOrder
    automationId?: SortOrder
    userId?: SortOrder
    channel?: SortOrder
    recipient?: SortOrder
    subject?: SortOrderInput | SortOrder
    message?: SortOrder
    status?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    failedAt?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    automation?: AutomationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type NotificationLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationLogWhereInput | NotificationLogWhereInput[]
    OR?: NotificationLogWhereInput[]
    NOT?: NotificationLogWhereInput | NotificationLogWhereInput[]
    automationId?: StringFilter<"NotificationLog"> | string
    userId?: StringFilter<"NotificationLog"> | string
    channel?: EnumAutomationActionTypeFilter<"NotificationLog"> | $Enums.AutomationActionType
    recipient?: StringFilter<"NotificationLog"> | string
    subject?: StringNullableFilter<"NotificationLog"> | string | null
    message?: StringFilter<"NotificationLog"> | string
    status?: EnumNotificationStatusFilter<"NotificationLog"> | $Enums.NotificationStatus
    sentAt?: DateTimeNullableFilter<"NotificationLog"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"NotificationLog"> | Date | string | null
    failedAt?: DateTimeNullableFilter<"NotificationLog"> | Date | string | null
    errorMessage?: StringNullableFilter<"NotificationLog"> | string | null
    metadata?: JsonNullableFilter<"NotificationLog">
    createdAt?: DateTimeFilter<"NotificationLog"> | Date | string
    automation?: XOR<AutomationRelationFilter, AutomationWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationLogOrderByWithAggregationInput = {
    id?: SortOrder
    automationId?: SortOrder
    userId?: SortOrder
    channel?: SortOrder
    recipient?: SortOrder
    subject?: SortOrderInput | SortOrder
    message?: SortOrder
    status?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    failedAt?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: NotificationLogCountOrderByAggregateInput
    _max?: NotificationLogMaxOrderByAggregateInput
    _min?: NotificationLogMinOrderByAggregateInput
  }

  export type NotificationLogScalarWhereWithAggregatesInput = {
    AND?: NotificationLogScalarWhereWithAggregatesInput | NotificationLogScalarWhereWithAggregatesInput[]
    OR?: NotificationLogScalarWhereWithAggregatesInput[]
    NOT?: NotificationLogScalarWhereWithAggregatesInput | NotificationLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationLog"> | string
    automationId?: StringWithAggregatesFilter<"NotificationLog"> | string
    userId?: StringWithAggregatesFilter<"NotificationLog"> | string
    channel?: EnumAutomationActionTypeWithAggregatesFilter<"NotificationLog"> | $Enums.AutomationActionType
    recipient?: StringWithAggregatesFilter<"NotificationLog"> | string
    subject?: StringNullableWithAggregatesFilter<"NotificationLog"> | string | null
    message?: StringWithAggregatesFilter<"NotificationLog"> | string
    status?: EnumNotificationStatusWithAggregatesFilter<"NotificationLog"> | $Enums.NotificationStatus
    sentAt?: DateTimeNullableWithAggregatesFilter<"NotificationLog"> | Date | string | null
    deliveredAt?: DateTimeNullableWithAggregatesFilter<"NotificationLog"> | Date | string | null
    failedAt?: DateTimeNullableWithAggregatesFilter<"NotificationLog"> | Date | string | null
    errorMessage?: StringNullableWithAggregatesFilter<"NotificationLog"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"NotificationLog">
    createdAt?: DateTimeWithAggregatesFilter<"NotificationLog"> | Date | string
  }

  export type UserInsightWhereInput = {
    AND?: UserInsightWhereInput | UserInsightWhereInput[]
    OR?: UserInsightWhereInput[]
    NOT?: UserInsightWhereInput | UserInsightWhereInput[]
    id?: StringFilter<"UserInsight"> | string
    userId?: StringFilter<"UserInsight"> | string
    winRate?: FloatFilter<"UserInsight"> | number
    avgProfitPerTrade?: FloatFilter<"UserInsight"> | number
    avgLossPerTrade?: FloatFilter<"UserInsight"> | number
    profitFactor?: FloatFilter<"UserInsight"> | number
    maxDrawdown?: FloatFilter<"UserInsight"> | number
    sharpeRatio?: FloatFilter<"UserInsight"> | number
    tradingDaysActive?: IntFilter<"UserInsight"> | number
    avgTradesPerDay?: FloatFilter<"UserInsight"> | number
    preferredTimeframe?: StringNullableFilter<"UserInsight"> | string | null
    riskLevel?: StringNullableFilter<"UserInsight"> | string | null
    lastTradeDate?: DateTimeNullableFilter<"UserInsight"> | Date | string | null
    consecutiveWins?: IntFilter<"UserInsight"> | number
    consecutiveLosses?: IntFilter<"UserInsight"> | number
    daysSinceLastTrade?: IntFilter<"UserInsight"> | number
    lifetimeValue?: FloatFilter<"UserInsight"> | number
    totalRevenue?: FloatFilter<"UserInsight"> | number
    churnRisk?: FloatFilter<"UserInsight"> | number
    engagementScore?: FloatFilter<"UserInsight"> | number
    predictedNextAction?: StringNullableFilter<"UserInsight"> | string | null
    retentionProbability?: FloatFilter<"UserInsight"> | number
    upsellProbability?: FloatFilter<"UserInsight"> | number
    updatedAt?: DateTimeFilter<"UserInsight"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserInsightOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    winRate?: SortOrder
    avgProfitPerTrade?: SortOrder
    avgLossPerTrade?: SortOrder
    profitFactor?: SortOrder
    maxDrawdown?: SortOrder
    sharpeRatio?: SortOrder
    tradingDaysActive?: SortOrder
    avgTradesPerDay?: SortOrder
    preferredTimeframe?: SortOrderInput | SortOrder
    riskLevel?: SortOrderInput | SortOrder
    lastTradeDate?: SortOrderInput | SortOrder
    consecutiveWins?: SortOrder
    consecutiveLosses?: SortOrder
    daysSinceLastTrade?: SortOrder
    lifetimeValue?: SortOrder
    totalRevenue?: SortOrder
    churnRisk?: SortOrder
    engagementScore?: SortOrder
    predictedNextAction?: SortOrderInput | SortOrder
    retentionProbability?: SortOrder
    upsellProbability?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserInsightWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserInsightWhereInput | UserInsightWhereInput[]
    OR?: UserInsightWhereInput[]
    NOT?: UserInsightWhereInput | UserInsightWhereInput[]
    winRate?: FloatFilter<"UserInsight"> | number
    avgProfitPerTrade?: FloatFilter<"UserInsight"> | number
    avgLossPerTrade?: FloatFilter<"UserInsight"> | number
    profitFactor?: FloatFilter<"UserInsight"> | number
    maxDrawdown?: FloatFilter<"UserInsight"> | number
    sharpeRatio?: FloatFilter<"UserInsight"> | number
    tradingDaysActive?: IntFilter<"UserInsight"> | number
    avgTradesPerDay?: FloatFilter<"UserInsight"> | number
    preferredTimeframe?: StringNullableFilter<"UserInsight"> | string | null
    riskLevel?: StringNullableFilter<"UserInsight"> | string | null
    lastTradeDate?: DateTimeNullableFilter<"UserInsight"> | Date | string | null
    consecutiveWins?: IntFilter<"UserInsight"> | number
    consecutiveLosses?: IntFilter<"UserInsight"> | number
    daysSinceLastTrade?: IntFilter<"UserInsight"> | number
    lifetimeValue?: FloatFilter<"UserInsight"> | number
    totalRevenue?: FloatFilter<"UserInsight"> | number
    churnRisk?: FloatFilter<"UserInsight"> | number
    engagementScore?: FloatFilter<"UserInsight"> | number
    predictedNextAction?: StringNullableFilter<"UserInsight"> | string | null
    retentionProbability?: FloatFilter<"UserInsight"> | number
    upsellProbability?: FloatFilter<"UserInsight"> | number
    updatedAt?: DateTimeFilter<"UserInsight"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserInsightOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    winRate?: SortOrder
    avgProfitPerTrade?: SortOrder
    avgLossPerTrade?: SortOrder
    profitFactor?: SortOrder
    maxDrawdown?: SortOrder
    sharpeRatio?: SortOrder
    tradingDaysActive?: SortOrder
    avgTradesPerDay?: SortOrder
    preferredTimeframe?: SortOrderInput | SortOrder
    riskLevel?: SortOrderInput | SortOrder
    lastTradeDate?: SortOrderInput | SortOrder
    consecutiveWins?: SortOrder
    consecutiveLosses?: SortOrder
    daysSinceLastTrade?: SortOrder
    lifetimeValue?: SortOrder
    totalRevenue?: SortOrder
    churnRisk?: SortOrder
    engagementScore?: SortOrder
    predictedNextAction?: SortOrderInput | SortOrder
    retentionProbability?: SortOrder
    upsellProbability?: SortOrder
    updatedAt?: SortOrder
    _count?: UserInsightCountOrderByAggregateInput
    _avg?: UserInsightAvgOrderByAggregateInput
    _max?: UserInsightMaxOrderByAggregateInput
    _min?: UserInsightMinOrderByAggregateInput
    _sum?: UserInsightSumOrderByAggregateInput
  }

  export type UserInsightScalarWhereWithAggregatesInput = {
    AND?: UserInsightScalarWhereWithAggregatesInput | UserInsightScalarWhereWithAggregatesInput[]
    OR?: UserInsightScalarWhereWithAggregatesInput[]
    NOT?: UserInsightScalarWhereWithAggregatesInput | UserInsightScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserInsight"> | string
    userId?: StringWithAggregatesFilter<"UserInsight"> | string
    winRate?: FloatWithAggregatesFilter<"UserInsight"> | number
    avgProfitPerTrade?: FloatWithAggregatesFilter<"UserInsight"> | number
    avgLossPerTrade?: FloatWithAggregatesFilter<"UserInsight"> | number
    profitFactor?: FloatWithAggregatesFilter<"UserInsight"> | number
    maxDrawdown?: FloatWithAggregatesFilter<"UserInsight"> | number
    sharpeRatio?: FloatWithAggregatesFilter<"UserInsight"> | number
    tradingDaysActive?: IntWithAggregatesFilter<"UserInsight"> | number
    avgTradesPerDay?: FloatWithAggregatesFilter<"UserInsight"> | number
    preferredTimeframe?: StringNullableWithAggregatesFilter<"UserInsight"> | string | null
    riskLevel?: StringNullableWithAggregatesFilter<"UserInsight"> | string | null
    lastTradeDate?: DateTimeNullableWithAggregatesFilter<"UserInsight"> | Date | string | null
    consecutiveWins?: IntWithAggregatesFilter<"UserInsight"> | number
    consecutiveLosses?: IntWithAggregatesFilter<"UserInsight"> | number
    daysSinceLastTrade?: IntWithAggregatesFilter<"UserInsight"> | number
    lifetimeValue?: FloatWithAggregatesFilter<"UserInsight"> | number
    totalRevenue?: FloatWithAggregatesFilter<"UserInsight"> | number
    churnRisk?: FloatWithAggregatesFilter<"UserInsight"> | number
    engagementScore?: FloatWithAggregatesFilter<"UserInsight"> | number
    predictedNextAction?: StringNullableWithAggregatesFilter<"UserInsight"> | string | null
    retentionProbability?: FloatWithAggregatesFilter<"UserInsight"> | number
    upsellProbability?: FloatWithAggregatesFilter<"UserInsight"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"UserInsight"> | Date | string
  }

  export type SystemLogWhereInput = {
    AND?: SystemLogWhereInput | SystemLogWhereInput[]
    OR?: SystemLogWhereInput[]
    NOT?: SystemLogWhereInput | SystemLogWhereInput[]
    id?: StringFilter<"SystemLog"> | string
    level?: StringFilter<"SystemLog"> | string
    component?: StringFilter<"SystemLog"> | string
    message?: StringFilter<"SystemLog"> | string
    metadata?: JsonNullableFilter<"SystemLog">
    createdAt?: DateTimeFilter<"SystemLog"> | Date | string
  }

  export type SystemLogOrderByWithRelationInput = {
    id?: SortOrder
    level?: SortOrder
    component?: SortOrder
    message?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type SystemLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SystemLogWhereInput | SystemLogWhereInput[]
    OR?: SystemLogWhereInput[]
    NOT?: SystemLogWhereInput | SystemLogWhereInput[]
    level?: StringFilter<"SystemLog"> | string
    component?: StringFilter<"SystemLog"> | string
    message?: StringFilter<"SystemLog"> | string
    metadata?: JsonNullableFilter<"SystemLog">
    createdAt?: DateTimeFilter<"SystemLog"> | Date | string
  }, "id">

  export type SystemLogOrderByWithAggregationInput = {
    id?: SortOrder
    level?: SortOrder
    component?: SortOrder
    message?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SystemLogCountOrderByAggregateInput
    _max?: SystemLogMaxOrderByAggregateInput
    _min?: SystemLogMinOrderByAggregateInput
  }

  export type SystemLogScalarWhereWithAggregatesInput = {
    AND?: SystemLogScalarWhereWithAggregatesInput | SystemLogScalarWhereWithAggregatesInput[]
    OR?: SystemLogScalarWhereWithAggregatesInput[]
    NOT?: SystemLogScalarWhereWithAggregatesInput | SystemLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemLog"> | string
    level?: StringWithAggregatesFilter<"SystemLog"> | string
    component?: StringWithAggregatesFilter<"SystemLog"> | string
    message?: StringWithAggregatesFilter<"SystemLog"> | string
    metadata?: JsonNullableWithAggregatesFilter<"SystemLog">
    createdAt?: DateTimeWithAggregatesFilter<"SystemLog"> | Date | string
  }

  export type MarketConditionWhereInput = {
    AND?: MarketConditionWhereInput | MarketConditionWhereInput[]
    OR?: MarketConditionWhereInput[]
    NOT?: MarketConditionWhereInput | MarketConditionWhereInput[]
    id?: StringFilter<"MarketCondition"> | string
    volatility?: FloatFilter<"MarketCondition"> | number
    spread?: FloatFilter<"MarketCondition"> | number
    trend?: StringFilter<"MarketCondition"> | string
    newsImpact?: BoolFilter<"MarketCondition"> | boolean
    safetyIndicator?: EnumSafetyIndicatorFilter<"MarketCondition"> | $Enums.SafetyIndicator
    reason?: StringFilter<"MarketCondition"> | string
    timestamp?: DateTimeFilter<"MarketCondition"> | Date | string
  }

  export type MarketConditionOrderByWithRelationInput = {
    id?: SortOrder
    volatility?: SortOrder
    spread?: SortOrder
    trend?: SortOrder
    newsImpact?: SortOrder
    safetyIndicator?: SortOrder
    reason?: SortOrder
    timestamp?: SortOrder
  }

  export type MarketConditionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MarketConditionWhereInput | MarketConditionWhereInput[]
    OR?: MarketConditionWhereInput[]
    NOT?: MarketConditionWhereInput | MarketConditionWhereInput[]
    volatility?: FloatFilter<"MarketCondition"> | number
    spread?: FloatFilter<"MarketCondition"> | number
    trend?: StringFilter<"MarketCondition"> | string
    newsImpact?: BoolFilter<"MarketCondition"> | boolean
    safetyIndicator?: EnumSafetyIndicatorFilter<"MarketCondition"> | $Enums.SafetyIndicator
    reason?: StringFilter<"MarketCondition"> | string
    timestamp?: DateTimeFilter<"MarketCondition"> | Date | string
  }, "id">

  export type MarketConditionOrderByWithAggregationInput = {
    id?: SortOrder
    volatility?: SortOrder
    spread?: SortOrder
    trend?: SortOrder
    newsImpact?: SortOrder
    safetyIndicator?: SortOrder
    reason?: SortOrder
    timestamp?: SortOrder
    _count?: MarketConditionCountOrderByAggregateInput
    _avg?: MarketConditionAvgOrderByAggregateInput
    _max?: MarketConditionMaxOrderByAggregateInput
    _min?: MarketConditionMinOrderByAggregateInput
    _sum?: MarketConditionSumOrderByAggregateInput
  }

  export type MarketConditionScalarWhereWithAggregatesInput = {
    AND?: MarketConditionScalarWhereWithAggregatesInput | MarketConditionScalarWhereWithAggregatesInput[]
    OR?: MarketConditionScalarWhereWithAggregatesInput[]
    NOT?: MarketConditionScalarWhereWithAggregatesInput | MarketConditionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MarketCondition"> | string
    volatility?: FloatWithAggregatesFilter<"MarketCondition"> | number
    spread?: FloatWithAggregatesFilter<"MarketCondition"> | number
    trend?: StringWithAggregatesFilter<"MarketCondition"> | string
    newsImpact?: BoolWithAggregatesFilter<"MarketCondition"> | boolean
    safetyIndicator?: EnumSafetyIndicatorWithAggregatesFilter<"MarketCondition"> | $Enums.SafetyIndicator
    reason?: StringWithAggregatesFilter<"MarketCondition"> | string
    timestamp?: DateTimeWithAggregatesFilter<"MarketCondition"> | Date | string
  }

  export type LeaderboardEntryWhereInput = {
    AND?: LeaderboardEntryWhereInput | LeaderboardEntryWhereInput[]
    OR?: LeaderboardEntryWhereInput[]
    NOT?: LeaderboardEntryWhereInput | LeaderboardEntryWhereInput[]
    id?: StringFilter<"LeaderboardEntry"> | string
    userId?: StringFilter<"LeaderboardEntry"> | string
    period?: StringFilter<"LeaderboardEntry"> | string
    periodDate?: DateTimeFilter<"LeaderboardEntry"> | Date | string
    trades?: IntFilter<"LeaderboardEntry"> | number
    winningTrades?: IntFilter<"LeaderboardEntry"> | number
    losingTrades?: IntFilter<"LeaderboardEntry"> | number
    profit?: FloatFilter<"LeaderboardEntry"> | number
    volume?: FloatFilter<"LeaderboardEntry"> | number
    winRate?: FloatFilter<"LeaderboardEntry"> | number
    rank?: IntNullableFilter<"LeaderboardEntry"> | number | null
    previousRank?: IntNullableFilter<"LeaderboardEntry"> | number | null
    createdAt?: DateTimeFilter<"LeaderboardEntry"> | Date | string
    updatedAt?: DateTimeFilter<"LeaderboardEntry"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type LeaderboardEntryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    period?: SortOrder
    periodDate?: SortOrder
    trades?: SortOrder
    winningTrades?: SortOrder
    losingTrades?: SortOrder
    profit?: SortOrder
    volume?: SortOrder
    winRate?: SortOrder
    rank?: SortOrderInput | SortOrder
    previousRank?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type LeaderboardEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_period_periodDate?: LeaderboardEntryUserIdPeriodPeriodDateCompoundUniqueInput
    AND?: LeaderboardEntryWhereInput | LeaderboardEntryWhereInput[]
    OR?: LeaderboardEntryWhereInput[]
    NOT?: LeaderboardEntryWhereInput | LeaderboardEntryWhereInput[]
    userId?: StringFilter<"LeaderboardEntry"> | string
    period?: StringFilter<"LeaderboardEntry"> | string
    periodDate?: DateTimeFilter<"LeaderboardEntry"> | Date | string
    trades?: IntFilter<"LeaderboardEntry"> | number
    winningTrades?: IntFilter<"LeaderboardEntry"> | number
    losingTrades?: IntFilter<"LeaderboardEntry"> | number
    profit?: FloatFilter<"LeaderboardEntry"> | number
    volume?: FloatFilter<"LeaderboardEntry"> | number
    winRate?: FloatFilter<"LeaderboardEntry"> | number
    rank?: IntNullableFilter<"LeaderboardEntry"> | number | null
    previousRank?: IntNullableFilter<"LeaderboardEntry"> | number | null
    createdAt?: DateTimeFilter<"LeaderboardEntry"> | Date | string
    updatedAt?: DateTimeFilter<"LeaderboardEntry"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_period_periodDate">

  export type LeaderboardEntryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    period?: SortOrder
    periodDate?: SortOrder
    trades?: SortOrder
    winningTrades?: SortOrder
    losingTrades?: SortOrder
    profit?: SortOrder
    volume?: SortOrder
    winRate?: SortOrder
    rank?: SortOrderInput | SortOrder
    previousRank?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LeaderboardEntryCountOrderByAggregateInput
    _avg?: LeaderboardEntryAvgOrderByAggregateInput
    _max?: LeaderboardEntryMaxOrderByAggregateInput
    _min?: LeaderboardEntryMinOrderByAggregateInput
    _sum?: LeaderboardEntrySumOrderByAggregateInput
  }

  export type LeaderboardEntryScalarWhereWithAggregatesInput = {
    AND?: LeaderboardEntryScalarWhereWithAggregatesInput | LeaderboardEntryScalarWhereWithAggregatesInput[]
    OR?: LeaderboardEntryScalarWhereWithAggregatesInput[]
    NOT?: LeaderboardEntryScalarWhereWithAggregatesInput | LeaderboardEntryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LeaderboardEntry"> | string
    userId?: StringWithAggregatesFilter<"LeaderboardEntry"> | string
    period?: StringWithAggregatesFilter<"LeaderboardEntry"> | string
    periodDate?: DateTimeWithAggregatesFilter<"LeaderboardEntry"> | Date | string
    trades?: IntWithAggregatesFilter<"LeaderboardEntry"> | number
    winningTrades?: IntWithAggregatesFilter<"LeaderboardEntry"> | number
    losingTrades?: IntWithAggregatesFilter<"LeaderboardEntry"> | number
    profit?: FloatWithAggregatesFilter<"LeaderboardEntry"> | number
    volume?: FloatWithAggregatesFilter<"LeaderboardEntry"> | number
    winRate?: FloatWithAggregatesFilter<"LeaderboardEntry"> | number
    rank?: IntNullableWithAggregatesFilter<"LeaderboardEntry"> | number | null
    previousRank?: IntNullableWithAggregatesFilter<"LeaderboardEntry"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"LeaderboardEntry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LeaderboardEntry"> | Date | string
  }

  export type IBPartnerWhereInput = {
    AND?: IBPartnerWhereInput | IBPartnerWhereInput[]
    OR?: IBPartnerWhereInput[]
    NOT?: IBPartnerWhereInput | IBPartnerWhereInput[]
    id?: StringFilter<"IBPartner"> | string
    email?: StringFilter<"IBPartner"> | string
    passwordHash?: StringFilter<"IBPartner"> | string
    companyName?: StringFilter<"IBPartner"> | string
    contactName?: StringFilter<"IBPartner"> | string
    phone?: StringFilter<"IBPartner"> | string
    ibCode?: StringFilter<"IBPartner"> | string
    domain?: StringNullableFilter<"IBPartner"> | string | null
    logo?: StringNullableFilter<"IBPartner"> | string | null
    favicon?: StringNullableFilter<"IBPartner"> | string | null
    brandColor?: StringFilter<"IBPartner"> | string
    brandName?: StringNullableFilter<"IBPartner"> | string | null
    isActive?: BoolFilter<"IBPartner"> | boolean
    isApproved?: BoolFilter<"IBPartner"> | boolean
    currentTraders?: StringNullableFilter<"IBPartner"> | string | null
    message?: StringNullableFilter<"IBPartner"> | string | null
    companyDocument?: StringNullableFilter<"IBPartner"> | string | null
    idDocument?: StringNullableFilter<"IBPartner"> | string | null
    kycDocument?: StringNullableFilter<"IBPartner"> | string | null
    kycStatus?: StringFilter<"IBPartner"> | string
    emailVerified?: BoolFilter<"IBPartner"> | boolean
    verificationCode?: StringNullableFilter<"IBPartner"> | string | null
    verificationExpiry?: DateTimeNullableFilter<"IBPartner"> | Date | string | null
    pricingTier?: StringFilter<"IBPartner"> | string
    monthlyFee?: FloatFilter<"IBPartner"> | number
    traderLimit?: IntFilter<"IBPartner"> | number
    spreadRevShare?: FloatFilter<"IBPartner"> | number
    totalTraders?: IntFilter<"IBPartner"> | number
    activeTraders?: IntFilter<"IBPartner"> | number
    monthlyRevenue?: FloatFilter<"IBPartner"> | number
    lifetimeRevenue?: FloatFilter<"IBPartner"> | number
    createdAt?: DateTimeFilter<"IBPartner"> | Date | string
    updatedAt?: DateTimeFilter<"IBPartner"> | Date | string
    approvedAt?: DateTimeNullableFilter<"IBPartner"> | Date | string | null
    approvedBy?: StringNullableFilter<"IBPartner"> | string | null
    users?: UserListRelationFilter
    anonymousAccounts?: AnonymousAccountListRelationFilter
    commissions?: IBCommissionListRelationFilter
    commissionRates?: IBCommissionRateListRelationFilter
  }

  export type IBPartnerOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    companyName?: SortOrder
    contactName?: SortOrder
    phone?: SortOrder
    ibCode?: SortOrder
    domain?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    favicon?: SortOrderInput | SortOrder
    brandColor?: SortOrder
    brandName?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isApproved?: SortOrder
    currentTraders?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    companyDocument?: SortOrderInput | SortOrder
    idDocument?: SortOrderInput | SortOrder
    kycDocument?: SortOrderInput | SortOrder
    kycStatus?: SortOrder
    emailVerified?: SortOrder
    verificationCode?: SortOrderInput | SortOrder
    verificationExpiry?: SortOrderInput | SortOrder
    pricingTier?: SortOrder
    monthlyFee?: SortOrder
    traderLimit?: SortOrder
    spreadRevShare?: SortOrder
    totalTraders?: SortOrder
    activeTraders?: SortOrder
    monthlyRevenue?: SortOrder
    lifetimeRevenue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    users?: UserOrderByRelationAggregateInput
    anonymousAccounts?: AnonymousAccountOrderByRelationAggregateInput
    commissions?: IBCommissionOrderByRelationAggregateInput
    commissionRates?: IBCommissionRateOrderByRelationAggregateInput
  }

  export type IBPartnerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    ibCode?: string
    AND?: IBPartnerWhereInput | IBPartnerWhereInput[]
    OR?: IBPartnerWhereInput[]
    NOT?: IBPartnerWhereInput | IBPartnerWhereInput[]
    passwordHash?: StringFilter<"IBPartner"> | string
    companyName?: StringFilter<"IBPartner"> | string
    contactName?: StringFilter<"IBPartner"> | string
    phone?: StringFilter<"IBPartner"> | string
    domain?: StringNullableFilter<"IBPartner"> | string | null
    logo?: StringNullableFilter<"IBPartner"> | string | null
    favicon?: StringNullableFilter<"IBPartner"> | string | null
    brandColor?: StringFilter<"IBPartner"> | string
    brandName?: StringNullableFilter<"IBPartner"> | string | null
    isActive?: BoolFilter<"IBPartner"> | boolean
    isApproved?: BoolFilter<"IBPartner"> | boolean
    currentTraders?: StringNullableFilter<"IBPartner"> | string | null
    message?: StringNullableFilter<"IBPartner"> | string | null
    companyDocument?: StringNullableFilter<"IBPartner"> | string | null
    idDocument?: StringNullableFilter<"IBPartner"> | string | null
    kycDocument?: StringNullableFilter<"IBPartner"> | string | null
    kycStatus?: StringFilter<"IBPartner"> | string
    emailVerified?: BoolFilter<"IBPartner"> | boolean
    verificationCode?: StringNullableFilter<"IBPartner"> | string | null
    verificationExpiry?: DateTimeNullableFilter<"IBPartner"> | Date | string | null
    pricingTier?: StringFilter<"IBPartner"> | string
    monthlyFee?: FloatFilter<"IBPartner"> | number
    traderLimit?: IntFilter<"IBPartner"> | number
    spreadRevShare?: FloatFilter<"IBPartner"> | number
    totalTraders?: IntFilter<"IBPartner"> | number
    activeTraders?: IntFilter<"IBPartner"> | number
    monthlyRevenue?: FloatFilter<"IBPartner"> | number
    lifetimeRevenue?: FloatFilter<"IBPartner"> | number
    createdAt?: DateTimeFilter<"IBPartner"> | Date | string
    updatedAt?: DateTimeFilter<"IBPartner"> | Date | string
    approvedAt?: DateTimeNullableFilter<"IBPartner"> | Date | string | null
    approvedBy?: StringNullableFilter<"IBPartner"> | string | null
    users?: UserListRelationFilter
    anonymousAccounts?: AnonymousAccountListRelationFilter
    commissions?: IBCommissionListRelationFilter
    commissionRates?: IBCommissionRateListRelationFilter
  }, "id" | "email" | "ibCode">

  export type IBPartnerOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    companyName?: SortOrder
    contactName?: SortOrder
    phone?: SortOrder
    ibCode?: SortOrder
    domain?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    favicon?: SortOrderInput | SortOrder
    brandColor?: SortOrder
    brandName?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isApproved?: SortOrder
    currentTraders?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    companyDocument?: SortOrderInput | SortOrder
    idDocument?: SortOrderInput | SortOrder
    kycDocument?: SortOrderInput | SortOrder
    kycStatus?: SortOrder
    emailVerified?: SortOrder
    verificationCode?: SortOrderInput | SortOrder
    verificationExpiry?: SortOrderInput | SortOrder
    pricingTier?: SortOrder
    monthlyFee?: SortOrder
    traderLimit?: SortOrder
    spreadRevShare?: SortOrder
    totalTraders?: SortOrder
    activeTraders?: SortOrder
    monthlyRevenue?: SortOrder
    lifetimeRevenue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    _count?: IBPartnerCountOrderByAggregateInput
    _avg?: IBPartnerAvgOrderByAggregateInput
    _max?: IBPartnerMaxOrderByAggregateInput
    _min?: IBPartnerMinOrderByAggregateInput
    _sum?: IBPartnerSumOrderByAggregateInput
  }

  export type IBPartnerScalarWhereWithAggregatesInput = {
    AND?: IBPartnerScalarWhereWithAggregatesInput | IBPartnerScalarWhereWithAggregatesInput[]
    OR?: IBPartnerScalarWhereWithAggregatesInput[]
    NOT?: IBPartnerScalarWhereWithAggregatesInput | IBPartnerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IBPartner"> | string
    email?: StringWithAggregatesFilter<"IBPartner"> | string
    passwordHash?: StringWithAggregatesFilter<"IBPartner"> | string
    companyName?: StringWithAggregatesFilter<"IBPartner"> | string
    contactName?: StringWithAggregatesFilter<"IBPartner"> | string
    phone?: StringWithAggregatesFilter<"IBPartner"> | string
    ibCode?: StringWithAggregatesFilter<"IBPartner"> | string
    domain?: StringNullableWithAggregatesFilter<"IBPartner"> | string | null
    logo?: StringNullableWithAggregatesFilter<"IBPartner"> | string | null
    favicon?: StringNullableWithAggregatesFilter<"IBPartner"> | string | null
    brandColor?: StringWithAggregatesFilter<"IBPartner"> | string
    brandName?: StringNullableWithAggregatesFilter<"IBPartner"> | string | null
    isActive?: BoolWithAggregatesFilter<"IBPartner"> | boolean
    isApproved?: BoolWithAggregatesFilter<"IBPartner"> | boolean
    currentTraders?: StringNullableWithAggregatesFilter<"IBPartner"> | string | null
    message?: StringNullableWithAggregatesFilter<"IBPartner"> | string | null
    companyDocument?: StringNullableWithAggregatesFilter<"IBPartner"> | string | null
    idDocument?: StringNullableWithAggregatesFilter<"IBPartner"> | string | null
    kycDocument?: StringNullableWithAggregatesFilter<"IBPartner"> | string | null
    kycStatus?: StringWithAggregatesFilter<"IBPartner"> | string
    emailVerified?: BoolWithAggregatesFilter<"IBPartner"> | boolean
    verificationCode?: StringNullableWithAggregatesFilter<"IBPartner"> | string | null
    verificationExpiry?: DateTimeNullableWithAggregatesFilter<"IBPartner"> | Date | string | null
    pricingTier?: StringWithAggregatesFilter<"IBPartner"> | string
    monthlyFee?: FloatWithAggregatesFilter<"IBPartner"> | number
    traderLimit?: IntWithAggregatesFilter<"IBPartner"> | number
    spreadRevShare?: FloatWithAggregatesFilter<"IBPartner"> | number
    totalTraders?: IntWithAggregatesFilter<"IBPartner"> | number
    activeTraders?: IntWithAggregatesFilter<"IBPartner"> | number
    monthlyRevenue?: FloatWithAggregatesFilter<"IBPartner"> | number
    lifetimeRevenue?: FloatWithAggregatesFilter<"IBPartner"> | number
    createdAt?: DateTimeWithAggregatesFilter<"IBPartner"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"IBPartner"> | Date | string
    approvedAt?: DateTimeNullableWithAggregatesFilter<"IBPartner"> | Date | string | null
    approvedBy?: StringNullableWithAggregatesFilter<"IBPartner"> | string | null
  }

  export type AgentWhereInput = {
    AND?: AgentWhereInput | AgentWhereInput[]
    OR?: AgentWhereInput[]
    NOT?: AgentWhereInput | AgentWhereInput[]
    id?: StringFilter<"Agent"> | string
    userId?: StringNullableFilter<"Agent"> | string | null
    machineId?: StringFilter<"Agent"> | string
    machineName?: StringNullableFilter<"Agent"> | string | null
    isPoolAgent?: BoolFilter<"Agent"> | boolean
    managedAccounts?: StringNullableListFilter<"Agent">
    maxCapacity?: IntFilter<"Agent"> | number
    currentLoad?: IntFilter<"Agent"> | number
    vpsName?: StringNullableFilter<"Agent"> | string | null
    vpsRegion?: StringNullableFilter<"Agent"> | string | null
    vpsIp?: StringNullableFilter<"Agent"> | string | null
    mt5AccountNumber?: StringNullableFilter<"Agent"> | string | null
    mt5Broker?: StringNullableFilter<"Agent"> | string | null
    mt5ServerName?: StringNullableFilter<"Agent"> | string | null
    mt5Version?: StringNullableFilter<"Agent"> | string | null
    status?: StringFilter<"Agent"> | string
    lastHeartbeat?: DateTimeNullableFilter<"Agent"> | Date | string | null
    connectedAt?: DateTimeNullableFilter<"Agent"> | Date | string | null
    disconnectedAt?: DateTimeNullableFilter<"Agent"> | Date | string | null
    eaLoaded?: BoolFilter<"Agent"> | boolean
    eaRunning?: BoolFilter<"Agent"> | boolean
    eaName?: StringNullableFilter<"Agent"> | string | null
    chartSymbol?: StringNullableFilter<"Agent"> | string | null
    chartTimeframe?: StringNullableFilter<"Agent"> | string | null
    tradeCopierActive?: BoolFilter<"Agent"> | boolean
    isMasterAccount?: BoolFilter<"Agent"> | boolean
    masterAgentId?: StringNullableFilter<"Agent"> | string | null
    totalTrades?: IntFilter<"Agent"> | number
    profitableTrades?: IntFilter<"Agent"> | number
    losingTrades?: IntFilter<"Agent"> | number
    totalProfit?: FloatFilter<"Agent"> | number
    winRate?: FloatFilter<"Agent"> | number
    indicatorSettings?: JsonNullableFilter<"Agent">
    aiOptimizationScore?: FloatFilter<"Agent"> | number
    lastOptimizedAt?: DateTimeNullableFilter<"Agent"> | Date | string | null
    apiKey?: StringNullableFilter<"Agent"> | string | null
    osVersion?: StringNullableFilter<"Agent"> | string | null
    agentVersion?: StringNullableFilter<"Agent"> | string | null
    cpuUsage?: FloatNullableFilter<"Agent"> | number | null
    memoryUsage?: FloatNullableFilter<"Agent"> | number | null
    diskUsage?: FloatNullableFilter<"Agent"> | number | null
    mt5InstanceCount?: IntFilter<"Agent"> | number
    createdAt?: DateTimeFilter<"Agent"> | Date | string
    updatedAt?: DateTimeFilter<"Agent"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    masterAgent?: XOR<AgentNullableRelationFilter, AgentWhereInput> | null
    slaveAgents?: AgentListRelationFilter
    accountAssignments?: MT5AccountAssignmentListRelationFilter
  }

  export type AgentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    machineId?: SortOrder
    machineName?: SortOrderInput | SortOrder
    isPoolAgent?: SortOrder
    managedAccounts?: SortOrder
    maxCapacity?: SortOrder
    currentLoad?: SortOrder
    vpsName?: SortOrderInput | SortOrder
    vpsRegion?: SortOrderInput | SortOrder
    vpsIp?: SortOrderInput | SortOrder
    mt5AccountNumber?: SortOrderInput | SortOrder
    mt5Broker?: SortOrderInput | SortOrder
    mt5ServerName?: SortOrderInput | SortOrder
    mt5Version?: SortOrderInput | SortOrder
    status?: SortOrder
    lastHeartbeat?: SortOrderInput | SortOrder
    connectedAt?: SortOrderInput | SortOrder
    disconnectedAt?: SortOrderInput | SortOrder
    eaLoaded?: SortOrder
    eaRunning?: SortOrder
    eaName?: SortOrderInput | SortOrder
    chartSymbol?: SortOrderInput | SortOrder
    chartTimeframe?: SortOrderInput | SortOrder
    tradeCopierActive?: SortOrder
    isMasterAccount?: SortOrder
    masterAgentId?: SortOrderInput | SortOrder
    totalTrades?: SortOrder
    profitableTrades?: SortOrder
    losingTrades?: SortOrder
    totalProfit?: SortOrder
    winRate?: SortOrder
    indicatorSettings?: SortOrderInput | SortOrder
    aiOptimizationScore?: SortOrder
    lastOptimizedAt?: SortOrderInput | SortOrder
    apiKey?: SortOrderInput | SortOrder
    osVersion?: SortOrderInput | SortOrder
    agentVersion?: SortOrderInput | SortOrder
    cpuUsage?: SortOrderInput | SortOrder
    memoryUsage?: SortOrderInput | SortOrder
    diskUsage?: SortOrderInput | SortOrder
    mt5InstanceCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    masterAgent?: AgentOrderByWithRelationInput
    slaveAgents?: AgentOrderByRelationAggregateInput
    accountAssignments?: MT5AccountAssignmentOrderByRelationAggregateInput
  }

  export type AgentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    machineId?: string
    apiKey?: string
    AND?: AgentWhereInput | AgentWhereInput[]
    OR?: AgentWhereInput[]
    NOT?: AgentWhereInput | AgentWhereInput[]
    userId?: StringNullableFilter<"Agent"> | string | null
    machineName?: StringNullableFilter<"Agent"> | string | null
    isPoolAgent?: BoolFilter<"Agent"> | boolean
    managedAccounts?: StringNullableListFilter<"Agent">
    maxCapacity?: IntFilter<"Agent"> | number
    currentLoad?: IntFilter<"Agent"> | number
    vpsName?: StringNullableFilter<"Agent"> | string | null
    vpsRegion?: StringNullableFilter<"Agent"> | string | null
    vpsIp?: StringNullableFilter<"Agent"> | string | null
    mt5AccountNumber?: StringNullableFilter<"Agent"> | string | null
    mt5Broker?: StringNullableFilter<"Agent"> | string | null
    mt5ServerName?: StringNullableFilter<"Agent"> | string | null
    mt5Version?: StringNullableFilter<"Agent"> | string | null
    status?: StringFilter<"Agent"> | string
    lastHeartbeat?: DateTimeNullableFilter<"Agent"> | Date | string | null
    connectedAt?: DateTimeNullableFilter<"Agent"> | Date | string | null
    disconnectedAt?: DateTimeNullableFilter<"Agent"> | Date | string | null
    eaLoaded?: BoolFilter<"Agent"> | boolean
    eaRunning?: BoolFilter<"Agent"> | boolean
    eaName?: StringNullableFilter<"Agent"> | string | null
    chartSymbol?: StringNullableFilter<"Agent"> | string | null
    chartTimeframe?: StringNullableFilter<"Agent"> | string | null
    tradeCopierActive?: BoolFilter<"Agent"> | boolean
    isMasterAccount?: BoolFilter<"Agent"> | boolean
    masterAgentId?: StringNullableFilter<"Agent"> | string | null
    totalTrades?: IntFilter<"Agent"> | number
    profitableTrades?: IntFilter<"Agent"> | number
    losingTrades?: IntFilter<"Agent"> | number
    totalProfit?: FloatFilter<"Agent"> | number
    winRate?: FloatFilter<"Agent"> | number
    indicatorSettings?: JsonNullableFilter<"Agent">
    aiOptimizationScore?: FloatFilter<"Agent"> | number
    lastOptimizedAt?: DateTimeNullableFilter<"Agent"> | Date | string | null
    osVersion?: StringNullableFilter<"Agent"> | string | null
    agentVersion?: StringNullableFilter<"Agent"> | string | null
    cpuUsage?: FloatNullableFilter<"Agent"> | number | null
    memoryUsage?: FloatNullableFilter<"Agent"> | number | null
    diskUsage?: FloatNullableFilter<"Agent"> | number | null
    mt5InstanceCount?: IntFilter<"Agent"> | number
    createdAt?: DateTimeFilter<"Agent"> | Date | string
    updatedAt?: DateTimeFilter<"Agent"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    masterAgent?: XOR<AgentNullableRelationFilter, AgentWhereInput> | null
    slaveAgents?: AgentListRelationFilter
    accountAssignments?: MT5AccountAssignmentListRelationFilter
  }, "id" | "machineId" | "apiKey">

  export type AgentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    machineId?: SortOrder
    machineName?: SortOrderInput | SortOrder
    isPoolAgent?: SortOrder
    managedAccounts?: SortOrder
    maxCapacity?: SortOrder
    currentLoad?: SortOrder
    vpsName?: SortOrderInput | SortOrder
    vpsRegion?: SortOrderInput | SortOrder
    vpsIp?: SortOrderInput | SortOrder
    mt5AccountNumber?: SortOrderInput | SortOrder
    mt5Broker?: SortOrderInput | SortOrder
    mt5ServerName?: SortOrderInput | SortOrder
    mt5Version?: SortOrderInput | SortOrder
    status?: SortOrder
    lastHeartbeat?: SortOrderInput | SortOrder
    connectedAt?: SortOrderInput | SortOrder
    disconnectedAt?: SortOrderInput | SortOrder
    eaLoaded?: SortOrder
    eaRunning?: SortOrder
    eaName?: SortOrderInput | SortOrder
    chartSymbol?: SortOrderInput | SortOrder
    chartTimeframe?: SortOrderInput | SortOrder
    tradeCopierActive?: SortOrder
    isMasterAccount?: SortOrder
    masterAgentId?: SortOrderInput | SortOrder
    totalTrades?: SortOrder
    profitableTrades?: SortOrder
    losingTrades?: SortOrder
    totalProfit?: SortOrder
    winRate?: SortOrder
    indicatorSettings?: SortOrderInput | SortOrder
    aiOptimizationScore?: SortOrder
    lastOptimizedAt?: SortOrderInput | SortOrder
    apiKey?: SortOrderInput | SortOrder
    osVersion?: SortOrderInput | SortOrder
    agentVersion?: SortOrderInput | SortOrder
    cpuUsage?: SortOrderInput | SortOrder
    memoryUsage?: SortOrderInput | SortOrder
    diskUsage?: SortOrderInput | SortOrder
    mt5InstanceCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AgentCountOrderByAggregateInput
    _avg?: AgentAvgOrderByAggregateInput
    _max?: AgentMaxOrderByAggregateInput
    _min?: AgentMinOrderByAggregateInput
    _sum?: AgentSumOrderByAggregateInput
  }

  export type AgentScalarWhereWithAggregatesInput = {
    AND?: AgentScalarWhereWithAggregatesInput | AgentScalarWhereWithAggregatesInput[]
    OR?: AgentScalarWhereWithAggregatesInput[]
    NOT?: AgentScalarWhereWithAggregatesInput | AgentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Agent"> | string
    userId?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    machineId?: StringWithAggregatesFilter<"Agent"> | string
    machineName?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    isPoolAgent?: BoolWithAggregatesFilter<"Agent"> | boolean
    managedAccounts?: StringNullableListFilter<"Agent">
    maxCapacity?: IntWithAggregatesFilter<"Agent"> | number
    currentLoad?: IntWithAggregatesFilter<"Agent"> | number
    vpsName?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    vpsRegion?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    vpsIp?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    mt5AccountNumber?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    mt5Broker?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    mt5ServerName?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    mt5Version?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    status?: StringWithAggregatesFilter<"Agent"> | string
    lastHeartbeat?: DateTimeNullableWithAggregatesFilter<"Agent"> | Date | string | null
    connectedAt?: DateTimeNullableWithAggregatesFilter<"Agent"> | Date | string | null
    disconnectedAt?: DateTimeNullableWithAggregatesFilter<"Agent"> | Date | string | null
    eaLoaded?: BoolWithAggregatesFilter<"Agent"> | boolean
    eaRunning?: BoolWithAggregatesFilter<"Agent"> | boolean
    eaName?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    chartSymbol?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    chartTimeframe?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    tradeCopierActive?: BoolWithAggregatesFilter<"Agent"> | boolean
    isMasterAccount?: BoolWithAggregatesFilter<"Agent"> | boolean
    masterAgentId?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    totalTrades?: IntWithAggregatesFilter<"Agent"> | number
    profitableTrades?: IntWithAggregatesFilter<"Agent"> | number
    losingTrades?: IntWithAggregatesFilter<"Agent"> | number
    totalProfit?: FloatWithAggregatesFilter<"Agent"> | number
    winRate?: FloatWithAggregatesFilter<"Agent"> | number
    indicatorSettings?: JsonNullableWithAggregatesFilter<"Agent">
    aiOptimizationScore?: FloatWithAggregatesFilter<"Agent"> | number
    lastOptimizedAt?: DateTimeNullableWithAggregatesFilter<"Agent"> | Date | string | null
    apiKey?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    osVersion?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    agentVersion?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    cpuUsage?: FloatNullableWithAggregatesFilter<"Agent"> | number | null
    memoryUsage?: FloatNullableWithAggregatesFilter<"Agent"> | number | null
    diskUsage?: FloatNullableWithAggregatesFilter<"Agent"> | number | null
    mt5InstanceCount?: IntWithAggregatesFilter<"Agent"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Agent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Agent"> | Date | string
  }

  export type MT5AccountAssignmentWhereInput = {
    AND?: MT5AccountAssignmentWhereInput | MT5AccountAssignmentWhereInput[]
    OR?: MT5AccountAssignmentWhereInput[]
    NOT?: MT5AccountAssignmentWhereInput | MT5AccountAssignmentWhereInput[]
    id?: StringFilter<"MT5AccountAssignment"> | string
    userId?: StringFilter<"MT5AccountAssignment"> | string
    agentId?: StringFilter<"MT5AccountAssignment"> | string
    mt5AccountNumber?: StringFilter<"MT5AccountAssignment"> | string
    mt5Broker?: StringNullableFilter<"MT5AccountAssignment"> | string | null
    mt5ServerName?: StringNullableFilter<"MT5AccountAssignment"> | string | null
    assignedAt?: DateTimeFilter<"MT5AccountAssignment"> | Date | string
    isActive?: BoolFilter<"MT5AccountAssignment"> | boolean
    status?: StringFilter<"MT5AccountAssignment"> | string
    eaStatus?: StringFilter<"MT5AccountAssignment"> | string
    lastHeartbeat?: DateTimeNullableFilter<"MT5AccountAssignment"> | Date | string | null
    balance?: FloatFilter<"MT5AccountAssignment"> | number
    equity?: FloatFilter<"MT5AccountAssignment"> | number
    margin?: FloatFilter<"MT5AccountAssignment"> | number
    freeMargin?: FloatFilter<"MT5AccountAssignment"> | number
    profit?: FloatFilter<"MT5AccountAssignment"> | number
    eaLoaded?: BoolFilter<"MT5AccountAssignment"> | boolean
    eaRunning?: BoolFilter<"MT5AccountAssignment"> | boolean
    eaName?: StringNullableFilter<"MT5AccountAssignment"> | string | null
    chartSymbol?: StringNullableFilter<"MT5AccountAssignment"> | string | null
    chartTimeframe?: StringNullableFilter<"MT5AccountAssignment"> | string | null
    totalTrades?: IntFilter<"MT5AccountAssignment"> | number
    profitableTrades?: IntFilter<"MT5AccountAssignment"> | number
    losingTrades?: IntFilter<"MT5AccountAssignment"> | number
    totalProfit?: FloatFilter<"MT5AccountAssignment"> | number
    winRate?: FloatFilter<"MT5AccountAssignment"> | number
    createdAt?: DateTimeFilter<"MT5AccountAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"MT5AccountAssignment"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    agent?: XOR<AgentRelationFilter, AgentWhereInput>
  }

  export type MT5AccountAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    agentId?: SortOrder
    mt5AccountNumber?: SortOrder
    mt5Broker?: SortOrderInput | SortOrder
    mt5ServerName?: SortOrderInput | SortOrder
    assignedAt?: SortOrder
    isActive?: SortOrder
    status?: SortOrder
    eaStatus?: SortOrder
    lastHeartbeat?: SortOrderInput | SortOrder
    balance?: SortOrder
    equity?: SortOrder
    margin?: SortOrder
    freeMargin?: SortOrder
    profit?: SortOrder
    eaLoaded?: SortOrder
    eaRunning?: SortOrder
    eaName?: SortOrderInput | SortOrder
    chartSymbol?: SortOrderInput | SortOrder
    chartTimeframe?: SortOrderInput | SortOrder
    totalTrades?: SortOrder
    profitableTrades?: SortOrder
    losingTrades?: SortOrder
    totalProfit?: SortOrder
    winRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    agent?: AgentOrderByWithRelationInput
  }

  export type MT5AccountAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    mt5AccountNumber?: string
    AND?: MT5AccountAssignmentWhereInput | MT5AccountAssignmentWhereInput[]
    OR?: MT5AccountAssignmentWhereInput[]
    NOT?: MT5AccountAssignmentWhereInput | MT5AccountAssignmentWhereInput[]
    userId?: StringFilter<"MT5AccountAssignment"> | string
    agentId?: StringFilter<"MT5AccountAssignment"> | string
    mt5Broker?: StringNullableFilter<"MT5AccountAssignment"> | string | null
    mt5ServerName?: StringNullableFilter<"MT5AccountAssignment"> | string | null
    assignedAt?: DateTimeFilter<"MT5AccountAssignment"> | Date | string
    isActive?: BoolFilter<"MT5AccountAssignment"> | boolean
    status?: StringFilter<"MT5AccountAssignment"> | string
    eaStatus?: StringFilter<"MT5AccountAssignment"> | string
    lastHeartbeat?: DateTimeNullableFilter<"MT5AccountAssignment"> | Date | string | null
    balance?: FloatFilter<"MT5AccountAssignment"> | number
    equity?: FloatFilter<"MT5AccountAssignment"> | number
    margin?: FloatFilter<"MT5AccountAssignment"> | number
    freeMargin?: FloatFilter<"MT5AccountAssignment"> | number
    profit?: FloatFilter<"MT5AccountAssignment"> | number
    eaLoaded?: BoolFilter<"MT5AccountAssignment"> | boolean
    eaRunning?: BoolFilter<"MT5AccountAssignment"> | boolean
    eaName?: StringNullableFilter<"MT5AccountAssignment"> | string | null
    chartSymbol?: StringNullableFilter<"MT5AccountAssignment"> | string | null
    chartTimeframe?: StringNullableFilter<"MT5AccountAssignment"> | string | null
    totalTrades?: IntFilter<"MT5AccountAssignment"> | number
    profitableTrades?: IntFilter<"MT5AccountAssignment"> | number
    losingTrades?: IntFilter<"MT5AccountAssignment"> | number
    totalProfit?: FloatFilter<"MT5AccountAssignment"> | number
    winRate?: FloatFilter<"MT5AccountAssignment"> | number
    createdAt?: DateTimeFilter<"MT5AccountAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"MT5AccountAssignment"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    agent?: XOR<AgentRelationFilter, AgentWhereInput>
  }, "id" | "mt5AccountNumber">

  export type MT5AccountAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    agentId?: SortOrder
    mt5AccountNumber?: SortOrder
    mt5Broker?: SortOrderInput | SortOrder
    mt5ServerName?: SortOrderInput | SortOrder
    assignedAt?: SortOrder
    isActive?: SortOrder
    status?: SortOrder
    eaStatus?: SortOrder
    lastHeartbeat?: SortOrderInput | SortOrder
    balance?: SortOrder
    equity?: SortOrder
    margin?: SortOrder
    freeMargin?: SortOrder
    profit?: SortOrder
    eaLoaded?: SortOrder
    eaRunning?: SortOrder
    eaName?: SortOrderInput | SortOrder
    chartSymbol?: SortOrderInput | SortOrder
    chartTimeframe?: SortOrderInput | SortOrder
    totalTrades?: SortOrder
    profitableTrades?: SortOrder
    losingTrades?: SortOrder
    totalProfit?: SortOrder
    winRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MT5AccountAssignmentCountOrderByAggregateInput
    _avg?: MT5AccountAssignmentAvgOrderByAggregateInput
    _max?: MT5AccountAssignmentMaxOrderByAggregateInput
    _min?: MT5AccountAssignmentMinOrderByAggregateInput
    _sum?: MT5AccountAssignmentSumOrderByAggregateInput
  }

  export type MT5AccountAssignmentScalarWhereWithAggregatesInput = {
    AND?: MT5AccountAssignmentScalarWhereWithAggregatesInput | MT5AccountAssignmentScalarWhereWithAggregatesInput[]
    OR?: MT5AccountAssignmentScalarWhereWithAggregatesInput[]
    NOT?: MT5AccountAssignmentScalarWhereWithAggregatesInput | MT5AccountAssignmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MT5AccountAssignment"> | string
    userId?: StringWithAggregatesFilter<"MT5AccountAssignment"> | string
    agentId?: StringWithAggregatesFilter<"MT5AccountAssignment"> | string
    mt5AccountNumber?: StringWithAggregatesFilter<"MT5AccountAssignment"> | string
    mt5Broker?: StringNullableWithAggregatesFilter<"MT5AccountAssignment"> | string | null
    mt5ServerName?: StringNullableWithAggregatesFilter<"MT5AccountAssignment"> | string | null
    assignedAt?: DateTimeWithAggregatesFilter<"MT5AccountAssignment"> | Date | string
    isActive?: BoolWithAggregatesFilter<"MT5AccountAssignment"> | boolean
    status?: StringWithAggregatesFilter<"MT5AccountAssignment"> | string
    eaStatus?: StringWithAggregatesFilter<"MT5AccountAssignment"> | string
    lastHeartbeat?: DateTimeNullableWithAggregatesFilter<"MT5AccountAssignment"> | Date | string | null
    balance?: FloatWithAggregatesFilter<"MT5AccountAssignment"> | number
    equity?: FloatWithAggregatesFilter<"MT5AccountAssignment"> | number
    margin?: FloatWithAggregatesFilter<"MT5AccountAssignment"> | number
    freeMargin?: FloatWithAggregatesFilter<"MT5AccountAssignment"> | number
    profit?: FloatWithAggregatesFilter<"MT5AccountAssignment"> | number
    eaLoaded?: BoolWithAggregatesFilter<"MT5AccountAssignment"> | boolean
    eaRunning?: BoolWithAggregatesFilter<"MT5AccountAssignment"> | boolean
    eaName?: StringNullableWithAggregatesFilter<"MT5AccountAssignment"> | string | null
    chartSymbol?: StringNullableWithAggregatesFilter<"MT5AccountAssignment"> | string | null
    chartTimeframe?: StringNullableWithAggregatesFilter<"MT5AccountAssignment"> | string | null
    totalTrades?: IntWithAggregatesFilter<"MT5AccountAssignment"> | number
    profitableTrades?: IntWithAggregatesFilter<"MT5AccountAssignment"> | number
    losingTrades?: IntWithAggregatesFilter<"MT5AccountAssignment"> | number
    totalProfit?: FloatWithAggregatesFilter<"MT5AccountAssignment"> | number
    winRate?: FloatWithAggregatesFilter<"MT5AccountAssignment"> | number
    createdAt?: DateTimeWithAggregatesFilter<"MT5AccountAssignment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MT5AccountAssignment"> | Date | string
  }

  export type PrizeWhereInput = {
    AND?: PrizeWhereInput | PrizeWhereInput[]
    OR?: PrizeWhereInput[]
    NOT?: PrizeWhereInput | PrizeWhereInput[]
    id?: StringFilter<"Prize"> | string
    period?: StringFilter<"Prize"> | string
    rank?: IntFilter<"Prize"> | number
    amount?: FloatFilter<"Prize"> | number
    isActive?: BoolFilter<"Prize"> | boolean
    updatedBy?: StringNullableFilter<"Prize"> | string | null
    createdAt?: DateTimeFilter<"Prize"> | Date | string
    updatedAt?: DateTimeFilter<"Prize"> | Date | string
  }

  export type PrizeOrderByWithRelationInput = {
    id?: SortOrder
    period?: SortOrder
    rank?: SortOrder
    amount?: SortOrder
    isActive?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PrizeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    period_rank?: PrizePeriodRankCompoundUniqueInput
    AND?: PrizeWhereInput | PrizeWhereInput[]
    OR?: PrizeWhereInput[]
    NOT?: PrizeWhereInput | PrizeWhereInput[]
    period?: StringFilter<"Prize"> | string
    rank?: IntFilter<"Prize"> | number
    amount?: FloatFilter<"Prize"> | number
    isActive?: BoolFilter<"Prize"> | boolean
    updatedBy?: StringNullableFilter<"Prize"> | string | null
    createdAt?: DateTimeFilter<"Prize"> | Date | string
    updatedAt?: DateTimeFilter<"Prize"> | Date | string
  }, "id" | "period_rank">

  export type PrizeOrderByWithAggregationInput = {
    id?: SortOrder
    period?: SortOrder
    rank?: SortOrder
    amount?: SortOrder
    isActive?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PrizeCountOrderByAggregateInput
    _avg?: PrizeAvgOrderByAggregateInput
    _max?: PrizeMaxOrderByAggregateInput
    _min?: PrizeMinOrderByAggregateInput
    _sum?: PrizeSumOrderByAggregateInput
  }

  export type PrizeScalarWhereWithAggregatesInput = {
    AND?: PrizeScalarWhereWithAggregatesInput | PrizeScalarWhereWithAggregatesInput[]
    OR?: PrizeScalarWhereWithAggregatesInput[]
    NOT?: PrizeScalarWhereWithAggregatesInput | PrizeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Prize"> | string
    period?: StringWithAggregatesFilter<"Prize"> | string
    rank?: IntWithAggregatesFilter<"Prize"> | number
    amount?: FloatWithAggregatesFilter<"Prize"> | number
    isActive?: BoolWithAggregatesFilter<"Prize"> | boolean
    updatedBy?: StringNullableWithAggregatesFilter<"Prize"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Prize"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Prize"> | Date | string
  }

  export type GlobalSettingsWhereInput = {
    AND?: GlobalSettingsWhereInput | GlobalSettingsWhereInput[]
    OR?: GlobalSettingsWhereInput[]
    NOT?: GlobalSettingsWhereInput | GlobalSettingsWhereInput[]
    id?: StringFilter<"GlobalSettings"> | string
    settingKey?: StringFilter<"GlobalSettings"> | string
    settingValue?: StringFilter<"GlobalSettings"> | string
    description?: StringNullableFilter<"GlobalSettings"> | string | null
    updatedBy?: StringNullableFilter<"GlobalSettings"> | string | null
    updatedAt?: DateTimeFilter<"GlobalSettings"> | Date | string
    createdAt?: DateTimeFilter<"GlobalSettings"> | Date | string
  }

  export type GlobalSettingsOrderByWithRelationInput = {
    id?: SortOrder
    settingKey?: SortOrder
    settingValue?: SortOrder
    description?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type GlobalSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    settingKey?: string
    AND?: GlobalSettingsWhereInput | GlobalSettingsWhereInput[]
    OR?: GlobalSettingsWhereInput[]
    NOT?: GlobalSettingsWhereInput | GlobalSettingsWhereInput[]
    settingValue?: StringFilter<"GlobalSettings"> | string
    description?: StringNullableFilter<"GlobalSettings"> | string | null
    updatedBy?: StringNullableFilter<"GlobalSettings"> | string | null
    updatedAt?: DateTimeFilter<"GlobalSettings"> | Date | string
    createdAt?: DateTimeFilter<"GlobalSettings"> | Date | string
  }, "id" | "settingKey">

  export type GlobalSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    settingKey?: SortOrder
    settingValue?: SortOrder
    description?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _count?: GlobalSettingsCountOrderByAggregateInput
    _max?: GlobalSettingsMaxOrderByAggregateInput
    _min?: GlobalSettingsMinOrderByAggregateInput
  }

  export type GlobalSettingsScalarWhereWithAggregatesInput = {
    AND?: GlobalSettingsScalarWhereWithAggregatesInput | GlobalSettingsScalarWhereWithAggregatesInput[]
    OR?: GlobalSettingsScalarWhereWithAggregatesInput[]
    NOT?: GlobalSettingsScalarWhereWithAggregatesInput | GlobalSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GlobalSettings"> | string
    settingKey?: StringWithAggregatesFilter<"GlobalSettings"> | string
    settingValue?: StringWithAggregatesFilter<"GlobalSettings"> | string
    description?: StringNullableWithAggregatesFilter<"GlobalSettings"> | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"GlobalSettings"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"GlobalSettings"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"GlobalSettings"> | Date | string
  }

  export type AnonymousAccountWhereInput = {
    AND?: AnonymousAccountWhereInput | AnonymousAccountWhereInput[]
    OR?: AnonymousAccountWhereInput[]
    NOT?: AnonymousAccountWhereInput | AnonymousAccountWhereInput[]
    id?: StringFilter<"AnonymousAccount"> | string
    anonymousId?: StringFilter<"AnonymousAccount"> | string
    userId?: StringFilter<"AnonymousAccount"> | string
    mt5AccountNumber?: StringFilter<"AnonymousAccount"> | string
    ibPartnerId?: StringFilter<"AnonymousAccount"> | string
    isActive?: BoolFilter<"AnonymousAccount"> | boolean
    registeredAt?: DateTimeFilter<"AnonymousAccount"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    ibPartner?: XOR<IBPartnerRelationFilter, IBPartnerWhereInput>
    commissions?: IBCommissionListRelationFilter
  }

  export type AnonymousAccountOrderByWithRelationInput = {
    id?: SortOrder
    anonymousId?: SortOrder
    userId?: SortOrder
    mt5AccountNumber?: SortOrder
    ibPartnerId?: SortOrder
    isActive?: SortOrder
    registeredAt?: SortOrder
    user?: UserOrderByWithRelationInput
    ibPartner?: IBPartnerOrderByWithRelationInput
    commissions?: IBCommissionOrderByRelationAggregateInput
  }

  export type AnonymousAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    anonymousId?: string
    mt5AccountNumber?: string
    AND?: AnonymousAccountWhereInput | AnonymousAccountWhereInput[]
    OR?: AnonymousAccountWhereInput[]
    NOT?: AnonymousAccountWhereInput | AnonymousAccountWhereInput[]
    userId?: StringFilter<"AnonymousAccount"> | string
    ibPartnerId?: StringFilter<"AnonymousAccount"> | string
    isActive?: BoolFilter<"AnonymousAccount"> | boolean
    registeredAt?: DateTimeFilter<"AnonymousAccount"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    ibPartner?: XOR<IBPartnerRelationFilter, IBPartnerWhereInput>
    commissions?: IBCommissionListRelationFilter
  }, "id" | "anonymousId" | "mt5AccountNumber">

  export type AnonymousAccountOrderByWithAggregationInput = {
    id?: SortOrder
    anonymousId?: SortOrder
    userId?: SortOrder
    mt5AccountNumber?: SortOrder
    ibPartnerId?: SortOrder
    isActive?: SortOrder
    registeredAt?: SortOrder
    _count?: AnonymousAccountCountOrderByAggregateInput
    _max?: AnonymousAccountMaxOrderByAggregateInput
    _min?: AnonymousAccountMinOrderByAggregateInput
  }

  export type AnonymousAccountScalarWhereWithAggregatesInput = {
    AND?: AnonymousAccountScalarWhereWithAggregatesInput | AnonymousAccountScalarWhereWithAggregatesInput[]
    OR?: AnonymousAccountScalarWhereWithAggregatesInput[]
    NOT?: AnonymousAccountScalarWhereWithAggregatesInput | AnonymousAccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AnonymousAccount"> | string
    anonymousId?: StringWithAggregatesFilter<"AnonymousAccount"> | string
    userId?: StringWithAggregatesFilter<"AnonymousAccount"> | string
    mt5AccountNumber?: StringWithAggregatesFilter<"AnonymousAccount"> | string
    ibPartnerId?: StringWithAggregatesFilter<"AnonymousAccount"> | string
    isActive?: BoolWithAggregatesFilter<"AnonymousAccount"> | boolean
    registeredAt?: DateTimeWithAggregatesFilter<"AnonymousAccount"> | Date | string
  }

  export type IBCommissionWhereInput = {
    AND?: IBCommissionWhereInput | IBCommissionWhereInput[]
    OR?: IBCommissionWhereInput[]
    NOT?: IBCommissionWhereInput | IBCommissionWhereInput[]
    id?: StringFilter<"IBCommission"> | string
    ibPartnerId?: StringFilter<"IBCommission"> | string
    anonymousAccountId?: StringFilter<"IBCommission"> | string
    period?: DateTimeFilter<"IBCommission"> | Date | string
    periodEnd?: DateTimeFilter<"IBCommission"> | Date | string
    tradingVolume?: FloatFilter<"IBCommission"> | number
    numberOfTrades?: IntFilter<"IBCommission"> | number
    averageSpread?: FloatFilter<"IBCommission"> | number
    commissionRate?: FloatFilter<"IBCommission"> | number
    grossCommission?: FloatFilter<"IBCommission"> | number
    platformFee?: FloatFilter<"IBCommission"> | number
    netCommission?: FloatFilter<"IBCommission"> | number
    isPaid?: BoolFilter<"IBCommission"> | boolean
    paidAt?: DateTimeNullableFilter<"IBCommission"> | Date | string | null
    paymentReference?: StringNullableFilter<"IBCommission"> | string | null
    notes?: StringNullableFilter<"IBCommission"> | string | null
    createdAt?: DateTimeFilter<"IBCommission"> | Date | string
    updatedAt?: DateTimeFilter<"IBCommission"> | Date | string
    ibPartner?: XOR<IBPartnerRelationFilter, IBPartnerWhereInput>
    anonymousAccount?: XOR<AnonymousAccountRelationFilter, AnonymousAccountWhereInput>
  }

  export type IBCommissionOrderByWithRelationInput = {
    id?: SortOrder
    ibPartnerId?: SortOrder
    anonymousAccountId?: SortOrder
    period?: SortOrder
    periodEnd?: SortOrder
    tradingVolume?: SortOrder
    numberOfTrades?: SortOrder
    averageSpread?: SortOrder
    commissionRate?: SortOrder
    grossCommission?: SortOrder
    platformFee?: SortOrder
    netCommission?: SortOrder
    isPaid?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    paymentReference?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ibPartner?: IBPartnerOrderByWithRelationInput
    anonymousAccount?: AnonymousAccountOrderByWithRelationInput
  }

  export type IBCommissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    anonymousAccountId_period?: IBCommissionAnonymousAccountIdPeriodCompoundUniqueInput
    AND?: IBCommissionWhereInput | IBCommissionWhereInput[]
    OR?: IBCommissionWhereInput[]
    NOT?: IBCommissionWhereInput | IBCommissionWhereInput[]
    ibPartnerId?: StringFilter<"IBCommission"> | string
    anonymousAccountId?: StringFilter<"IBCommission"> | string
    period?: DateTimeFilter<"IBCommission"> | Date | string
    periodEnd?: DateTimeFilter<"IBCommission"> | Date | string
    tradingVolume?: FloatFilter<"IBCommission"> | number
    numberOfTrades?: IntFilter<"IBCommission"> | number
    averageSpread?: FloatFilter<"IBCommission"> | number
    commissionRate?: FloatFilter<"IBCommission"> | number
    grossCommission?: FloatFilter<"IBCommission"> | number
    platformFee?: FloatFilter<"IBCommission"> | number
    netCommission?: FloatFilter<"IBCommission"> | number
    isPaid?: BoolFilter<"IBCommission"> | boolean
    paidAt?: DateTimeNullableFilter<"IBCommission"> | Date | string | null
    paymentReference?: StringNullableFilter<"IBCommission"> | string | null
    notes?: StringNullableFilter<"IBCommission"> | string | null
    createdAt?: DateTimeFilter<"IBCommission"> | Date | string
    updatedAt?: DateTimeFilter<"IBCommission"> | Date | string
    ibPartner?: XOR<IBPartnerRelationFilter, IBPartnerWhereInput>
    anonymousAccount?: XOR<AnonymousAccountRelationFilter, AnonymousAccountWhereInput>
  }, "id" | "anonymousAccountId_period">

  export type IBCommissionOrderByWithAggregationInput = {
    id?: SortOrder
    ibPartnerId?: SortOrder
    anonymousAccountId?: SortOrder
    period?: SortOrder
    periodEnd?: SortOrder
    tradingVolume?: SortOrder
    numberOfTrades?: SortOrder
    averageSpread?: SortOrder
    commissionRate?: SortOrder
    grossCommission?: SortOrder
    platformFee?: SortOrder
    netCommission?: SortOrder
    isPaid?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    paymentReference?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IBCommissionCountOrderByAggregateInput
    _avg?: IBCommissionAvgOrderByAggregateInput
    _max?: IBCommissionMaxOrderByAggregateInput
    _min?: IBCommissionMinOrderByAggregateInput
    _sum?: IBCommissionSumOrderByAggregateInput
  }

  export type IBCommissionScalarWhereWithAggregatesInput = {
    AND?: IBCommissionScalarWhereWithAggregatesInput | IBCommissionScalarWhereWithAggregatesInput[]
    OR?: IBCommissionScalarWhereWithAggregatesInput[]
    NOT?: IBCommissionScalarWhereWithAggregatesInput | IBCommissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IBCommission"> | string
    ibPartnerId?: StringWithAggregatesFilter<"IBCommission"> | string
    anonymousAccountId?: StringWithAggregatesFilter<"IBCommission"> | string
    period?: DateTimeWithAggregatesFilter<"IBCommission"> | Date | string
    periodEnd?: DateTimeWithAggregatesFilter<"IBCommission"> | Date | string
    tradingVolume?: FloatWithAggregatesFilter<"IBCommission"> | number
    numberOfTrades?: IntWithAggregatesFilter<"IBCommission"> | number
    averageSpread?: FloatWithAggregatesFilter<"IBCommission"> | number
    commissionRate?: FloatWithAggregatesFilter<"IBCommission"> | number
    grossCommission?: FloatWithAggregatesFilter<"IBCommission"> | number
    platformFee?: FloatWithAggregatesFilter<"IBCommission"> | number
    netCommission?: FloatWithAggregatesFilter<"IBCommission"> | number
    isPaid?: BoolWithAggregatesFilter<"IBCommission"> | boolean
    paidAt?: DateTimeNullableWithAggregatesFilter<"IBCommission"> | Date | string | null
    paymentReference?: StringNullableWithAggregatesFilter<"IBCommission"> | string | null
    notes?: StringNullableWithAggregatesFilter<"IBCommission"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"IBCommission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"IBCommission"> | Date | string
  }

  export type IBCommissionRateWhereInput = {
    AND?: IBCommissionRateWhereInput | IBCommissionRateWhereInput[]
    OR?: IBCommissionRateWhereInput[]
    NOT?: IBCommissionRateWhereInput | IBCommissionRateWhereInput[]
    id?: StringFilter<"IBCommissionRate"> | string
    ibPartnerId?: StringFilter<"IBCommissionRate"> | string
    commissionRate?: FloatFilter<"IBCommissionRate"> | number
    minVolume?: FloatFilter<"IBCommissionRate"> | number
    maxVolume?: FloatNullableFilter<"IBCommissionRate"> | number | null
    effectiveFrom?: DateTimeFilter<"IBCommissionRate"> | Date | string
    effectiveTo?: DateTimeNullableFilter<"IBCommissionRate"> | Date | string | null
    isActive?: BoolFilter<"IBCommissionRate"> | boolean
    createdAt?: DateTimeFilter<"IBCommissionRate"> | Date | string
    updatedAt?: DateTimeFilter<"IBCommissionRate"> | Date | string
    ibPartner?: XOR<IBPartnerRelationFilter, IBPartnerWhereInput>
  }

  export type IBCommissionRateOrderByWithRelationInput = {
    id?: SortOrder
    ibPartnerId?: SortOrder
    commissionRate?: SortOrder
    minVolume?: SortOrder
    maxVolume?: SortOrderInput | SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ibPartner?: IBPartnerOrderByWithRelationInput
  }

  export type IBCommissionRateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IBCommissionRateWhereInput | IBCommissionRateWhereInput[]
    OR?: IBCommissionRateWhereInput[]
    NOT?: IBCommissionRateWhereInput | IBCommissionRateWhereInput[]
    ibPartnerId?: StringFilter<"IBCommissionRate"> | string
    commissionRate?: FloatFilter<"IBCommissionRate"> | number
    minVolume?: FloatFilter<"IBCommissionRate"> | number
    maxVolume?: FloatNullableFilter<"IBCommissionRate"> | number | null
    effectiveFrom?: DateTimeFilter<"IBCommissionRate"> | Date | string
    effectiveTo?: DateTimeNullableFilter<"IBCommissionRate"> | Date | string | null
    isActive?: BoolFilter<"IBCommissionRate"> | boolean
    createdAt?: DateTimeFilter<"IBCommissionRate"> | Date | string
    updatedAt?: DateTimeFilter<"IBCommissionRate"> | Date | string
    ibPartner?: XOR<IBPartnerRelationFilter, IBPartnerWhereInput>
  }, "id">

  export type IBCommissionRateOrderByWithAggregationInput = {
    id?: SortOrder
    ibPartnerId?: SortOrder
    commissionRate?: SortOrder
    minVolume?: SortOrder
    maxVolume?: SortOrderInput | SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IBCommissionRateCountOrderByAggregateInput
    _avg?: IBCommissionRateAvgOrderByAggregateInput
    _max?: IBCommissionRateMaxOrderByAggregateInput
    _min?: IBCommissionRateMinOrderByAggregateInput
    _sum?: IBCommissionRateSumOrderByAggregateInput
  }

  export type IBCommissionRateScalarWhereWithAggregatesInput = {
    AND?: IBCommissionRateScalarWhereWithAggregatesInput | IBCommissionRateScalarWhereWithAggregatesInput[]
    OR?: IBCommissionRateScalarWhereWithAggregatesInput[]
    NOT?: IBCommissionRateScalarWhereWithAggregatesInput | IBCommissionRateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IBCommissionRate"> | string
    ibPartnerId?: StringWithAggregatesFilter<"IBCommissionRate"> | string
    commissionRate?: FloatWithAggregatesFilter<"IBCommissionRate"> | number
    minVolume?: FloatWithAggregatesFilter<"IBCommissionRate"> | number
    maxVolume?: FloatNullableWithAggregatesFilter<"IBCommissionRate"> | number | null
    effectiveFrom?: DateTimeWithAggregatesFilter<"IBCommissionRate"> | Date | string
    effectiveTo?: DateTimeNullableWithAggregatesFilter<"IBCommissionRate"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"IBCommissionRate"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"IBCommissionRate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"IBCommissionRate"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    phone?: string | null
    ibCode?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    monthlyFee?: number
    totalTrades?: number
    winningTrades?: number
    losingTrades?: number
    totalProfit?: number
    totalVolume?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    lastActiveAt?: Date | string | null
    isActive?: boolean
    status?: $Enums.AccountStatus
    emailVerified?: boolean
    verificationCode?: string | null
    verificationExpiry?: Date | string | null
    ibPartner?: IBPartnerCreateNestedOneWithoutUsersInput
    mt5Accounts?: MT5AccountCreateNestedManyWithoutUserInput
    eas?: EACreateNestedManyWithoutUserInput
    trades?: TradeCreateNestedManyWithoutUserInput
    notifications?: NotificationLogCreateNestedManyWithoutUserInput
    insights?: UserInsightCreateNestedOneWithoutUserInput
    automations?: AutomationCreateNestedManyWithoutUserInput
    leaderboardStats?: LeaderboardEntryCreateNestedManyWithoutUserInput
    agents?: AgentCreateNestedManyWithoutUserInput
    accountAssignments?: MT5AccountAssignmentCreateNestedManyWithoutUserInput
    anonymousAccounts?: AnonymousAccountCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    phone?: string | null
    ibCode?: string | null
    ibPartnerId?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    monthlyFee?: number
    totalTrades?: number
    winningTrades?: number
    losingTrades?: number
    totalProfit?: number
    totalVolume?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    lastActiveAt?: Date | string | null
    isActive?: boolean
    status?: $Enums.AccountStatus
    emailVerified?: boolean
    verificationCode?: string | null
    verificationExpiry?: Date | string | null
    mt5Accounts?: MT5AccountUncheckedCreateNestedManyWithoutUserInput
    eas?: EAUncheckedCreateNestedManyWithoutUserInput
    trades?: TradeUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationLogUncheckedCreateNestedManyWithoutUserInput
    insights?: UserInsightUncheckedCreateNestedOneWithoutUserInput
    automations?: AutomationUncheckedCreateNestedManyWithoutUserInput
    leaderboardStats?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    agents?: AgentUncheckedCreateNestedManyWithoutUserInput
    accountAssignments?: MT5AccountAssignmentUncheckedCreateNestedManyWithoutUserInput
    anonymousAccounts?: AnonymousAccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ibCode?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyFee?: FloatFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    winningTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ibPartner?: IBPartnerUpdateOneWithoutUsersNestedInput
    mt5Accounts?: MT5AccountUpdateManyWithoutUserNestedInput
    eas?: EAUpdateManyWithoutUserNestedInput
    trades?: TradeUpdateManyWithoutUserNestedInput
    notifications?: NotificationLogUpdateManyWithoutUserNestedInput
    insights?: UserInsightUpdateOneWithoutUserNestedInput
    automations?: AutomationUpdateManyWithoutUserNestedInput
    leaderboardStats?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    agents?: AgentUpdateManyWithoutUserNestedInput
    accountAssignments?: MT5AccountAssignmentUpdateManyWithoutUserNestedInput
    anonymousAccounts?: AnonymousAccountUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ibCode?: NullableStringFieldUpdateOperationsInput | string | null
    ibPartnerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyFee?: FloatFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    winningTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mt5Accounts?: MT5AccountUncheckedUpdateManyWithoutUserNestedInput
    eas?: EAUncheckedUpdateManyWithoutUserNestedInput
    trades?: TradeUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationLogUncheckedUpdateManyWithoutUserNestedInput
    insights?: UserInsightUncheckedUpdateOneWithoutUserNestedInput
    automations?: AutomationUncheckedUpdateManyWithoutUserNestedInput
    leaderboardStats?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    agents?: AgentUncheckedUpdateManyWithoutUserNestedInput
    accountAssignments?: MT5AccountAssignmentUncheckedUpdateManyWithoutUserNestedInput
    anonymousAccounts?: AnonymousAccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    phone?: string | null
    ibCode?: string | null
    ibPartnerId?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    monthlyFee?: number
    totalTrades?: number
    winningTrades?: number
    losingTrades?: number
    totalProfit?: number
    totalVolume?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    lastActiveAt?: Date | string | null
    isActive?: boolean
    status?: $Enums.AccountStatus
    emailVerified?: boolean
    verificationCode?: string | null
    verificationExpiry?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ibCode?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyFee?: FloatFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    winningTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ibCode?: NullableStringFieldUpdateOperationsInput | string | null
    ibPartnerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyFee?: FloatFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    winningTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MT5AccountCreateInput = {
    id?: string
    accountNumber: string
    broker: string
    serverName: string
    login: string
    password?: string | null
    vpsIp?: string | null
    vpsPort?: number | null
    status?: $Enums.AccountStatus
    balance?: number
    equity?: number
    margin?: number
    freeMargin?: number
    isEnabledForTrading?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastSyncAt?: Date | string | null
    user: UserCreateNestedOneWithoutMt5AccountsInput
    eas?: EACreateNestedManyWithoutMt5AccountInput
    trades?: TradeCreateNestedManyWithoutMt5AccountInput
  }

  export type MT5AccountUncheckedCreateInput = {
    id?: string
    userId: string
    accountNumber: string
    broker: string
    serverName: string
    login: string
    password?: string | null
    vpsIp?: string | null
    vpsPort?: number | null
    status?: $Enums.AccountStatus
    balance?: number
    equity?: number
    margin?: number
    freeMargin?: number
    isEnabledForTrading?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastSyncAt?: Date | string | null
    eas?: EAUncheckedCreateNestedManyWithoutMt5AccountInput
    trades?: TradeUncheckedCreateNestedManyWithoutMt5AccountInput
  }

  export type MT5AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    broker?: StringFieldUpdateOperationsInput | string
    serverName?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    vpsIp?: NullableStringFieldUpdateOperationsInput | string | null
    vpsPort?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    balance?: FloatFieldUpdateOperationsInput | number
    equity?: FloatFieldUpdateOperationsInput | number
    margin?: FloatFieldUpdateOperationsInput | number
    freeMargin?: FloatFieldUpdateOperationsInput | number
    isEnabledForTrading?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutMt5AccountsNestedInput
    eas?: EAUpdateManyWithoutMt5AccountNestedInput
    trades?: TradeUpdateManyWithoutMt5AccountNestedInput
  }

  export type MT5AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    broker?: StringFieldUpdateOperationsInput | string
    serverName?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    vpsIp?: NullableStringFieldUpdateOperationsInput | string | null
    vpsPort?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    balance?: FloatFieldUpdateOperationsInput | number
    equity?: FloatFieldUpdateOperationsInput | number
    margin?: FloatFieldUpdateOperationsInput | number
    freeMargin?: FloatFieldUpdateOperationsInput | number
    isEnabledForTrading?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eas?: EAUncheckedUpdateManyWithoutMt5AccountNestedInput
    trades?: TradeUncheckedUpdateManyWithoutMt5AccountNestedInput
  }

  export type MT5AccountCreateManyInput = {
    id?: string
    userId: string
    accountNumber: string
    broker: string
    serverName: string
    login: string
    password?: string | null
    vpsIp?: string | null
    vpsPort?: number | null
    status?: $Enums.AccountStatus
    balance?: number
    equity?: number
    margin?: number
    freeMargin?: number
    isEnabledForTrading?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastSyncAt?: Date | string | null
  }

  export type MT5AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    broker?: StringFieldUpdateOperationsInput | string
    serverName?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    vpsIp?: NullableStringFieldUpdateOperationsInput | string | null
    vpsPort?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    balance?: FloatFieldUpdateOperationsInput | number
    equity?: FloatFieldUpdateOperationsInput | number
    margin?: FloatFieldUpdateOperationsInput | number
    freeMargin?: FloatFieldUpdateOperationsInput | number
    isEnabledForTrading?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MT5AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    broker?: StringFieldUpdateOperationsInput | string
    serverName?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    vpsIp?: NullableStringFieldUpdateOperationsInput | string | null
    vpsPort?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    balance?: FloatFieldUpdateOperationsInput | number
    equity?: FloatFieldUpdateOperationsInput | number
    margin?: FloatFieldUpdateOperationsInput | number
    freeMargin?: FloatFieldUpdateOperationsInput | number
    isEnabledForTrading?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EACreateInput = {
    id?: string
    name: string
    version?: string | null
    magicNumber?: number | null
    status?: $Enums.EAStatus
    safetyIndicator?: $Enums.SafetyIndicator
    indicatorScore?: number
    stoppedByIndicator?: boolean
    stoppedByIndicatorAt?: Date | string | null
    maxLotSize?: number
    riskPercent?: number
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastStartAt?: Date | string | null
    lastStopAt?: Date | string | null
    uptime?: number
    totalTrades?: number
    winningTrades?: number
    totalProfit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEasInput
    mt5Account: MT5AccountCreateNestedOneWithoutEasInput
  }

  export type EAUncheckedCreateInput = {
    id?: string
    userId: string
    mt5AccountId: string
    name: string
    version?: string | null
    magicNumber?: number | null
    status?: $Enums.EAStatus
    safetyIndicator?: $Enums.SafetyIndicator
    indicatorScore?: number
    stoppedByIndicator?: boolean
    stoppedByIndicatorAt?: Date | string | null
    maxLotSize?: number
    riskPercent?: number
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastStartAt?: Date | string | null
    lastStopAt?: Date | string | null
    uptime?: number
    totalTrades?: number
    winningTrades?: number
    totalProfit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EAUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    magicNumber?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumEAStatusFieldUpdateOperationsInput | $Enums.EAStatus
    safetyIndicator?: EnumSafetyIndicatorFieldUpdateOperationsInput | $Enums.SafetyIndicator
    indicatorScore?: FloatFieldUpdateOperationsInput | number
    stoppedByIndicator?: BoolFieldUpdateOperationsInput | boolean
    stoppedByIndicatorAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxLotSize?: FloatFieldUpdateOperationsInput | number
    riskPercent?: FloatFieldUpdateOperationsInput | number
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStopAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uptime?: IntFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    winningTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEasNestedInput
    mt5Account?: MT5AccountUpdateOneRequiredWithoutEasNestedInput
  }

  export type EAUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mt5AccountId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    magicNumber?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumEAStatusFieldUpdateOperationsInput | $Enums.EAStatus
    safetyIndicator?: EnumSafetyIndicatorFieldUpdateOperationsInput | $Enums.SafetyIndicator
    indicatorScore?: FloatFieldUpdateOperationsInput | number
    stoppedByIndicator?: BoolFieldUpdateOperationsInput | boolean
    stoppedByIndicatorAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxLotSize?: FloatFieldUpdateOperationsInput | number
    riskPercent?: FloatFieldUpdateOperationsInput | number
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStopAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uptime?: IntFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    winningTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EACreateManyInput = {
    id?: string
    userId: string
    mt5AccountId: string
    name: string
    version?: string | null
    magicNumber?: number | null
    status?: $Enums.EAStatus
    safetyIndicator?: $Enums.SafetyIndicator
    indicatorScore?: number
    stoppedByIndicator?: boolean
    stoppedByIndicatorAt?: Date | string | null
    maxLotSize?: number
    riskPercent?: number
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastStartAt?: Date | string | null
    lastStopAt?: Date | string | null
    uptime?: number
    totalTrades?: number
    winningTrades?: number
    totalProfit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EAUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    magicNumber?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumEAStatusFieldUpdateOperationsInput | $Enums.EAStatus
    safetyIndicator?: EnumSafetyIndicatorFieldUpdateOperationsInput | $Enums.SafetyIndicator
    indicatorScore?: FloatFieldUpdateOperationsInput | number
    stoppedByIndicator?: BoolFieldUpdateOperationsInput | boolean
    stoppedByIndicatorAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxLotSize?: FloatFieldUpdateOperationsInput | number
    riskPercent?: FloatFieldUpdateOperationsInput | number
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStopAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uptime?: IntFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    winningTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EAUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mt5AccountId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    magicNumber?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumEAStatusFieldUpdateOperationsInput | $Enums.EAStatus
    safetyIndicator?: EnumSafetyIndicatorFieldUpdateOperationsInput | $Enums.SafetyIndicator
    indicatorScore?: FloatFieldUpdateOperationsInput | number
    stoppedByIndicator?: BoolFieldUpdateOperationsInput | boolean
    stoppedByIndicatorAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxLotSize?: FloatFieldUpdateOperationsInput | number
    riskPercent?: FloatFieldUpdateOperationsInput | number
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStopAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uptime?: IntFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    winningTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradeCreateInput = {
    id?: string
    ticket: string
    symbol: string
    type: string
    volume: number
    openPrice: number
    openTime: Date | string
    closePrice?: number | null
    closeTime?: Date | string | null
    profit?: number
    commission?: number
    swap?: number
    magicNumber?: number | null
    comment?: string | null
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTradesInput
    mt5Account: MT5AccountCreateNestedOneWithoutTradesInput
  }

  export type TradeUncheckedCreateInput = {
    id?: string
    userId: string
    mt5AccountId: string
    ticket: string
    symbol: string
    type: string
    volume: number
    openPrice: number
    openTime: Date | string
    closePrice?: number | null
    closeTime?: Date | string | null
    profit?: number
    commission?: number
    swap?: number
    magicNumber?: number | null
    comment?: string | null
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TradeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticket?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    volume?: FloatFieldUpdateOperationsInput | number
    openPrice?: FloatFieldUpdateOperationsInput | number
    openTime?: DateTimeFieldUpdateOperationsInput | Date | string
    closePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    closeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profit?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    swap?: FloatFieldUpdateOperationsInput | number
    magicNumber?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTradesNestedInput
    mt5Account?: MT5AccountUpdateOneRequiredWithoutTradesNestedInput
  }

  export type TradeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mt5AccountId?: StringFieldUpdateOperationsInput | string
    ticket?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    volume?: FloatFieldUpdateOperationsInput | number
    openPrice?: FloatFieldUpdateOperationsInput | number
    openTime?: DateTimeFieldUpdateOperationsInput | Date | string
    closePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    closeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profit?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    swap?: FloatFieldUpdateOperationsInput | number
    magicNumber?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradeCreateManyInput = {
    id?: string
    userId: string
    mt5AccountId: string
    ticket: string
    symbol: string
    type: string
    volume: number
    openPrice: number
    openTime: Date | string
    closePrice?: number | null
    closeTime?: Date | string | null
    profit?: number
    commission?: number
    swap?: number
    magicNumber?: number | null
    comment?: string | null
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TradeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticket?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    volume?: FloatFieldUpdateOperationsInput | number
    openPrice?: FloatFieldUpdateOperationsInput | number
    openTime?: DateTimeFieldUpdateOperationsInput | Date | string
    closePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    closeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profit?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    swap?: FloatFieldUpdateOperationsInput | number
    magicNumber?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mt5AccountId?: StringFieldUpdateOperationsInput | string
    ticket?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    volume?: FloatFieldUpdateOperationsInput | number
    openPrice?: FloatFieldUpdateOperationsInput | number
    openTime?: DateTimeFieldUpdateOperationsInput | Date | string
    closePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    closeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profit?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    swap?: FloatFieldUpdateOperationsInput | number
    magicNumber?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutomationCreateInput = {
    id?: string
    name: string
    description?: string | null
    triggerType: $Enums.AutomationTriggerType
    triggerValue?: number | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    actionTypes?: AutomationCreateactionTypesInput | $Enums.AutomationActionType[]
    actionData?: NullableJsonNullValueInput | InputJsonValue
    messageSubject?: string | null
    messageBody: string
    status?: $Enums.AutomationStatus
    priority?: number
    isUserEnabled?: boolean
    totalTriggered?: number
    totalSent?: number
    totalFailed?: number
    lastTriggered?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    user?: UserCreateNestedOneWithoutAutomationsInput
    logs?: NotificationLogCreateNestedManyWithoutAutomationInput
  }

  export type AutomationUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    userId?: string | null
    triggerType: $Enums.AutomationTriggerType
    triggerValue?: number | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    actionTypes?: AutomationCreateactionTypesInput | $Enums.AutomationActionType[]
    actionData?: NullableJsonNullValueInput | InputJsonValue
    messageSubject?: string | null
    messageBody: string
    status?: $Enums.AutomationStatus
    priority?: number
    isUserEnabled?: boolean
    totalTriggered?: number
    totalSent?: number
    totalFailed?: number
    lastTriggered?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    logs?: NotificationLogUncheckedCreateNestedManyWithoutAutomationInput
  }

  export type AutomationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: EnumAutomationTriggerTypeFieldUpdateOperationsInput | $Enums.AutomationTriggerType
    triggerValue?: NullableIntFieldUpdateOperationsInput | number | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    actionTypes?: AutomationUpdateactionTypesInput | $Enums.AutomationActionType[]
    actionData?: NullableJsonNullValueInput | InputJsonValue
    messageSubject?: NullableStringFieldUpdateOperationsInput | string | null
    messageBody?: StringFieldUpdateOperationsInput | string
    status?: EnumAutomationStatusFieldUpdateOperationsInput | $Enums.AutomationStatus
    priority?: IntFieldUpdateOperationsInput | number
    isUserEnabled?: BoolFieldUpdateOperationsInput | boolean
    totalTriggered?: IntFieldUpdateOperationsInput | number
    totalSent?: IntFieldUpdateOperationsInput | number
    totalFailed?: IntFieldUpdateOperationsInput | number
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutAutomationsNestedInput
    logs?: NotificationLogUpdateManyWithoutAutomationNestedInput
  }

  export type AutomationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: EnumAutomationTriggerTypeFieldUpdateOperationsInput | $Enums.AutomationTriggerType
    triggerValue?: NullableIntFieldUpdateOperationsInput | number | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    actionTypes?: AutomationUpdateactionTypesInput | $Enums.AutomationActionType[]
    actionData?: NullableJsonNullValueInput | InputJsonValue
    messageSubject?: NullableStringFieldUpdateOperationsInput | string | null
    messageBody?: StringFieldUpdateOperationsInput | string
    status?: EnumAutomationStatusFieldUpdateOperationsInput | $Enums.AutomationStatus
    priority?: IntFieldUpdateOperationsInput | number
    isUserEnabled?: BoolFieldUpdateOperationsInput | boolean
    totalTriggered?: IntFieldUpdateOperationsInput | number
    totalSent?: IntFieldUpdateOperationsInput | number
    totalFailed?: IntFieldUpdateOperationsInput | number
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    logs?: NotificationLogUncheckedUpdateManyWithoutAutomationNestedInput
  }

  export type AutomationCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    userId?: string | null
    triggerType: $Enums.AutomationTriggerType
    triggerValue?: number | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    actionTypes?: AutomationCreateactionTypesInput | $Enums.AutomationActionType[]
    actionData?: NullableJsonNullValueInput | InputJsonValue
    messageSubject?: string | null
    messageBody: string
    status?: $Enums.AutomationStatus
    priority?: number
    isUserEnabled?: boolean
    totalTriggered?: number
    totalSent?: number
    totalFailed?: number
    lastTriggered?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
  }

  export type AutomationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: EnumAutomationTriggerTypeFieldUpdateOperationsInput | $Enums.AutomationTriggerType
    triggerValue?: NullableIntFieldUpdateOperationsInput | number | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    actionTypes?: AutomationUpdateactionTypesInput | $Enums.AutomationActionType[]
    actionData?: NullableJsonNullValueInput | InputJsonValue
    messageSubject?: NullableStringFieldUpdateOperationsInput | string | null
    messageBody?: StringFieldUpdateOperationsInput | string
    status?: EnumAutomationStatusFieldUpdateOperationsInput | $Enums.AutomationStatus
    priority?: IntFieldUpdateOperationsInput | number
    isUserEnabled?: BoolFieldUpdateOperationsInput | boolean
    totalTriggered?: IntFieldUpdateOperationsInput | number
    totalSent?: IntFieldUpdateOperationsInput | number
    totalFailed?: IntFieldUpdateOperationsInput | number
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AutomationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: EnumAutomationTriggerTypeFieldUpdateOperationsInput | $Enums.AutomationTriggerType
    triggerValue?: NullableIntFieldUpdateOperationsInput | number | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    actionTypes?: AutomationUpdateactionTypesInput | $Enums.AutomationActionType[]
    actionData?: NullableJsonNullValueInput | InputJsonValue
    messageSubject?: NullableStringFieldUpdateOperationsInput | string | null
    messageBody?: StringFieldUpdateOperationsInput | string
    status?: EnumAutomationStatusFieldUpdateOperationsInput | $Enums.AutomationStatus
    priority?: IntFieldUpdateOperationsInput | number
    isUserEnabled?: BoolFieldUpdateOperationsInput | boolean
    totalTriggered?: IntFieldUpdateOperationsInput | number
    totalSent?: IntFieldUpdateOperationsInput | number
    totalFailed?: IntFieldUpdateOperationsInput | number
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationLogCreateInput = {
    id?: string
    channel: $Enums.AutomationActionType
    recipient: string
    subject?: string | null
    message: string
    status?: $Enums.NotificationStatus
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    failedAt?: Date | string | null
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    automation: AutomationCreateNestedOneWithoutLogsInput
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationLogUncheckedCreateInput = {
    id?: string
    automationId: string
    userId: string
    channel: $Enums.AutomationActionType
    recipient: string
    subject?: string | null
    message: string
    status?: $Enums.NotificationStatus
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    failedAt?: Date | string | null
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    channel?: EnumAutomationActionTypeFieldUpdateOperationsInput | $Enums.AutomationActionType
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    automation?: AutomationUpdateOneRequiredWithoutLogsNestedInput
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    automationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    channel?: EnumAutomationActionTypeFieldUpdateOperationsInput | $Enums.AutomationActionType
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationLogCreateManyInput = {
    id?: string
    automationId: string
    userId: string
    channel: $Enums.AutomationActionType
    recipient: string
    subject?: string | null
    message: string
    status?: $Enums.NotificationStatus
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    failedAt?: Date | string | null
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    channel?: EnumAutomationActionTypeFieldUpdateOperationsInput | $Enums.AutomationActionType
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    automationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    channel?: EnumAutomationActionTypeFieldUpdateOperationsInput | $Enums.AutomationActionType
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserInsightCreateInput = {
    id?: string
    winRate?: number
    avgProfitPerTrade?: number
    avgLossPerTrade?: number
    profitFactor?: number
    maxDrawdown?: number
    sharpeRatio?: number
    tradingDaysActive?: number
    avgTradesPerDay?: number
    preferredTimeframe?: string | null
    riskLevel?: string | null
    lastTradeDate?: Date | string | null
    consecutiveWins?: number
    consecutiveLosses?: number
    daysSinceLastTrade?: number
    lifetimeValue?: number
    totalRevenue?: number
    churnRisk?: number
    engagementScore?: number
    predictedNextAction?: string | null
    retentionProbability?: number
    upsellProbability?: number
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutInsightsInput
  }

  export type UserInsightUncheckedCreateInput = {
    id?: string
    userId: string
    winRate?: number
    avgProfitPerTrade?: number
    avgLossPerTrade?: number
    profitFactor?: number
    maxDrawdown?: number
    sharpeRatio?: number
    tradingDaysActive?: number
    avgTradesPerDay?: number
    preferredTimeframe?: string | null
    riskLevel?: string | null
    lastTradeDate?: Date | string | null
    consecutiveWins?: number
    consecutiveLosses?: number
    daysSinceLastTrade?: number
    lifetimeValue?: number
    totalRevenue?: number
    churnRisk?: number
    engagementScore?: number
    predictedNextAction?: string | null
    retentionProbability?: number
    upsellProbability?: number
    updatedAt?: Date | string
  }

  export type UserInsightUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    winRate?: FloatFieldUpdateOperationsInput | number
    avgProfitPerTrade?: FloatFieldUpdateOperationsInput | number
    avgLossPerTrade?: FloatFieldUpdateOperationsInput | number
    profitFactor?: FloatFieldUpdateOperationsInput | number
    maxDrawdown?: FloatFieldUpdateOperationsInput | number
    sharpeRatio?: FloatFieldUpdateOperationsInput | number
    tradingDaysActive?: IntFieldUpdateOperationsInput | number
    avgTradesPerDay?: FloatFieldUpdateOperationsInput | number
    preferredTimeframe?: NullableStringFieldUpdateOperationsInput | string | null
    riskLevel?: NullableStringFieldUpdateOperationsInput | string | null
    lastTradeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consecutiveWins?: IntFieldUpdateOperationsInput | number
    consecutiveLosses?: IntFieldUpdateOperationsInput | number
    daysSinceLastTrade?: IntFieldUpdateOperationsInput | number
    lifetimeValue?: FloatFieldUpdateOperationsInput | number
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    churnRisk?: FloatFieldUpdateOperationsInput | number
    engagementScore?: FloatFieldUpdateOperationsInput | number
    predictedNextAction?: NullableStringFieldUpdateOperationsInput | string | null
    retentionProbability?: FloatFieldUpdateOperationsInput | number
    upsellProbability?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInsightsNestedInput
  }

  export type UserInsightUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    winRate?: FloatFieldUpdateOperationsInput | number
    avgProfitPerTrade?: FloatFieldUpdateOperationsInput | number
    avgLossPerTrade?: FloatFieldUpdateOperationsInput | number
    profitFactor?: FloatFieldUpdateOperationsInput | number
    maxDrawdown?: FloatFieldUpdateOperationsInput | number
    sharpeRatio?: FloatFieldUpdateOperationsInput | number
    tradingDaysActive?: IntFieldUpdateOperationsInput | number
    avgTradesPerDay?: FloatFieldUpdateOperationsInput | number
    preferredTimeframe?: NullableStringFieldUpdateOperationsInput | string | null
    riskLevel?: NullableStringFieldUpdateOperationsInput | string | null
    lastTradeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consecutiveWins?: IntFieldUpdateOperationsInput | number
    consecutiveLosses?: IntFieldUpdateOperationsInput | number
    daysSinceLastTrade?: IntFieldUpdateOperationsInput | number
    lifetimeValue?: FloatFieldUpdateOperationsInput | number
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    churnRisk?: FloatFieldUpdateOperationsInput | number
    engagementScore?: FloatFieldUpdateOperationsInput | number
    predictedNextAction?: NullableStringFieldUpdateOperationsInput | string | null
    retentionProbability?: FloatFieldUpdateOperationsInput | number
    upsellProbability?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserInsightCreateManyInput = {
    id?: string
    userId: string
    winRate?: number
    avgProfitPerTrade?: number
    avgLossPerTrade?: number
    profitFactor?: number
    maxDrawdown?: number
    sharpeRatio?: number
    tradingDaysActive?: number
    avgTradesPerDay?: number
    preferredTimeframe?: string | null
    riskLevel?: string | null
    lastTradeDate?: Date | string | null
    consecutiveWins?: number
    consecutiveLosses?: number
    daysSinceLastTrade?: number
    lifetimeValue?: number
    totalRevenue?: number
    churnRisk?: number
    engagementScore?: number
    predictedNextAction?: string | null
    retentionProbability?: number
    upsellProbability?: number
    updatedAt?: Date | string
  }

  export type UserInsightUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    winRate?: FloatFieldUpdateOperationsInput | number
    avgProfitPerTrade?: FloatFieldUpdateOperationsInput | number
    avgLossPerTrade?: FloatFieldUpdateOperationsInput | number
    profitFactor?: FloatFieldUpdateOperationsInput | number
    maxDrawdown?: FloatFieldUpdateOperationsInput | number
    sharpeRatio?: FloatFieldUpdateOperationsInput | number
    tradingDaysActive?: IntFieldUpdateOperationsInput | number
    avgTradesPerDay?: FloatFieldUpdateOperationsInput | number
    preferredTimeframe?: NullableStringFieldUpdateOperationsInput | string | null
    riskLevel?: NullableStringFieldUpdateOperationsInput | string | null
    lastTradeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consecutiveWins?: IntFieldUpdateOperationsInput | number
    consecutiveLosses?: IntFieldUpdateOperationsInput | number
    daysSinceLastTrade?: IntFieldUpdateOperationsInput | number
    lifetimeValue?: FloatFieldUpdateOperationsInput | number
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    churnRisk?: FloatFieldUpdateOperationsInput | number
    engagementScore?: FloatFieldUpdateOperationsInput | number
    predictedNextAction?: NullableStringFieldUpdateOperationsInput | string | null
    retentionProbability?: FloatFieldUpdateOperationsInput | number
    upsellProbability?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserInsightUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    winRate?: FloatFieldUpdateOperationsInput | number
    avgProfitPerTrade?: FloatFieldUpdateOperationsInput | number
    avgLossPerTrade?: FloatFieldUpdateOperationsInput | number
    profitFactor?: FloatFieldUpdateOperationsInput | number
    maxDrawdown?: FloatFieldUpdateOperationsInput | number
    sharpeRatio?: FloatFieldUpdateOperationsInput | number
    tradingDaysActive?: IntFieldUpdateOperationsInput | number
    avgTradesPerDay?: FloatFieldUpdateOperationsInput | number
    preferredTimeframe?: NullableStringFieldUpdateOperationsInput | string | null
    riskLevel?: NullableStringFieldUpdateOperationsInput | string | null
    lastTradeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consecutiveWins?: IntFieldUpdateOperationsInput | number
    consecutiveLosses?: IntFieldUpdateOperationsInput | number
    daysSinceLastTrade?: IntFieldUpdateOperationsInput | number
    lifetimeValue?: FloatFieldUpdateOperationsInput | number
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    churnRisk?: FloatFieldUpdateOperationsInput | number
    engagementScore?: FloatFieldUpdateOperationsInput | number
    predictedNextAction?: NullableStringFieldUpdateOperationsInput | string | null
    retentionProbability?: FloatFieldUpdateOperationsInput | number
    upsellProbability?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemLogCreateInput = {
    id?: string
    level: string
    component: string
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SystemLogUncheckedCreateInput = {
    id?: string
    level: string
    component: string
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SystemLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    component?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    component?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemLogCreateManyInput = {
    id?: string
    level: string
    component: string
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SystemLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    component?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    component?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketConditionCreateInput = {
    id?: string
    volatility: number
    spread: number
    trend: string
    newsImpact?: boolean
    safetyIndicator: $Enums.SafetyIndicator
    reason: string
    timestamp?: Date | string
  }

  export type MarketConditionUncheckedCreateInput = {
    id?: string
    volatility: number
    spread: number
    trend: string
    newsImpact?: boolean
    safetyIndicator: $Enums.SafetyIndicator
    reason: string
    timestamp?: Date | string
  }

  export type MarketConditionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    volatility?: FloatFieldUpdateOperationsInput | number
    spread?: FloatFieldUpdateOperationsInput | number
    trend?: StringFieldUpdateOperationsInput | string
    newsImpact?: BoolFieldUpdateOperationsInput | boolean
    safetyIndicator?: EnumSafetyIndicatorFieldUpdateOperationsInput | $Enums.SafetyIndicator
    reason?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketConditionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    volatility?: FloatFieldUpdateOperationsInput | number
    spread?: FloatFieldUpdateOperationsInput | number
    trend?: StringFieldUpdateOperationsInput | string
    newsImpact?: BoolFieldUpdateOperationsInput | boolean
    safetyIndicator?: EnumSafetyIndicatorFieldUpdateOperationsInput | $Enums.SafetyIndicator
    reason?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketConditionCreateManyInput = {
    id?: string
    volatility: number
    spread: number
    trend: string
    newsImpact?: boolean
    safetyIndicator: $Enums.SafetyIndicator
    reason: string
    timestamp?: Date | string
  }

  export type MarketConditionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    volatility?: FloatFieldUpdateOperationsInput | number
    spread?: FloatFieldUpdateOperationsInput | number
    trend?: StringFieldUpdateOperationsInput | string
    newsImpact?: BoolFieldUpdateOperationsInput | boolean
    safetyIndicator?: EnumSafetyIndicatorFieldUpdateOperationsInput | $Enums.SafetyIndicator
    reason?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketConditionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    volatility?: FloatFieldUpdateOperationsInput | number
    spread?: FloatFieldUpdateOperationsInput | number
    trend?: StringFieldUpdateOperationsInput | string
    newsImpact?: BoolFieldUpdateOperationsInput | boolean
    safetyIndicator?: EnumSafetyIndicatorFieldUpdateOperationsInput | $Enums.SafetyIndicator
    reason?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaderboardEntryCreateInput = {
    id?: string
    period: string
    periodDate: Date | string
    trades?: number
    winningTrades?: number
    losingTrades?: number
    profit?: number
    volume?: number
    winRate?: number
    rank?: number | null
    previousRank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLeaderboardStatsInput
  }

  export type LeaderboardEntryUncheckedCreateInput = {
    id?: string
    userId: string
    period: string
    periodDate: Date | string
    trades?: number
    winningTrades?: number
    losingTrades?: number
    profit?: number
    volume?: number
    winRate?: number
    rank?: number | null
    previousRank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaderboardEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trades?: IntFieldUpdateOperationsInput | number
    winningTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    profit?: FloatFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    previousRank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLeaderboardStatsNestedInput
  }

  export type LeaderboardEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trades?: IntFieldUpdateOperationsInput | number
    winningTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    profit?: FloatFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    previousRank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaderboardEntryCreateManyInput = {
    id?: string
    userId: string
    period: string
    periodDate: Date | string
    trades?: number
    winningTrades?: number
    losingTrades?: number
    profit?: number
    volume?: number
    winRate?: number
    rank?: number | null
    previousRank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaderboardEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trades?: IntFieldUpdateOperationsInput | number
    winningTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    profit?: FloatFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    previousRank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaderboardEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trades?: IntFieldUpdateOperationsInput | number
    winningTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    profit?: FloatFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    previousRank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IBPartnerCreateInput = {
    id?: string
    email: string
    passwordHash: string
    companyName: string
    contactName: string
    phone: string
    ibCode: string
    domain?: string | null
    logo?: string | null
    favicon?: string | null
    brandColor?: string
    brandName?: string | null
    isActive?: boolean
    isApproved?: boolean
    currentTraders?: string | null
    message?: string | null
    companyDocument?: string | null
    idDocument?: string | null
    kycDocument?: string | null
    kycStatus?: string
    emailVerified?: boolean
    verificationCode?: string | null
    verificationExpiry?: Date | string | null
    pricingTier?: string
    monthlyFee?: number
    traderLimit?: number
    spreadRevShare?: number
    totalTraders?: number
    activeTraders?: number
    monthlyRevenue?: number
    lifetimeRevenue?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedAt?: Date | string | null
    approvedBy?: string | null
    users?: UserCreateNestedManyWithoutIbPartnerInput
    anonymousAccounts?: AnonymousAccountCreateNestedManyWithoutIbPartnerInput
    commissions?: IBCommissionCreateNestedManyWithoutIbPartnerInput
    commissionRates?: IBCommissionRateCreateNestedManyWithoutIbPartnerInput
  }

  export type IBPartnerUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash: string
    companyName: string
    contactName: string
    phone: string
    ibCode: string
    domain?: string | null
    logo?: string | null
    favicon?: string | null
    brandColor?: string
    brandName?: string | null
    isActive?: boolean
    isApproved?: boolean
    currentTraders?: string | null
    message?: string | null
    companyDocument?: string | null
    idDocument?: string | null
    kycDocument?: string | null
    kycStatus?: string
    emailVerified?: boolean
    verificationCode?: string | null
    verificationExpiry?: Date | string | null
    pricingTier?: string
    monthlyFee?: number
    traderLimit?: number
    spreadRevShare?: number
    totalTraders?: number
    activeTraders?: number
    monthlyRevenue?: number
    lifetimeRevenue?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedAt?: Date | string | null
    approvedBy?: string | null
    users?: UserUncheckedCreateNestedManyWithoutIbPartnerInput
    anonymousAccounts?: AnonymousAccountUncheckedCreateNestedManyWithoutIbPartnerInput
    commissions?: IBCommissionUncheckedCreateNestedManyWithoutIbPartnerInput
    commissionRates?: IBCommissionRateUncheckedCreateNestedManyWithoutIbPartnerInput
  }

  export type IBPartnerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    ibCode?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    brandColor?: StringFieldUpdateOperationsInput | string
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    currentTraders?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    companyDocument?: NullableStringFieldUpdateOperationsInput | string | null
    idDocument?: NullableStringFieldUpdateOperationsInput | string | null
    kycDocument?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pricingTier?: StringFieldUpdateOperationsInput | string
    monthlyFee?: FloatFieldUpdateOperationsInput | number
    traderLimit?: IntFieldUpdateOperationsInput | number
    spreadRevShare?: FloatFieldUpdateOperationsInput | number
    totalTraders?: IntFieldUpdateOperationsInput | number
    activeTraders?: IntFieldUpdateOperationsInput | number
    monthlyRevenue?: FloatFieldUpdateOperationsInput | number
    lifetimeRevenue?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUpdateManyWithoutIbPartnerNestedInput
    anonymousAccounts?: AnonymousAccountUpdateManyWithoutIbPartnerNestedInput
    commissions?: IBCommissionUpdateManyWithoutIbPartnerNestedInput
    commissionRates?: IBCommissionRateUpdateManyWithoutIbPartnerNestedInput
  }

  export type IBPartnerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    ibCode?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    brandColor?: StringFieldUpdateOperationsInput | string
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    currentTraders?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    companyDocument?: NullableStringFieldUpdateOperationsInput | string | null
    idDocument?: NullableStringFieldUpdateOperationsInput | string | null
    kycDocument?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pricingTier?: StringFieldUpdateOperationsInput | string
    monthlyFee?: FloatFieldUpdateOperationsInput | number
    traderLimit?: IntFieldUpdateOperationsInput | number
    spreadRevShare?: FloatFieldUpdateOperationsInput | number
    totalTraders?: IntFieldUpdateOperationsInput | number
    activeTraders?: IntFieldUpdateOperationsInput | number
    monthlyRevenue?: FloatFieldUpdateOperationsInput | number
    lifetimeRevenue?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutIbPartnerNestedInput
    anonymousAccounts?: AnonymousAccountUncheckedUpdateManyWithoutIbPartnerNestedInput
    commissions?: IBCommissionUncheckedUpdateManyWithoutIbPartnerNestedInput
    commissionRates?: IBCommissionRateUncheckedUpdateManyWithoutIbPartnerNestedInput
  }

  export type IBPartnerCreateManyInput = {
    id?: string
    email: string
    passwordHash: string
    companyName: string
    contactName: string
    phone: string
    ibCode: string
    domain?: string | null
    logo?: string | null
    favicon?: string | null
    brandColor?: string
    brandName?: string | null
    isActive?: boolean
    isApproved?: boolean
    currentTraders?: string | null
    message?: string | null
    companyDocument?: string | null
    idDocument?: string | null
    kycDocument?: string | null
    kycStatus?: string
    emailVerified?: boolean
    verificationCode?: string | null
    verificationExpiry?: Date | string | null
    pricingTier?: string
    monthlyFee?: number
    traderLimit?: number
    spreadRevShare?: number
    totalTraders?: number
    activeTraders?: number
    monthlyRevenue?: number
    lifetimeRevenue?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedAt?: Date | string | null
    approvedBy?: string | null
  }

  export type IBPartnerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    ibCode?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    brandColor?: StringFieldUpdateOperationsInput | string
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    currentTraders?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    companyDocument?: NullableStringFieldUpdateOperationsInput | string | null
    idDocument?: NullableStringFieldUpdateOperationsInput | string | null
    kycDocument?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pricingTier?: StringFieldUpdateOperationsInput | string
    monthlyFee?: FloatFieldUpdateOperationsInput | number
    traderLimit?: IntFieldUpdateOperationsInput | number
    spreadRevShare?: FloatFieldUpdateOperationsInput | number
    totalTraders?: IntFieldUpdateOperationsInput | number
    activeTraders?: IntFieldUpdateOperationsInput | number
    monthlyRevenue?: FloatFieldUpdateOperationsInput | number
    lifetimeRevenue?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IBPartnerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    ibCode?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    brandColor?: StringFieldUpdateOperationsInput | string
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    currentTraders?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    companyDocument?: NullableStringFieldUpdateOperationsInput | string | null
    idDocument?: NullableStringFieldUpdateOperationsInput | string | null
    kycDocument?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pricingTier?: StringFieldUpdateOperationsInput | string
    monthlyFee?: FloatFieldUpdateOperationsInput | number
    traderLimit?: IntFieldUpdateOperationsInput | number
    spreadRevShare?: FloatFieldUpdateOperationsInput | number
    totalTraders?: IntFieldUpdateOperationsInput | number
    activeTraders?: IntFieldUpdateOperationsInput | number
    monthlyRevenue?: FloatFieldUpdateOperationsInput | number
    lifetimeRevenue?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AgentCreateInput = {
    id?: string
    machineId: string
    machineName?: string | null
    isPoolAgent?: boolean
    managedAccounts?: AgentCreatemanagedAccountsInput | string[]
    maxCapacity?: number
    currentLoad?: number
    vpsName?: string | null
    vpsRegion?: string | null
    vpsIp?: string | null
    mt5AccountNumber?: string | null
    mt5Broker?: string | null
    mt5ServerName?: string | null
    mt5Version?: string | null
    status?: string
    lastHeartbeat?: Date | string | null
    connectedAt?: Date | string | null
    disconnectedAt?: Date | string | null
    eaLoaded?: boolean
    eaRunning?: boolean
    eaName?: string | null
    chartSymbol?: string | null
    chartTimeframe?: string | null
    tradeCopierActive?: boolean
    isMasterAccount?: boolean
    totalTrades?: number
    profitableTrades?: number
    losingTrades?: number
    totalProfit?: number
    winRate?: number
    indicatorSettings?: NullableJsonNullValueInput | InputJsonValue
    aiOptimizationScore?: number
    lastOptimizedAt?: Date | string | null
    apiKey?: string | null
    osVersion?: string | null
    agentVersion?: string | null
    cpuUsage?: number | null
    memoryUsage?: number | null
    diskUsage?: number | null
    mt5InstanceCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutAgentsInput
    masterAgent?: AgentCreateNestedOneWithoutSlaveAgentsInput
    slaveAgents?: AgentCreateNestedManyWithoutMasterAgentInput
    accountAssignments?: MT5AccountAssignmentCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateInput = {
    id?: string
    userId?: string | null
    machineId: string
    machineName?: string | null
    isPoolAgent?: boolean
    managedAccounts?: AgentCreatemanagedAccountsInput | string[]
    maxCapacity?: number
    currentLoad?: number
    vpsName?: string | null
    vpsRegion?: string | null
    vpsIp?: string | null
    mt5AccountNumber?: string | null
    mt5Broker?: string | null
    mt5ServerName?: string | null
    mt5Version?: string | null
    status?: string
    lastHeartbeat?: Date | string | null
    connectedAt?: Date | string | null
    disconnectedAt?: Date | string | null
    eaLoaded?: boolean
    eaRunning?: boolean
    eaName?: string | null
    chartSymbol?: string | null
    chartTimeframe?: string | null
    tradeCopierActive?: boolean
    isMasterAccount?: boolean
    masterAgentId?: string | null
    totalTrades?: number
    profitableTrades?: number
    losingTrades?: number
    totalProfit?: number
    winRate?: number
    indicatorSettings?: NullableJsonNullValueInput | InputJsonValue
    aiOptimizationScore?: number
    lastOptimizedAt?: Date | string | null
    apiKey?: string | null
    osVersion?: string | null
    agentVersion?: string | null
    cpuUsage?: number | null
    memoryUsage?: number | null
    diskUsage?: number | null
    mt5InstanceCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slaveAgents?: AgentUncheckedCreateNestedManyWithoutMasterAgentInput
    accountAssignments?: MT5AccountAssignmentUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    machineId?: StringFieldUpdateOperationsInput | string
    machineName?: NullableStringFieldUpdateOperationsInput | string | null
    isPoolAgent?: BoolFieldUpdateOperationsInput | boolean
    managedAccounts?: AgentUpdatemanagedAccountsInput | string[]
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentLoad?: IntFieldUpdateOperationsInput | number
    vpsName?: NullableStringFieldUpdateOperationsInput | string | null
    vpsRegion?: NullableStringFieldUpdateOperationsInput | string | null
    vpsIp?: NullableStringFieldUpdateOperationsInput | string | null
    mt5AccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    mt5Broker?: NullableStringFieldUpdateOperationsInput | string | null
    mt5ServerName?: NullableStringFieldUpdateOperationsInput | string | null
    mt5Version?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastHeartbeat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    connectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eaLoaded?: BoolFieldUpdateOperationsInput | boolean
    eaRunning?: BoolFieldUpdateOperationsInput | boolean
    eaName?: NullableStringFieldUpdateOperationsInput | string | null
    chartSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    chartTimeframe?: NullableStringFieldUpdateOperationsInput | string | null
    tradeCopierActive?: BoolFieldUpdateOperationsInput | boolean
    isMasterAccount?: BoolFieldUpdateOperationsInput | boolean
    totalTrades?: IntFieldUpdateOperationsInput | number
    profitableTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    indicatorSettings?: NullableJsonNullValueInput | InputJsonValue
    aiOptimizationScore?: FloatFieldUpdateOperationsInput | number
    lastOptimizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    agentVersion?: NullableStringFieldUpdateOperationsInput | string | null
    cpuUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    memoryUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    diskUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    mt5InstanceCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAgentsNestedInput
    masterAgent?: AgentUpdateOneWithoutSlaveAgentsNestedInput
    slaveAgents?: AgentUpdateManyWithoutMasterAgentNestedInput
    accountAssignments?: MT5AccountAssignmentUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    machineId?: StringFieldUpdateOperationsInput | string
    machineName?: NullableStringFieldUpdateOperationsInput | string | null
    isPoolAgent?: BoolFieldUpdateOperationsInput | boolean
    managedAccounts?: AgentUpdatemanagedAccountsInput | string[]
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentLoad?: IntFieldUpdateOperationsInput | number
    vpsName?: NullableStringFieldUpdateOperationsInput | string | null
    vpsRegion?: NullableStringFieldUpdateOperationsInput | string | null
    vpsIp?: NullableStringFieldUpdateOperationsInput | string | null
    mt5AccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    mt5Broker?: NullableStringFieldUpdateOperationsInput | string | null
    mt5ServerName?: NullableStringFieldUpdateOperationsInput | string | null
    mt5Version?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastHeartbeat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    connectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eaLoaded?: BoolFieldUpdateOperationsInput | boolean
    eaRunning?: BoolFieldUpdateOperationsInput | boolean
    eaName?: NullableStringFieldUpdateOperationsInput | string | null
    chartSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    chartTimeframe?: NullableStringFieldUpdateOperationsInput | string | null
    tradeCopierActive?: BoolFieldUpdateOperationsInput | boolean
    isMasterAccount?: BoolFieldUpdateOperationsInput | boolean
    masterAgentId?: NullableStringFieldUpdateOperationsInput | string | null
    totalTrades?: IntFieldUpdateOperationsInput | number
    profitableTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    indicatorSettings?: NullableJsonNullValueInput | InputJsonValue
    aiOptimizationScore?: FloatFieldUpdateOperationsInput | number
    lastOptimizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    agentVersion?: NullableStringFieldUpdateOperationsInput | string | null
    cpuUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    memoryUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    diskUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    mt5InstanceCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slaveAgents?: AgentUncheckedUpdateManyWithoutMasterAgentNestedInput
    accountAssignments?: MT5AccountAssignmentUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AgentCreateManyInput = {
    id?: string
    userId?: string | null
    machineId: string
    machineName?: string | null
    isPoolAgent?: boolean
    managedAccounts?: AgentCreatemanagedAccountsInput | string[]
    maxCapacity?: number
    currentLoad?: number
    vpsName?: string | null
    vpsRegion?: string | null
    vpsIp?: string | null
    mt5AccountNumber?: string | null
    mt5Broker?: string | null
    mt5ServerName?: string | null
    mt5Version?: string | null
    status?: string
    lastHeartbeat?: Date | string | null
    connectedAt?: Date | string | null
    disconnectedAt?: Date | string | null
    eaLoaded?: boolean
    eaRunning?: boolean
    eaName?: string | null
    chartSymbol?: string | null
    chartTimeframe?: string | null
    tradeCopierActive?: boolean
    isMasterAccount?: boolean
    masterAgentId?: string | null
    totalTrades?: number
    profitableTrades?: number
    losingTrades?: number
    totalProfit?: number
    winRate?: number
    indicatorSettings?: NullableJsonNullValueInput | InputJsonValue
    aiOptimizationScore?: number
    lastOptimizedAt?: Date | string | null
    apiKey?: string | null
    osVersion?: string | null
    agentVersion?: string | null
    cpuUsage?: number | null
    memoryUsage?: number | null
    diskUsage?: number | null
    mt5InstanceCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    machineId?: StringFieldUpdateOperationsInput | string
    machineName?: NullableStringFieldUpdateOperationsInput | string | null
    isPoolAgent?: BoolFieldUpdateOperationsInput | boolean
    managedAccounts?: AgentUpdatemanagedAccountsInput | string[]
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentLoad?: IntFieldUpdateOperationsInput | number
    vpsName?: NullableStringFieldUpdateOperationsInput | string | null
    vpsRegion?: NullableStringFieldUpdateOperationsInput | string | null
    vpsIp?: NullableStringFieldUpdateOperationsInput | string | null
    mt5AccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    mt5Broker?: NullableStringFieldUpdateOperationsInput | string | null
    mt5ServerName?: NullableStringFieldUpdateOperationsInput | string | null
    mt5Version?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastHeartbeat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    connectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eaLoaded?: BoolFieldUpdateOperationsInput | boolean
    eaRunning?: BoolFieldUpdateOperationsInput | boolean
    eaName?: NullableStringFieldUpdateOperationsInput | string | null
    chartSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    chartTimeframe?: NullableStringFieldUpdateOperationsInput | string | null
    tradeCopierActive?: BoolFieldUpdateOperationsInput | boolean
    isMasterAccount?: BoolFieldUpdateOperationsInput | boolean
    totalTrades?: IntFieldUpdateOperationsInput | number
    profitableTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    indicatorSettings?: NullableJsonNullValueInput | InputJsonValue
    aiOptimizationScore?: FloatFieldUpdateOperationsInput | number
    lastOptimizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    agentVersion?: NullableStringFieldUpdateOperationsInput | string | null
    cpuUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    memoryUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    diskUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    mt5InstanceCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    machineId?: StringFieldUpdateOperationsInput | string
    machineName?: NullableStringFieldUpdateOperationsInput | string | null
    isPoolAgent?: BoolFieldUpdateOperationsInput | boolean
    managedAccounts?: AgentUpdatemanagedAccountsInput | string[]
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentLoad?: IntFieldUpdateOperationsInput | number
    vpsName?: NullableStringFieldUpdateOperationsInput | string | null
    vpsRegion?: NullableStringFieldUpdateOperationsInput | string | null
    vpsIp?: NullableStringFieldUpdateOperationsInput | string | null
    mt5AccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    mt5Broker?: NullableStringFieldUpdateOperationsInput | string | null
    mt5ServerName?: NullableStringFieldUpdateOperationsInput | string | null
    mt5Version?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastHeartbeat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    connectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eaLoaded?: BoolFieldUpdateOperationsInput | boolean
    eaRunning?: BoolFieldUpdateOperationsInput | boolean
    eaName?: NullableStringFieldUpdateOperationsInput | string | null
    chartSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    chartTimeframe?: NullableStringFieldUpdateOperationsInput | string | null
    tradeCopierActive?: BoolFieldUpdateOperationsInput | boolean
    isMasterAccount?: BoolFieldUpdateOperationsInput | boolean
    masterAgentId?: NullableStringFieldUpdateOperationsInput | string | null
    totalTrades?: IntFieldUpdateOperationsInput | number
    profitableTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    indicatorSettings?: NullableJsonNullValueInput | InputJsonValue
    aiOptimizationScore?: FloatFieldUpdateOperationsInput | number
    lastOptimizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    agentVersion?: NullableStringFieldUpdateOperationsInput | string | null
    cpuUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    memoryUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    diskUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    mt5InstanceCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MT5AccountAssignmentCreateInput = {
    id?: string
    mt5AccountNumber: string
    mt5Broker?: string | null
    mt5ServerName?: string | null
    assignedAt?: Date | string
    isActive?: boolean
    status?: string
    eaStatus?: string
    lastHeartbeat?: Date | string | null
    balance?: number
    equity?: number
    margin?: number
    freeMargin?: number
    profit?: number
    eaLoaded?: boolean
    eaRunning?: boolean
    eaName?: string | null
    chartSymbol?: string | null
    chartTimeframe?: string | null
    totalTrades?: number
    profitableTrades?: number
    losingTrades?: number
    totalProfit?: number
    winRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAccountAssignmentsInput
    agent: AgentCreateNestedOneWithoutAccountAssignmentsInput
  }

  export type MT5AccountAssignmentUncheckedCreateInput = {
    id?: string
    userId: string
    agentId: string
    mt5AccountNumber: string
    mt5Broker?: string | null
    mt5ServerName?: string | null
    assignedAt?: Date | string
    isActive?: boolean
    status?: string
    eaStatus?: string
    lastHeartbeat?: Date | string | null
    balance?: number
    equity?: number
    margin?: number
    freeMargin?: number
    profit?: number
    eaLoaded?: boolean
    eaRunning?: boolean
    eaName?: string | null
    chartSymbol?: string | null
    chartTimeframe?: string | null
    totalTrades?: number
    profitableTrades?: number
    losingTrades?: number
    totalProfit?: number
    winRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MT5AccountAssignmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mt5AccountNumber?: StringFieldUpdateOperationsInput | string
    mt5Broker?: NullableStringFieldUpdateOperationsInput | string | null
    mt5ServerName?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    eaStatus?: StringFieldUpdateOperationsInput | string
    lastHeartbeat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    equity?: FloatFieldUpdateOperationsInput | number
    margin?: FloatFieldUpdateOperationsInput | number
    freeMargin?: FloatFieldUpdateOperationsInput | number
    profit?: FloatFieldUpdateOperationsInput | number
    eaLoaded?: BoolFieldUpdateOperationsInput | boolean
    eaRunning?: BoolFieldUpdateOperationsInput | boolean
    eaName?: NullableStringFieldUpdateOperationsInput | string | null
    chartSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    chartTimeframe?: NullableStringFieldUpdateOperationsInput | string | null
    totalTrades?: IntFieldUpdateOperationsInput | number
    profitableTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountAssignmentsNestedInput
    agent?: AgentUpdateOneRequiredWithoutAccountAssignmentsNestedInput
  }

  export type MT5AccountAssignmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    mt5AccountNumber?: StringFieldUpdateOperationsInput | string
    mt5Broker?: NullableStringFieldUpdateOperationsInput | string | null
    mt5ServerName?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    eaStatus?: StringFieldUpdateOperationsInput | string
    lastHeartbeat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    equity?: FloatFieldUpdateOperationsInput | number
    margin?: FloatFieldUpdateOperationsInput | number
    freeMargin?: FloatFieldUpdateOperationsInput | number
    profit?: FloatFieldUpdateOperationsInput | number
    eaLoaded?: BoolFieldUpdateOperationsInput | boolean
    eaRunning?: BoolFieldUpdateOperationsInput | boolean
    eaName?: NullableStringFieldUpdateOperationsInput | string | null
    chartSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    chartTimeframe?: NullableStringFieldUpdateOperationsInput | string | null
    totalTrades?: IntFieldUpdateOperationsInput | number
    profitableTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MT5AccountAssignmentCreateManyInput = {
    id?: string
    userId: string
    agentId: string
    mt5AccountNumber: string
    mt5Broker?: string | null
    mt5ServerName?: string | null
    assignedAt?: Date | string
    isActive?: boolean
    status?: string
    eaStatus?: string
    lastHeartbeat?: Date | string | null
    balance?: number
    equity?: number
    margin?: number
    freeMargin?: number
    profit?: number
    eaLoaded?: boolean
    eaRunning?: boolean
    eaName?: string | null
    chartSymbol?: string | null
    chartTimeframe?: string | null
    totalTrades?: number
    profitableTrades?: number
    losingTrades?: number
    totalProfit?: number
    winRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MT5AccountAssignmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    mt5AccountNumber?: StringFieldUpdateOperationsInput | string
    mt5Broker?: NullableStringFieldUpdateOperationsInput | string | null
    mt5ServerName?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    eaStatus?: StringFieldUpdateOperationsInput | string
    lastHeartbeat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    equity?: FloatFieldUpdateOperationsInput | number
    margin?: FloatFieldUpdateOperationsInput | number
    freeMargin?: FloatFieldUpdateOperationsInput | number
    profit?: FloatFieldUpdateOperationsInput | number
    eaLoaded?: BoolFieldUpdateOperationsInput | boolean
    eaRunning?: BoolFieldUpdateOperationsInput | boolean
    eaName?: NullableStringFieldUpdateOperationsInput | string | null
    chartSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    chartTimeframe?: NullableStringFieldUpdateOperationsInput | string | null
    totalTrades?: IntFieldUpdateOperationsInput | number
    profitableTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MT5AccountAssignmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    mt5AccountNumber?: StringFieldUpdateOperationsInput | string
    mt5Broker?: NullableStringFieldUpdateOperationsInput | string | null
    mt5ServerName?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    eaStatus?: StringFieldUpdateOperationsInput | string
    lastHeartbeat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    equity?: FloatFieldUpdateOperationsInput | number
    margin?: FloatFieldUpdateOperationsInput | number
    freeMargin?: FloatFieldUpdateOperationsInput | number
    profit?: FloatFieldUpdateOperationsInput | number
    eaLoaded?: BoolFieldUpdateOperationsInput | boolean
    eaRunning?: BoolFieldUpdateOperationsInput | boolean
    eaName?: NullableStringFieldUpdateOperationsInput | string | null
    chartSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    chartTimeframe?: NullableStringFieldUpdateOperationsInput | string | null
    totalTrades?: IntFieldUpdateOperationsInput | number
    profitableTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrizeCreateInput = {
    id?: string
    period: string
    rank: number
    amount: number
    isActive?: boolean
    updatedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrizeUncheckedCreateInput = {
    id?: string
    period: string
    rank: number
    amount: number
    isActive?: boolean
    updatedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrizeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrizeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrizeCreateManyInput = {
    id?: string
    period: string
    rank: number
    amount: number
    isActive?: boolean
    updatedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrizeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrizeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GlobalSettingsCreateInput = {
    id?: string
    settingKey: string
    settingValue: string
    description?: string | null
    updatedBy?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type GlobalSettingsUncheckedCreateInput = {
    id?: string
    settingKey: string
    settingValue: string
    description?: string | null
    updatedBy?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type GlobalSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    settingKey?: StringFieldUpdateOperationsInput | string
    settingValue?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GlobalSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    settingKey?: StringFieldUpdateOperationsInput | string
    settingValue?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GlobalSettingsCreateManyInput = {
    id?: string
    settingKey: string
    settingValue: string
    description?: string | null
    updatedBy?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type GlobalSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    settingKey?: StringFieldUpdateOperationsInput | string
    settingValue?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GlobalSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    settingKey?: StringFieldUpdateOperationsInput | string
    settingValue?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnonymousAccountCreateInput = {
    id?: string
    anonymousId: string
    mt5AccountNumber: string
    isActive?: boolean
    registeredAt?: Date | string
    user: UserCreateNestedOneWithoutAnonymousAccountsInput
    ibPartner: IBPartnerCreateNestedOneWithoutAnonymousAccountsInput
    commissions?: IBCommissionCreateNestedManyWithoutAnonymousAccountInput
  }

  export type AnonymousAccountUncheckedCreateInput = {
    id?: string
    anonymousId: string
    userId: string
    mt5AccountNumber: string
    ibPartnerId: string
    isActive?: boolean
    registeredAt?: Date | string
    commissions?: IBCommissionUncheckedCreateNestedManyWithoutAnonymousAccountInput
  }

  export type AnonymousAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: StringFieldUpdateOperationsInput | string
    mt5AccountNumber?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAnonymousAccountsNestedInput
    ibPartner?: IBPartnerUpdateOneRequiredWithoutAnonymousAccountsNestedInput
    commissions?: IBCommissionUpdateManyWithoutAnonymousAccountNestedInput
  }

  export type AnonymousAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mt5AccountNumber?: StringFieldUpdateOperationsInput | string
    ibPartnerId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commissions?: IBCommissionUncheckedUpdateManyWithoutAnonymousAccountNestedInput
  }

  export type AnonymousAccountCreateManyInput = {
    id?: string
    anonymousId: string
    userId: string
    mt5AccountNumber: string
    ibPartnerId: string
    isActive?: boolean
    registeredAt?: Date | string
  }

  export type AnonymousAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: StringFieldUpdateOperationsInput | string
    mt5AccountNumber?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnonymousAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mt5AccountNumber?: StringFieldUpdateOperationsInput | string
    ibPartnerId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IBCommissionCreateInput = {
    id?: string
    period: Date | string
    periodEnd: Date | string
    tradingVolume?: number
    numberOfTrades?: number
    averageSpread?: number
    commissionRate: number
    grossCommission?: number
    platformFee?: number
    netCommission?: number
    isPaid?: boolean
    paidAt?: Date | string | null
    paymentReference?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ibPartner: IBPartnerCreateNestedOneWithoutCommissionsInput
    anonymousAccount: AnonymousAccountCreateNestedOneWithoutCommissionsInput
  }

  export type IBCommissionUncheckedCreateInput = {
    id?: string
    ibPartnerId: string
    anonymousAccountId: string
    period: Date | string
    periodEnd: Date | string
    tradingVolume?: number
    numberOfTrades?: number
    averageSpread?: number
    commissionRate: number
    grossCommission?: number
    platformFee?: number
    netCommission?: number
    isPaid?: boolean
    paidAt?: Date | string | null
    paymentReference?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IBCommissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    tradingVolume?: FloatFieldUpdateOperationsInput | number
    numberOfTrades?: IntFieldUpdateOperationsInput | number
    averageSpread?: FloatFieldUpdateOperationsInput | number
    commissionRate?: FloatFieldUpdateOperationsInput | number
    grossCommission?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    netCommission?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ibPartner?: IBPartnerUpdateOneRequiredWithoutCommissionsNestedInput
    anonymousAccount?: AnonymousAccountUpdateOneRequiredWithoutCommissionsNestedInput
  }

  export type IBCommissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ibPartnerId?: StringFieldUpdateOperationsInput | string
    anonymousAccountId?: StringFieldUpdateOperationsInput | string
    period?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    tradingVolume?: FloatFieldUpdateOperationsInput | number
    numberOfTrades?: IntFieldUpdateOperationsInput | number
    averageSpread?: FloatFieldUpdateOperationsInput | number
    commissionRate?: FloatFieldUpdateOperationsInput | number
    grossCommission?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    netCommission?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IBCommissionCreateManyInput = {
    id?: string
    ibPartnerId: string
    anonymousAccountId: string
    period: Date | string
    periodEnd: Date | string
    tradingVolume?: number
    numberOfTrades?: number
    averageSpread?: number
    commissionRate: number
    grossCommission?: number
    platformFee?: number
    netCommission?: number
    isPaid?: boolean
    paidAt?: Date | string | null
    paymentReference?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IBCommissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    tradingVolume?: FloatFieldUpdateOperationsInput | number
    numberOfTrades?: IntFieldUpdateOperationsInput | number
    averageSpread?: FloatFieldUpdateOperationsInput | number
    commissionRate?: FloatFieldUpdateOperationsInput | number
    grossCommission?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    netCommission?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IBCommissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ibPartnerId?: StringFieldUpdateOperationsInput | string
    anonymousAccountId?: StringFieldUpdateOperationsInput | string
    period?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    tradingVolume?: FloatFieldUpdateOperationsInput | number
    numberOfTrades?: IntFieldUpdateOperationsInput | number
    averageSpread?: FloatFieldUpdateOperationsInput | number
    commissionRate?: FloatFieldUpdateOperationsInput | number
    grossCommission?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    netCommission?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IBCommissionRateCreateInput = {
    id?: string
    commissionRate?: number
    minVolume?: number
    maxVolume?: number | null
    effectiveFrom?: Date | string
    effectiveTo?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ibPartner: IBPartnerCreateNestedOneWithoutCommissionRatesInput
  }

  export type IBCommissionRateUncheckedCreateInput = {
    id?: string
    ibPartnerId: string
    commissionRate?: number
    minVolume?: number
    maxVolume?: number | null
    effectiveFrom?: Date | string
    effectiveTo?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IBCommissionRateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    commissionRate?: FloatFieldUpdateOperationsInput | number
    minVolume?: FloatFieldUpdateOperationsInput | number
    maxVolume?: NullableFloatFieldUpdateOperationsInput | number | null
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ibPartner?: IBPartnerUpdateOneRequiredWithoutCommissionRatesNestedInput
  }

  export type IBCommissionRateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ibPartnerId?: StringFieldUpdateOperationsInput | string
    commissionRate?: FloatFieldUpdateOperationsInput | number
    minVolume?: FloatFieldUpdateOperationsInput | number
    maxVolume?: NullableFloatFieldUpdateOperationsInput | number | null
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IBCommissionRateCreateManyInput = {
    id?: string
    ibPartnerId: string
    commissionRate?: number
    minVolume?: number
    maxVolume?: number | null
    effectiveFrom?: Date | string
    effectiveTo?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IBCommissionRateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    commissionRate?: FloatFieldUpdateOperationsInput | number
    minVolume?: FloatFieldUpdateOperationsInput | number
    maxVolume?: NullableFloatFieldUpdateOperationsInput | number | null
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IBCommissionRateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ibPartnerId?: StringFieldUpdateOperationsInput | string
    commissionRate?: FloatFieldUpdateOperationsInput | number
    minVolume?: FloatFieldUpdateOperationsInput | number
    maxVolume?: NullableFloatFieldUpdateOperationsInput | number | null
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumSubscriptionTierFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionTier | EnumSubscriptionTierFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTierFilter<$PrismaModel> | $Enums.SubscriptionTier
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumAccountStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountStatus | EnumAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountStatusFilter<$PrismaModel> | $Enums.AccountStatus
  }

  export type IBPartnerNullableRelationFilter = {
    is?: IBPartnerWhereInput | null
    isNot?: IBPartnerWhereInput | null
  }

  export type MT5AccountListRelationFilter = {
    every?: MT5AccountWhereInput
    some?: MT5AccountWhereInput
    none?: MT5AccountWhereInput
  }

  export type EAListRelationFilter = {
    every?: EAWhereInput
    some?: EAWhereInput
    none?: EAWhereInput
  }

  export type TradeListRelationFilter = {
    every?: TradeWhereInput
    some?: TradeWhereInput
    none?: TradeWhereInput
  }

  export type NotificationLogListRelationFilter = {
    every?: NotificationLogWhereInput
    some?: NotificationLogWhereInput
    none?: NotificationLogWhereInput
  }

  export type UserInsightNullableRelationFilter = {
    is?: UserInsightWhereInput | null
    isNot?: UserInsightWhereInput | null
  }

  export type AutomationListRelationFilter = {
    every?: AutomationWhereInput
    some?: AutomationWhereInput
    none?: AutomationWhereInput
  }

  export type LeaderboardEntryListRelationFilter = {
    every?: LeaderboardEntryWhereInput
    some?: LeaderboardEntryWhereInput
    none?: LeaderboardEntryWhereInput
  }

  export type AgentListRelationFilter = {
    every?: AgentWhereInput
    some?: AgentWhereInput
    none?: AgentWhereInput
  }

  export type MT5AccountAssignmentListRelationFilter = {
    every?: MT5AccountAssignmentWhereInput
    some?: MT5AccountAssignmentWhereInput
    none?: MT5AccountAssignmentWhereInput
  }

  export type AnonymousAccountListRelationFilter = {
    every?: AnonymousAccountWhereInput
    some?: AnonymousAccountWhereInput
    none?: AnonymousAccountWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type MT5AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EAOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TradeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AutomationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeaderboardEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MT5AccountAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnonymousAccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    ibCode?: SortOrder
    ibPartnerId?: SortOrder
    subscriptionTier?: SortOrder
    subscriptionStart?: SortOrder
    subscriptionEnd?: SortOrder
    monthlyFee?: SortOrder
    totalTrades?: SortOrder
    winningTrades?: SortOrder
    losingTrades?: SortOrder
    totalProfit?: SortOrder
    totalVolume?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
    lastActiveAt?: SortOrder
    isActive?: SortOrder
    status?: SortOrder
    emailVerified?: SortOrder
    verificationCode?: SortOrder
    verificationExpiry?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    monthlyFee?: SortOrder
    totalTrades?: SortOrder
    winningTrades?: SortOrder
    losingTrades?: SortOrder
    totalProfit?: SortOrder
    totalVolume?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    ibCode?: SortOrder
    ibPartnerId?: SortOrder
    subscriptionTier?: SortOrder
    subscriptionStart?: SortOrder
    subscriptionEnd?: SortOrder
    monthlyFee?: SortOrder
    totalTrades?: SortOrder
    winningTrades?: SortOrder
    losingTrades?: SortOrder
    totalProfit?: SortOrder
    totalVolume?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
    lastActiveAt?: SortOrder
    isActive?: SortOrder
    status?: SortOrder
    emailVerified?: SortOrder
    verificationCode?: SortOrder
    verificationExpiry?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    ibCode?: SortOrder
    ibPartnerId?: SortOrder
    subscriptionTier?: SortOrder
    subscriptionStart?: SortOrder
    subscriptionEnd?: SortOrder
    monthlyFee?: SortOrder
    totalTrades?: SortOrder
    winningTrades?: SortOrder
    losingTrades?: SortOrder
    totalProfit?: SortOrder
    totalVolume?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
    lastActiveAt?: SortOrder
    isActive?: SortOrder
    status?: SortOrder
    emailVerified?: SortOrder
    verificationCode?: SortOrder
    verificationExpiry?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    monthlyFee?: SortOrder
    totalTrades?: SortOrder
    winningTrades?: SortOrder
    losingTrades?: SortOrder
    totalProfit?: SortOrder
    totalVolume?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumSubscriptionTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionTier | EnumSubscriptionTierFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTierWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionTierFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionTierFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumAccountStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountStatus | EnumAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountStatusWithAggregatesFilter<$PrismaModel> | $Enums.AccountStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountStatusFilter<$PrismaModel>
    _max?: NestedEnumAccountStatusFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type MT5AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountNumber?: SortOrder
    broker?: SortOrder
    serverName?: SortOrder
    login?: SortOrder
    password?: SortOrder
    vpsIp?: SortOrder
    vpsPort?: SortOrder
    status?: SortOrder
    balance?: SortOrder
    equity?: SortOrder
    margin?: SortOrder
    freeMargin?: SortOrder
    isEnabledForTrading?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastSyncAt?: SortOrder
  }

  export type MT5AccountAvgOrderByAggregateInput = {
    vpsPort?: SortOrder
    balance?: SortOrder
    equity?: SortOrder
    margin?: SortOrder
    freeMargin?: SortOrder
  }

  export type MT5AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountNumber?: SortOrder
    broker?: SortOrder
    serverName?: SortOrder
    login?: SortOrder
    password?: SortOrder
    vpsIp?: SortOrder
    vpsPort?: SortOrder
    status?: SortOrder
    balance?: SortOrder
    equity?: SortOrder
    margin?: SortOrder
    freeMargin?: SortOrder
    isEnabledForTrading?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastSyncAt?: SortOrder
  }

  export type MT5AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountNumber?: SortOrder
    broker?: SortOrder
    serverName?: SortOrder
    login?: SortOrder
    password?: SortOrder
    vpsIp?: SortOrder
    vpsPort?: SortOrder
    status?: SortOrder
    balance?: SortOrder
    equity?: SortOrder
    margin?: SortOrder
    freeMargin?: SortOrder
    isEnabledForTrading?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastSyncAt?: SortOrder
  }

  export type MT5AccountSumOrderByAggregateInput = {
    vpsPort?: SortOrder
    balance?: SortOrder
    equity?: SortOrder
    margin?: SortOrder
    freeMargin?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumEAStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EAStatus | EnumEAStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EAStatus[] | ListEnumEAStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EAStatus[] | ListEnumEAStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEAStatusFilter<$PrismaModel> | $Enums.EAStatus
  }

  export type EnumSafetyIndicatorFilter<$PrismaModel = never> = {
    equals?: $Enums.SafetyIndicator | EnumSafetyIndicatorFieldRefInput<$PrismaModel>
    in?: $Enums.SafetyIndicator[] | ListEnumSafetyIndicatorFieldRefInput<$PrismaModel>
    notIn?: $Enums.SafetyIndicator[] | ListEnumSafetyIndicatorFieldRefInput<$PrismaModel>
    not?: NestedEnumSafetyIndicatorFilter<$PrismaModel> | $Enums.SafetyIndicator
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type MT5AccountRelationFilter = {
    is?: MT5AccountWhereInput
    isNot?: MT5AccountWhereInput
  }

  export type EACountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    mt5AccountId?: SortOrder
    name?: SortOrder
    version?: SortOrder
    magicNumber?: SortOrder
    status?: SortOrder
    safetyIndicator?: SortOrder
    indicatorScore?: SortOrder
    stoppedByIndicator?: SortOrder
    stoppedByIndicatorAt?: SortOrder
    maxLotSize?: SortOrder
    riskPercent?: SortOrder
    settings?: SortOrder
    lastStartAt?: SortOrder
    lastStopAt?: SortOrder
    uptime?: SortOrder
    totalTrades?: SortOrder
    winningTrades?: SortOrder
    totalProfit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EAAvgOrderByAggregateInput = {
    magicNumber?: SortOrder
    indicatorScore?: SortOrder
    maxLotSize?: SortOrder
    riskPercent?: SortOrder
    uptime?: SortOrder
    totalTrades?: SortOrder
    winningTrades?: SortOrder
    totalProfit?: SortOrder
  }

  export type EAMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    mt5AccountId?: SortOrder
    name?: SortOrder
    version?: SortOrder
    magicNumber?: SortOrder
    status?: SortOrder
    safetyIndicator?: SortOrder
    indicatorScore?: SortOrder
    stoppedByIndicator?: SortOrder
    stoppedByIndicatorAt?: SortOrder
    maxLotSize?: SortOrder
    riskPercent?: SortOrder
    lastStartAt?: SortOrder
    lastStopAt?: SortOrder
    uptime?: SortOrder
    totalTrades?: SortOrder
    winningTrades?: SortOrder
    totalProfit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EAMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    mt5AccountId?: SortOrder
    name?: SortOrder
    version?: SortOrder
    magicNumber?: SortOrder
    status?: SortOrder
    safetyIndicator?: SortOrder
    indicatorScore?: SortOrder
    stoppedByIndicator?: SortOrder
    stoppedByIndicatorAt?: SortOrder
    maxLotSize?: SortOrder
    riskPercent?: SortOrder
    lastStartAt?: SortOrder
    lastStopAt?: SortOrder
    uptime?: SortOrder
    totalTrades?: SortOrder
    winningTrades?: SortOrder
    totalProfit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EASumOrderByAggregateInput = {
    magicNumber?: SortOrder
    indicatorScore?: SortOrder
    maxLotSize?: SortOrder
    riskPercent?: SortOrder
    uptime?: SortOrder
    totalTrades?: SortOrder
    winningTrades?: SortOrder
    totalProfit?: SortOrder
  }

  export type EnumEAStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EAStatus | EnumEAStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EAStatus[] | ListEnumEAStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EAStatus[] | ListEnumEAStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEAStatusWithAggregatesFilter<$PrismaModel> | $Enums.EAStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEAStatusFilter<$PrismaModel>
    _max?: NestedEnumEAStatusFilter<$PrismaModel>
  }

  export type EnumSafetyIndicatorWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SafetyIndicator | EnumSafetyIndicatorFieldRefInput<$PrismaModel>
    in?: $Enums.SafetyIndicator[] | ListEnumSafetyIndicatorFieldRefInput<$PrismaModel>
    notIn?: $Enums.SafetyIndicator[] | ListEnumSafetyIndicatorFieldRefInput<$PrismaModel>
    not?: NestedEnumSafetyIndicatorWithAggregatesFilter<$PrismaModel> | $Enums.SafetyIndicator
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSafetyIndicatorFilter<$PrismaModel>
    _max?: NestedEnumSafetyIndicatorFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type TradeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    mt5AccountId?: SortOrder
    ticket?: SortOrder
    symbol?: SortOrder
    type?: SortOrder
    volume?: SortOrder
    openPrice?: SortOrder
    openTime?: SortOrder
    closePrice?: SortOrder
    closeTime?: SortOrder
    profit?: SortOrder
    commission?: SortOrder
    swap?: SortOrder
    magicNumber?: SortOrder
    comment?: SortOrder
    isClosed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TradeAvgOrderByAggregateInput = {
    volume?: SortOrder
    openPrice?: SortOrder
    closePrice?: SortOrder
    profit?: SortOrder
    commission?: SortOrder
    swap?: SortOrder
    magicNumber?: SortOrder
  }

  export type TradeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    mt5AccountId?: SortOrder
    ticket?: SortOrder
    symbol?: SortOrder
    type?: SortOrder
    volume?: SortOrder
    openPrice?: SortOrder
    openTime?: SortOrder
    closePrice?: SortOrder
    closeTime?: SortOrder
    profit?: SortOrder
    commission?: SortOrder
    swap?: SortOrder
    magicNumber?: SortOrder
    comment?: SortOrder
    isClosed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TradeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    mt5AccountId?: SortOrder
    ticket?: SortOrder
    symbol?: SortOrder
    type?: SortOrder
    volume?: SortOrder
    openPrice?: SortOrder
    openTime?: SortOrder
    closePrice?: SortOrder
    closeTime?: SortOrder
    profit?: SortOrder
    commission?: SortOrder
    swap?: SortOrder
    magicNumber?: SortOrder
    comment?: SortOrder
    isClosed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TradeSumOrderByAggregateInput = {
    volume?: SortOrder
    openPrice?: SortOrder
    closePrice?: SortOrder
    profit?: SortOrder
    commission?: SortOrder
    swap?: SortOrder
    magicNumber?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumAutomationTriggerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AutomationTriggerType | EnumAutomationTriggerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AutomationTriggerType[] | ListEnumAutomationTriggerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AutomationTriggerType[] | ListEnumAutomationTriggerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAutomationTriggerTypeFilter<$PrismaModel> | $Enums.AutomationTriggerType
  }

  export type EnumAutomationActionTypeNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.AutomationActionType[] | ListEnumAutomationActionTypeFieldRefInput<$PrismaModel> | null
    has?: $Enums.AutomationActionType | EnumAutomationActionTypeFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.AutomationActionType[] | ListEnumAutomationActionTypeFieldRefInput<$PrismaModel>
    hasSome?: $Enums.AutomationActionType[] | ListEnumAutomationActionTypeFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumAutomationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AutomationStatus | EnumAutomationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AutomationStatus[] | ListEnumAutomationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AutomationStatus[] | ListEnumAutomationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAutomationStatusFilter<$PrismaModel> | $Enums.AutomationStatus
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type AutomationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    triggerType?: SortOrder
    triggerValue?: SortOrder
    triggerData?: SortOrder
    actionTypes?: SortOrder
    actionData?: SortOrder
    messageSubject?: SortOrder
    messageBody?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    isUserEnabled?: SortOrder
    totalTriggered?: SortOrder
    totalSent?: SortOrder
    totalFailed?: SortOrder
    lastTriggered?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type AutomationAvgOrderByAggregateInput = {
    triggerValue?: SortOrder
    priority?: SortOrder
    totalTriggered?: SortOrder
    totalSent?: SortOrder
    totalFailed?: SortOrder
  }

  export type AutomationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    triggerType?: SortOrder
    triggerValue?: SortOrder
    messageSubject?: SortOrder
    messageBody?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    isUserEnabled?: SortOrder
    totalTriggered?: SortOrder
    totalSent?: SortOrder
    totalFailed?: SortOrder
    lastTriggered?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type AutomationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    triggerType?: SortOrder
    triggerValue?: SortOrder
    messageSubject?: SortOrder
    messageBody?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    isUserEnabled?: SortOrder
    totalTriggered?: SortOrder
    totalSent?: SortOrder
    totalFailed?: SortOrder
    lastTriggered?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type AutomationSumOrderByAggregateInput = {
    triggerValue?: SortOrder
    priority?: SortOrder
    totalTriggered?: SortOrder
    totalSent?: SortOrder
    totalFailed?: SortOrder
  }

  export type EnumAutomationTriggerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AutomationTriggerType | EnumAutomationTriggerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AutomationTriggerType[] | ListEnumAutomationTriggerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AutomationTriggerType[] | ListEnumAutomationTriggerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAutomationTriggerTypeWithAggregatesFilter<$PrismaModel> | $Enums.AutomationTriggerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAutomationTriggerTypeFilter<$PrismaModel>
    _max?: NestedEnumAutomationTriggerTypeFilter<$PrismaModel>
  }

  export type EnumAutomationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AutomationStatus | EnumAutomationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AutomationStatus[] | ListEnumAutomationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AutomationStatus[] | ListEnumAutomationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAutomationStatusWithAggregatesFilter<$PrismaModel> | $Enums.AutomationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAutomationStatusFilter<$PrismaModel>
    _max?: NestedEnumAutomationStatusFilter<$PrismaModel>
  }

  export type EnumAutomationActionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AutomationActionType | EnumAutomationActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AutomationActionType[] | ListEnumAutomationActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AutomationActionType[] | ListEnumAutomationActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAutomationActionTypeFilter<$PrismaModel> | $Enums.AutomationActionType
  }

  export type EnumNotificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusFilter<$PrismaModel> | $Enums.NotificationStatus
  }

  export type AutomationRelationFilter = {
    is?: AutomationWhereInput
    isNot?: AutomationWhereInput
  }

  export type NotificationLogCountOrderByAggregateInput = {
    id?: SortOrder
    automationId?: SortOrder
    userId?: SortOrder
    channel?: SortOrder
    recipient?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    deliveredAt?: SortOrder
    failedAt?: SortOrder
    errorMessage?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationLogMaxOrderByAggregateInput = {
    id?: SortOrder
    automationId?: SortOrder
    userId?: SortOrder
    channel?: SortOrder
    recipient?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    deliveredAt?: SortOrder
    failedAt?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationLogMinOrderByAggregateInput = {
    id?: SortOrder
    automationId?: SortOrder
    userId?: SortOrder
    channel?: SortOrder
    recipient?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    deliveredAt?: SortOrder
    failedAt?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumAutomationActionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AutomationActionType | EnumAutomationActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AutomationActionType[] | ListEnumAutomationActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AutomationActionType[] | ListEnumAutomationActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAutomationActionTypeWithAggregatesFilter<$PrismaModel> | $Enums.AutomationActionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAutomationActionTypeFilter<$PrismaModel>
    _max?: NestedEnumAutomationActionTypeFilter<$PrismaModel>
  }

  export type EnumNotificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.NotificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationStatusFilter<$PrismaModel>
    _max?: NestedEnumNotificationStatusFilter<$PrismaModel>
  }

  export type UserInsightCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    winRate?: SortOrder
    avgProfitPerTrade?: SortOrder
    avgLossPerTrade?: SortOrder
    profitFactor?: SortOrder
    maxDrawdown?: SortOrder
    sharpeRatio?: SortOrder
    tradingDaysActive?: SortOrder
    avgTradesPerDay?: SortOrder
    preferredTimeframe?: SortOrder
    riskLevel?: SortOrder
    lastTradeDate?: SortOrder
    consecutiveWins?: SortOrder
    consecutiveLosses?: SortOrder
    daysSinceLastTrade?: SortOrder
    lifetimeValue?: SortOrder
    totalRevenue?: SortOrder
    churnRisk?: SortOrder
    engagementScore?: SortOrder
    predictedNextAction?: SortOrder
    retentionProbability?: SortOrder
    upsellProbability?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserInsightAvgOrderByAggregateInput = {
    winRate?: SortOrder
    avgProfitPerTrade?: SortOrder
    avgLossPerTrade?: SortOrder
    profitFactor?: SortOrder
    maxDrawdown?: SortOrder
    sharpeRatio?: SortOrder
    tradingDaysActive?: SortOrder
    avgTradesPerDay?: SortOrder
    consecutiveWins?: SortOrder
    consecutiveLosses?: SortOrder
    daysSinceLastTrade?: SortOrder
    lifetimeValue?: SortOrder
    totalRevenue?: SortOrder
    churnRisk?: SortOrder
    engagementScore?: SortOrder
    retentionProbability?: SortOrder
    upsellProbability?: SortOrder
  }

  export type UserInsightMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    winRate?: SortOrder
    avgProfitPerTrade?: SortOrder
    avgLossPerTrade?: SortOrder
    profitFactor?: SortOrder
    maxDrawdown?: SortOrder
    sharpeRatio?: SortOrder
    tradingDaysActive?: SortOrder
    avgTradesPerDay?: SortOrder
    preferredTimeframe?: SortOrder
    riskLevel?: SortOrder
    lastTradeDate?: SortOrder
    consecutiveWins?: SortOrder
    consecutiveLosses?: SortOrder
    daysSinceLastTrade?: SortOrder
    lifetimeValue?: SortOrder
    totalRevenue?: SortOrder
    churnRisk?: SortOrder
    engagementScore?: SortOrder
    predictedNextAction?: SortOrder
    retentionProbability?: SortOrder
    upsellProbability?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserInsightMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    winRate?: SortOrder
    avgProfitPerTrade?: SortOrder
    avgLossPerTrade?: SortOrder
    profitFactor?: SortOrder
    maxDrawdown?: SortOrder
    sharpeRatio?: SortOrder
    tradingDaysActive?: SortOrder
    avgTradesPerDay?: SortOrder
    preferredTimeframe?: SortOrder
    riskLevel?: SortOrder
    lastTradeDate?: SortOrder
    consecutiveWins?: SortOrder
    consecutiveLosses?: SortOrder
    daysSinceLastTrade?: SortOrder
    lifetimeValue?: SortOrder
    totalRevenue?: SortOrder
    churnRisk?: SortOrder
    engagementScore?: SortOrder
    predictedNextAction?: SortOrder
    retentionProbability?: SortOrder
    upsellProbability?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserInsightSumOrderByAggregateInput = {
    winRate?: SortOrder
    avgProfitPerTrade?: SortOrder
    avgLossPerTrade?: SortOrder
    profitFactor?: SortOrder
    maxDrawdown?: SortOrder
    sharpeRatio?: SortOrder
    tradingDaysActive?: SortOrder
    avgTradesPerDay?: SortOrder
    consecutiveWins?: SortOrder
    consecutiveLosses?: SortOrder
    daysSinceLastTrade?: SortOrder
    lifetimeValue?: SortOrder
    totalRevenue?: SortOrder
    churnRisk?: SortOrder
    engagementScore?: SortOrder
    retentionProbability?: SortOrder
    upsellProbability?: SortOrder
  }

  export type SystemLogCountOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    component?: SortOrder
    message?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type SystemLogMaxOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    component?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type SystemLogMinOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    component?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type MarketConditionCountOrderByAggregateInput = {
    id?: SortOrder
    volatility?: SortOrder
    spread?: SortOrder
    trend?: SortOrder
    newsImpact?: SortOrder
    safetyIndicator?: SortOrder
    reason?: SortOrder
    timestamp?: SortOrder
  }

  export type MarketConditionAvgOrderByAggregateInput = {
    volatility?: SortOrder
    spread?: SortOrder
  }

  export type MarketConditionMaxOrderByAggregateInput = {
    id?: SortOrder
    volatility?: SortOrder
    spread?: SortOrder
    trend?: SortOrder
    newsImpact?: SortOrder
    safetyIndicator?: SortOrder
    reason?: SortOrder
    timestamp?: SortOrder
  }

  export type MarketConditionMinOrderByAggregateInput = {
    id?: SortOrder
    volatility?: SortOrder
    spread?: SortOrder
    trend?: SortOrder
    newsImpact?: SortOrder
    safetyIndicator?: SortOrder
    reason?: SortOrder
    timestamp?: SortOrder
  }

  export type MarketConditionSumOrderByAggregateInput = {
    volatility?: SortOrder
    spread?: SortOrder
  }

  export type LeaderboardEntryUserIdPeriodPeriodDateCompoundUniqueInput = {
    userId: string
    period: string
    periodDate: Date | string
  }

  export type LeaderboardEntryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    period?: SortOrder
    periodDate?: SortOrder
    trades?: SortOrder
    winningTrades?: SortOrder
    losingTrades?: SortOrder
    profit?: SortOrder
    volume?: SortOrder
    winRate?: SortOrder
    rank?: SortOrder
    previousRank?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaderboardEntryAvgOrderByAggregateInput = {
    trades?: SortOrder
    winningTrades?: SortOrder
    losingTrades?: SortOrder
    profit?: SortOrder
    volume?: SortOrder
    winRate?: SortOrder
    rank?: SortOrder
    previousRank?: SortOrder
  }

  export type LeaderboardEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    period?: SortOrder
    periodDate?: SortOrder
    trades?: SortOrder
    winningTrades?: SortOrder
    losingTrades?: SortOrder
    profit?: SortOrder
    volume?: SortOrder
    winRate?: SortOrder
    rank?: SortOrder
    previousRank?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaderboardEntryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    period?: SortOrder
    periodDate?: SortOrder
    trades?: SortOrder
    winningTrades?: SortOrder
    losingTrades?: SortOrder
    profit?: SortOrder
    volume?: SortOrder
    winRate?: SortOrder
    rank?: SortOrder
    previousRank?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaderboardEntrySumOrderByAggregateInput = {
    trades?: SortOrder
    winningTrades?: SortOrder
    losingTrades?: SortOrder
    profit?: SortOrder
    volume?: SortOrder
    winRate?: SortOrder
    rank?: SortOrder
    previousRank?: SortOrder
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type IBCommissionListRelationFilter = {
    every?: IBCommissionWhereInput
    some?: IBCommissionWhereInput
    none?: IBCommissionWhereInput
  }

  export type IBCommissionRateListRelationFilter = {
    every?: IBCommissionRateWhereInput
    some?: IBCommissionRateWhereInput
    none?: IBCommissionRateWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IBCommissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IBCommissionRateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IBPartnerCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    companyName?: SortOrder
    contactName?: SortOrder
    phone?: SortOrder
    ibCode?: SortOrder
    domain?: SortOrder
    logo?: SortOrder
    favicon?: SortOrder
    brandColor?: SortOrder
    brandName?: SortOrder
    isActive?: SortOrder
    isApproved?: SortOrder
    currentTraders?: SortOrder
    message?: SortOrder
    companyDocument?: SortOrder
    idDocument?: SortOrder
    kycDocument?: SortOrder
    kycStatus?: SortOrder
    emailVerified?: SortOrder
    verificationCode?: SortOrder
    verificationExpiry?: SortOrder
    pricingTier?: SortOrder
    monthlyFee?: SortOrder
    traderLimit?: SortOrder
    spreadRevShare?: SortOrder
    totalTraders?: SortOrder
    activeTraders?: SortOrder
    monthlyRevenue?: SortOrder
    lifetimeRevenue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    approvedAt?: SortOrder
    approvedBy?: SortOrder
  }

  export type IBPartnerAvgOrderByAggregateInput = {
    monthlyFee?: SortOrder
    traderLimit?: SortOrder
    spreadRevShare?: SortOrder
    totalTraders?: SortOrder
    activeTraders?: SortOrder
    monthlyRevenue?: SortOrder
    lifetimeRevenue?: SortOrder
  }

  export type IBPartnerMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    companyName?: SortOrder
    contactName?: SortOrder
    phone?: SortOrder
    ibCode?: SortOrder
    domain?: SortOrder
    logo?: SortOrder
    favicon?: SortOrder
    brandColor?: SortOrder
    brandName?: SortOrder
    isActive?: SortOrder
    isApproved?: SortOrder
    currentTraders?: SortOrder
    message?: SortOrder
    companyDocument?: SortOrder
    idDocument?: SortOrder
    kycDocument?: SortOrder
    kycStatus?: SortOrder
    emailVerified?: SortOrder
    verificationCode?: SortOrder
    verificationExpiry?: SortOrder
    pricingTier?: SortOrder
    monthlyFee?: SortOrder
    traderLimit?: SortOrder
    spreadRevShare?: SortOrder
    totalTraders?: SortOrder
    activeTraders?: SortOrder
    monthlyRevenue?: SortOrder
    lifetimeRevenue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    approvedAt?: SortOrder
    approvedBy?: SortOrder
  }

  export type IBPartnerMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    companyName?: SortOrder
    contactName?: SortOrder
    phone?: SortOrder
    ibCode?: SortOrder
    domain?: SortOrder
    logo?: SortOrder
    favicon?: SortOrder
    brandColor?: SortOrder
    brandName?: SortOrder
    isActive?: SortOrder
    isApproved?: SortOrder
    currentTraders?: SortOrder
    message?: SortOrder
    companyDocument?: SortOrder
    idDocument?: SortOrder
    kycDocument?: SortOrder
    kycStatus?: SortOrder
    emailVerified?: SortOrder
    verificationCode?: SortOrder
    verificationExpiry?: SortOrder
    pricingTier?: SortOrder
    monthlyFee?: SortOrder
    traderLimit?: SortOrder
    spreadRevShare?: SortOrder
    totalTraders?: SortOrder
    activeTraders?: SortOrder
    monthlyRevenue?: SortOrder
    lifetimeRevenue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    approvedAt?: SortOrder
    approvedBy?: SortOrder
  }

  export type IBPartnerSumOrderByAggregateInput = {
    monthlyFee?: SortOrder
    traderLimit?: SortOrder
    spreadRevShare?: SortOrder
    totalTraders?: SortOrder
    activeTraders?: SortOrder
    monthlyRevenue?: SortOrder
    lifetimeRevenue?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type AgentNullableRelationFilter = {
    is?: AgentWhereInput | null
    isNot?: AgentWhereInput | null
  }

  export type AgentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    machineId?: SortOrder
    machineName?: SortOrder
    isPoolAgent?: SortOrder
    managedAccounts?: SortOrder
    maxCapacity?: SortOrder
    currentLoad?: SortOrder
    vpsName?: SortOrder
    vpsRegion?: SortOrder
    vpsIp?: SortOrder
    mt5AccountNumber?: SortOrder
    mt5Broker?: SortOrder
    mt5ServerName?: SortOrder
    mt5Version?: SortOrder
    status?: SortOrder
    lastHeartbeat?: SortOrder
    connectedAt?: SortOrder
    disconnectedAt?: SortOrder
    eaLoaded?: SortOrder
    eaRunning?: SortOrder
    eaName?: SortOrder
    chartSymbol?: SortOrder
    chartTimeframe?: SortOrder
    tradeCopierActive?: SortOrder
    isMasterAccount?: SortOrder
    masterAgentId?: SortOrder
    totalTrades?: SortOrder
    profitableTrades?: SortOrder
    losingTrades?: SortOrder
    totalProfit?: SortOrder
    winRate?: SortOrder
    indicatorSettings?: SortOrder
    aiOptimizationScore?: SortOrder
    lastOptimizedAt?: SortOrder
    apiKey?: SortOrder
    osVersion?: SortOrder
    agentVersion?: SortOrder
    cpuUsage?: SortOrder
    memoryUsage?: SortOrder
    diskUsage?: SortOrder
    mt5InstanceCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentAvgOrderByAggregateInput = {
    maxCapacity?: SortOrder
    currentLoad?: SortOrder
    totalTrades?: SortOrder
    profitableTrades?: SortOrder
    losingTrades?: SortOrder
    totalProfit?: SortOrder
    winRate?: SortOrder
    aiOptimizationScore?: SortOrder
    cpuUsage?: SortOrder
    memoryUsage?: SortOrder
    diskUsage?: SortOrder
    mt5InstanceCount?: SortOrder
  }

  export type AgentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    machineId?: SortOrder
    machineName?: SortOrder
    isPoolAgent?: SortOrder
    maxCapacity?: SortOrder
    currentLoad?: SortOrder
    vpsName?: SortOrder
    vpsRegion?: SortOrder
    vpsIp?: SortOrder
    mt5AccountNumber?: SortOrder
    mt5Broker?: SortOrder
    mt5ServerName?: SortOrder
    mt5Version?: SortOrder
    status?: SortOrder
    lastHeartbeat?: SortOrder
    connectedAt?: SortOrder
    disconnectedAt?: SortOrder
    eaLoaded?: SortOrder
    eaRunning?: SortOrder
    eaName?: SortOrder
    chartSymbol?: SortOrder
    chartTimeframe?: SortOrder
    tradeCopierActive?: SortOrder
    isMasterAccount?: SortOrder
    masterAgentId?: SortOrder
    totalTrades?: SortOrder
    profitableTrades?: SortOrder
    losingTrades?: SortOrder
    totalProfit?: SortOrder
    winRate?: SortOrder
    aiOptimizationScore?: SortOrder
    lastOptimizedAt?: SortOrder
    apiKey?: SortOrder
    osVersion?: SortOrder
    agentVersion?: SortOrder
    cpuUsage?: SortOrder
    memoryUsage?: SortOrder
    diskUsage?: SortOrder
    mt5InstanceCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    machineId?: SortOrder
    machineName?: SortOrder
    isPoolAgent?: SortOrder
    maxCapacity?: SortOrder
    currentLoad?: SortOrder
    vpsName?: SortOrder
    vpsRegion?: SortOrder
    vpsIp?: SortOrder
    mt5AccountNumber?: SortOrder
    mt5Broker?: SortOrder
    mt5ServerName?: SortOrder
    mt5Version?: SortOrder
    status?: SortOrder
    lastHeartbeat?: SortOrder
    connectedAt?: SortOrder
    disconnectedAt?: SortOrder
    eaLoaded?: SortOrder
    eaRunning?: SortOrder
    eaName?: SortOrder
    chartSymbol?: SortOrder
    chartTimeframe?: SortOrder
    tradeCopierActive?: SortOrder
    isMasterAccount?: SortOrder
    masterAgentId?: SortOrder
    totalTrades?: SortOrder
    profitableTrades?: SortOrder
    losingTrades?: SortOrder
    totalProfit?: SortOrder
    winRate?: SortOrder
    aiOptimizationScore?: SortOrder
    lastOptimizedAt?: SortOrder
    apiKey?: SortOrder
    osVersion?: SortOrder
    agentVersion?: SortOrder
    cpuUsage?: SortOrder
    memoryUsage?: SortOrder
    diskUsage?: SortOrder
    mt5InstanceCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentSumOrderByAggregateInput = {
    maxCapacity?: SortOrder
    currentLoad?: SortOrder
    totalTrades?: SortOrder
    profitableTrades?: SortOrder
    losingTrades?: SortOrder
    totalProfit?: SortOrder
    winRate?: SortOrder
    aiOptimizationScore?: SortOrder
    cpuUsage?: SortOrder
    memoryUsage?: SortOrder
    diskUsage?: SortOrder
    mt5InstanceCount?: SortOrder
  }

  export type AgentRelationFilter = {
    is?: AgentWhereInput
    isNot?: AgentWhereInput
  }

  export type MT5AccountAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    agentId?: SortOrder
    mt5AccountNumber?: SortOrder
    mt5Broker?: SortOrder
    mt5ServerName?: SortOrder
    assignedAt?: SortOrder
    isActive?: SortOrder
    status?: SortOrder
    eaStatus?: SortOrder
    lastHeartbeat?: SortOrder
    balance?: SortOrder
    equity?: SortOrder
    margin?: SortOrder
    freeMargin?: SortOrder
    profit?: SortOrder
    eaLoaded?: SortOrder
    eaRunning?: SortOrder
    eaName?: SortOrder
    chartSymbol?: SortOrder
    chartTimeframe?: SortOrder
    totalTrades?: SortOrder
    profitableTrades?: SortOrder
    losingTrades?: SortOrder
    totalProfit?: SortOrder
    winRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MT5AccountAssignmentAvgOrderByAggregateInput = {
    balance?: SortOrder
    equity?: SortOrder
    margin?: SortOrder
    freeMargin?: SortOrder
    profit?: SortOrder
    totalTrades?: SortOrder
    profitableTrades?: SortOrder
    losingTrades?: SortOrder
    totalProfit?: SortOrder
    winRate?: SortOrder
  }

  export type MT5AccountAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    agentId?: SortOrder
    mt5AccountNumber?: SortOrder
    mt5Broker?: SortOrder
    mt5ServerName?: SortOrder
    assignedAt?: SortOrder
    isActive?: SortOrder
    status?: SortOrder
    eaStatus?: SortOrder
    lastHeartbeat?: SortOrder
    balance?: SortOrder
    equity?: SortOrder
    margin?: SortOrder
    freeMargin?: SortOrder
    profit?: SortOrder
    eaLoaded?: SortOrder
    eaRunning?: SortOrder
    eaName?: SortOrder
    chartSymbol?: SortOrder
    chartTimeframe?: SortOrder
    totalTrades?: SortOrder
    profitableTrades?: SortOrder
    losingTrades?: SortOrder
    totalProfit?: SortOrder
    winRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MT5AccountAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    agentId?: SortOrder
    mt5AccountNumber?: SortOrder
    mt5Broker?: SortOrder
    mt5ServerName?: SortOrder
    assignedAt?: SortOrder
    isActive?: SortOrder
    status?: SortOrder
    eaStatus?: SortOrder
    lastHeartbeat?: SortOrder
    balance?: SortOrder
    equity?: SortOrder
    margin?: SortOrder
    freeMargin?: SortOrder
    profit?: SortOrder
    eaLoaded?: SortOrder
    eaRunning?: SortOrder
    eaName?: SortOrder
    chartSymbol?: SortOrder
    chartTimeframe?: SortOrder
    totalTrades?: SortOrder
    profitableTrades?: SortOrder
    losingTrades?: SortOrder
    totalProfit?: SortOrder
    winRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MT5AccountAssignmentSumOrderByAggregateInput = {
    balance?: SortOrder
    equity?: SortOrder
    margin?: SortOrder
    freeMargin?: SortOrder
    profit?: SortOrder
    totalTrades?: SortOrder
    profitableTrades?: SortOrder
    losingTrades?: SortOrder
    totalProfit?: SortOrder
    winRate?: SortOrder
  }

  export type PrizePeriodRankCompoundUniqueInput = {
    period: string
    rank: number
  }

  export type PrizeCountOrderByAggregateInput = {
    id?: SortOrder
    period?: SortOrder
    rank?: SortOrder
    amount?: SortOrder
    isActive?: SortOrder
    updatedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PrizeAvgOrderByAggregateInput = {
    rank?: SortOrder
    amount?: SortOrder
  }

  export type PrizeMaxOrderByAggregateInput = {
    id?: SortOrder
    period?: SortOrder
    rank?: SortOrder
    amount?: SortOrder
    isActive?: SortOrder
    updatedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PrizeMinOrderByAggregateInput = {
    id?: SortOrder
    period?: SortOrder
    rank?: SortOrder
    amount?: SortOrder
    isActive?: SortOrder
    updatedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PrizeSumOrderByAggregateInput = {
    rank?: SortOrder
    amount?: SortOrder
  }

  export type GlobalSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    settingKey?: SortOrder
    settingValue?: SortOrder
    description?: SortOrder
    updatedBy?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type GlobalSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    settingKey?: SortOrder
    settingValue?: SortOrder
    description?: SortOrder
    updatedBy?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type GlobalSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    settingKey?: SortOrder
    settingValue?: SortOrder
    description?: SortOrder
    updatedBy?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type IBPartnerRelationFilter = {
    is?: IBPartnerWhereInput
    isNot?: IBPartnerWhereInput
  }

  export type AnonymousAccountCountOrderByAggregateInput = {
    id?: SortOrder
    anonymousId?: SortOrder
    userId?: SortOrder
    mt5AccountNumber?: SortOrder
    ibPartnerId?: SortOrder
    isActive?: SortOrder
    registeredAt?: SortOrder
  }

  export type AnonymousAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    anonymousId?: SortOrder
    userId?: SortOrder
    mt5AccountNumber?: SortOrder
    ibPartnerId?: SortOrder
    isActive?: SortOrder
    registeredAt?: SortOrder
  }

  export type AnonymousAccountMinOrderByAggregateInput = {
    id?: SortOrder
    anonymousId?: SortOrder
    userId?: SortOrder
    mt5AccountNumber?: SortOrder
    ibPartnerId?: SortOrder
    isActive?: SortOrder
    registeredAt?: SortOrder
  }

  export type AnonymousAccountRelationFilter = {
    is?: AnonymousAccountWhereInput
    isNot?: AnonymousAccountWhereInput
  }

  export type IBCommissionAnonymousAccountIdPeriodCompoundUniqueInput = {
    anonymousAccountId: string
    period: Date | string
  }

  export type IBCommissionCountOrderByAggregateInput = {
    id?: SortOrder
    ibPartnerId?: SortOrder
    anonymousAccountId?: SortOrder
    period?: SortOrder
    periodEnd?: SortOrder
    tradingVolume?: SortOrder
    numberOfTrades?: SortOrder
    averageSpread?: SortOrder
    commissionRate?: SortOrder
    grossCommission?: SortOrder
    platformFee?: SortOrder
    netCommission?: SortOrder
    isPaid?: SortOrder
    paidAt?: SortOrder
    paymentReference?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IBCommissionAvgOrderByAggregateInput = {
    tradingVolume?: SortOrder
    numberOfTrades?: SortOrder
    averageSpread?: SortOrder
    commissionRate?: SortOrder
    grossCommission?: SortOrder
    platformFee?: SortOrder
    netCommission?: SortOrder
  }

  export type IBCommissionMaxOrderByAggregateInput = {
    id?: SortOrder
    ibPartnerId?: SortOrder
    anonymousAccountId?: SortOrder
    period?: SortOrder
    periodEnd?: SortOrder
    tradingVolume?: SortOrder
    numberOfTrades?: SortOrder
    averageSpread?: SortOrder
    commissionRate?: SortOrder
    grossCommission?: SortOrder
    platformFee?: SortOrder
    netCommission?: SortOrder
    isPaid?: SortOrder
    paidAt?: SortOrder
    paymentReference?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IBCommissionMinOrderByAggregateInput = {
    id?: SortOrder
    ibPartnerId?: SortOrder
    anonymousAccountId?: SortOrder
    period?: SortOrder
    periodEnd?: SortOrder
    tradingVolume?: SortOrder
    numberOfTrades?: SortOrder
    averageSpread?: SortOrder
    commissionRate?: SortOrder
    grossCommission?: SortOrder
    platformFee?: SortOrder
    netCommission?: SortOrder
    isPaid?: SortOrder
    paidAt?: SortOrder
    paymentReference?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IBCommissionSumOrderByAggregateInput = {
    tradingVolume?: SortOrder
    numberOfTrades?: SortOrder
    averageSpread?: SortOrder
    commissionRate?: SortOrder
    grossCommission?: SortOrder
    platformFee?: SortOrder
    netCommission?: SortOrder
  }

  export type IBCommissionRateCountOrderByAggregateInput = {
    id?: SortOrder
    ibPartnerId?: SortOrder
    commissionRate?: SortOrder
    minVolume?: SortOrder
    maxVolume?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IBCommissionRateAvgOrderByAggregateInput = {
    commissionRate?: SortOrder
    minVolume?: SortOrder
    maxVolume?: SortOrder
  }

  export type IBCommissionRateMaxOrderByAggregateInput = {
    id?: SortOrder
    ibPartnerId?: SortOrder
    commissionRate?: SortOrder
    minVolume?: SortOrder
    maxVolume?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IBCommissionRateMinOrderByAggregateInput = {
    id?: SortOrder
    ibPartnerId?: SortOrder
    commissionRate?: SortOrder
    minVolume?: SortOrder
    maxVolume?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IBCommissionRateSumOrderByAggregateInput = {
    commissionRate?: SortOrder
    minVolume?: SortOrder
    maxVolume?: SortOrder
  }

  export type IBPartnerCreateNestedOneWithoutUsersInput = {
    create?: XOR<IBPartnerCreateWithoutUsersInput, IBPartnerUncheckedCreateWithoutUsersInput>
    connectOrCreate?: IBPartnerCreateOrConnectWithoutUsersInput
    connect?: IBPartnerWhereUniqueInput
  }

  export type MT5AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<MT5AccountCreateWithoutUserInput, MT5AccountUncheckedCreateWithoutUserInput> | MT5AccountCreateWithoutUserInput[] | MT5AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MT5AccountCreateOrConnectWithoutUserInput | MT5AccountCreateOrConnectWithoutUserInput[]
    createMany?: MT5AccountCreateManyUserInputEnvelope
    connect?: MT5AccountWhereUniqueInput | MT5AccountWhereUniqueInput[]
  }

  export type EACreateNestedManyWithoutUserInput = {
    create?: XOR<EACreateWithoutUserInput, EAUncheckedCreateWithoutUserInput> | EACreateWithoutUserInput[] | EAUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EACreateOrConnectWithoutUserInput | EACreateOrConnectWithoutUserInput[]
    createMany?: EACreateManyUserInputEnvelope
    connect?: EAWhereUniqueInput | EAWhereUniqueInput[]
  }

  export type TradeCreateNestedManyWithoutUserInput = {
    create?: XOR<TradeCreateWithoutUserInput, TradeUncheckedCreateWithoutUserInput> | TradeCreateWithoutUserInput[] | TradeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TradeCreateOrConnectWithoutUserInput | TradeCreateOrConnectWithoutUserInput[]
    createMany?: TradeCreateManyUserInputEnvelope
    connect?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
  }

  export type NotificationLogCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationLogCreateWithoutUserInput, NotificationLogUncheckedCreateWithoutUserInput> | NotificationLogCreateWithoutUserInput[] | NotificationLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationLogCreateOrConnectWithoutUserInput | NotificationLogCreateOrConnectWithoutUserInput[]
    createMany?: NotificationLogCreateManyUserInputEnvelope
    connect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
  }

  export type UserInsightCreateNestedOneWithoutUserInput = {
    create?: XOR<UserInsightCreateWithoutUserInput, UserInsightUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserInsightCreateOrConnectWithoutUserInput
    connect?: UserInsightWhereUniqueInput
  }

  export type AutomationCreateNestedManyWithoutUserInput = {
    create?: XOR<AutomationCreateWithoutUserInput, AutomationUncheckedCreateWithoutUserInput> | AutomationCreateWithoutUserInput[] | AutomationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AutomationCreateOrConnectWithoutUserInput | AutomationCreateOrConnectWithoutUserInput[]
    createMany?: AutomationCreateManyUserInputEnvelope
    connect?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
  }

  export type LeaderboardEntryCreateNestedManyWithoutUserInput = {
    create?: XOR<LeaderboardEntryCreateWithoutUserInput, LeaderboardEntryUncheckedCreateWithoutUserInput> | LeaderboardEntryCreateWithoutUserInput[] | LeaderboardEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaderboardEntryCreateOrConnectWithoutUserInput | LeaderboardEntryCreateOrConnectWithoutUserInput[]
    createMany?: LeaderboardEntryCreateManyUserInputEnvelope
    connect?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
  }

  export type AgentCreateNestedManyWithoutUserInput = {
    create?: XOR<AgentCreateWithoutUserInput, AgentUncheckedCreateWithoutUserInput> | AgentCreateWithoutUserInput[] | AgentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutUserInput | AgentCreateOrConnectWithoutUserInput[]
    createMany?: AgentCreateManyUserInputEnvelope
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
  }

  export type MT5AccountAssignmentCreateNestedManyWithoutUserInput = {
    create?: XOR<MT5AccountAssignmentCreateWithoutUserInput, MT5AccountAssignmentUncheckedCreateWithoutUserInput> | MT5AccountAssignmentCreateWithoutUserInput[] | MT5AccountAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MT5AccountAssignmentCreateOrConnectWithoutUserInput | MT5AccountAssignmentCreateOrConnectWithoutUserInput[]
    createMany?: MT5AccountAssignmentCreateManyUserInputEnvelope
    connect?: MT5AccountAssignmentWhereUniqueInput | MT5AccountAssignmentWhereUniqueInput[]
  }

  export type AnonymousAccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AnonymousAccountCreateWithoutUserInput, AnonymousAccountUncheckedCreateWithoutUserInput> | AnonymousAccountCreateWithoutUserInput[] | AnonymousAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AnonymousAccountCreateOrConnectWithoutUserInput | AnonymousAccountCreateOrConnectWithoutUserInput[]
    createMany?: AnonymousAccountCreateManyUserInputEnvelope
    connect?: AnonymousAccountWhereUniqueInput | AnonymousAccountWhereUniqueInput[]
  }

  export type MT5AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MT5AccountCreateWithoutUserInput, MT5AccountUncheckedCreateWithoutUserInput> | MT5AccountCreateWithoutUserInput[] | MT5AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MT5AccountCreateOrConnectWithoutUserInput | MT5AccountCreateOrConnectWithoutUserInput[]
    createMany?: MT5AccountCreateManyUserInputEnvelope
    connect?: MT5AccountWhereUniqueInput | MT5AccountWhereUniqueInput[]
  }

  export type EAUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EACreateWithoutUserInput, EAUncheckedCreateWithoutUserInput> | EACreateWithoutUserInput[] | EAUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EACreateOrConnectWithoutUserInput | EACreateOrConnectWithoutUserInput[]
    createMany?: EACreateManyUserInputEnvelope
    connect?: EAWhereUniqueInput | EAWhereUniqueInput[]
  }

  export type TradeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TradeCreateWithoutUserInput, TradeUncheckedCreateWithoutUserInput> | TradeCreateWithoutUserInput[] | TradeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TradeCreateOrConnectWithoutUserInput | TradeCreateOrConnectWithoutUserInput[]
    createMany?: TradeCreateManyUserInputEnvelope
    connect?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
  }

  export type NotificationLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationLogCreateWithoutUserInput, NotificationLogUncheckedCreateWithoutUserInput> | NotificationLogCreateWithoutUserInput[] | NotificationLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationLogCreateOrConnectWithoutUserInput | NotificationLogCreateOrConnectWithoutUserInput[]
    createMany?: NotificationLogCreateManyUserInputEnvelope
    connect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
  }

  export type UserInsightUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserInsightCreateWithoutUserInput, UserInsightUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserInsightCreateOrConnectWithoutUserInput
    connect?: UserInsightWhereUniqueInput
  }

  export type AutomationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AutomationCreateWithoutUserInput, AutomationUncheckedCreateWithoutUserInput> | AutomationCreateWithoutUserInput[] | AutomationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AutomationCreateOrConnectWithoutUserInput | AutomationCreateOrConnectWithoutUserInput[]
    createMany?: AutomationCreateManyUserInputEnvelope
    connect?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
  }

  export type LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LeaderboardEntryCreateWithoutUserInput, LeaderboardEntryUncheckedCreateWithoutUserInput> | LeaderboardEntryCreateWithoutUserInput[] | LeaderboardEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaderboardEntryCreateOrConnectWithoutUserInput | LeaderboardEntryCreateOrConnectWithoutUserInput[]
    createMany?: LeaderboardEntryCreateManyUserInputEnvelope
    connect?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
  }

  export type AgentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AgentCreateWithoutUserInput, AgentUncheckedCreateWithoutUserInput> | AgentCreateWithoutUserInput[] | AgentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutUserInput | AgentCreateOrConnectWithoutUserInput[]
    createMany?: AgentCreateManyUserInputEnvelope
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
  }

  export type MT5AccountAssignmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MT5AccountAssignmentCreateWithoutUserInput, MT5AccountAssignmentUncheckedCreateWithoutUserInput> | MT5AccountAssignmentCreateWithoutUserInput[] | MT5AccountAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MT5AccountAssignmentCreateOrConnectWithoutUserInput | MT5AccountAssignmentCreateOrConnectWithoutUserInput[]
    createMany?: MT5AccountAssignmentCreateManyUserInputEnvelope
    connect?: MT5AccountAssignmentWhereUniqueInput | MT5AccountAssignmentWhereUniqueInput[]
  }

  export type AnonymousAccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AnonymousAccountCreateWithoutUserInput, AnonymousAccountUncheckedCreateWithoutUserInput> | AnonymousAccountCreateWithoutUserInput[] | AnonymousAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AnonymousAccountCreateOrConnectWithoutUserInput | AnonymousAccountCreateOrConnectWithoutUserInput[]
    createMany?: AnonymousAccountCreateManyUserInputEnvelope
    connect?: AnonymousAccountWhereUniqueInput | AnonymousAccountWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumSubscriptionTierFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionTier
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumAccountStatusFieldUpdateOperationsInput = {
    set?: $Enums.AccountStatus
  }

  export type IBPartnerUpdateOneWithoutUsersNestedInput = {
    create?: XOR<IBPartnerCreateWithoutUsersInput, IBPartnerUncheckedCreateWithoutUsersInput>
    connectOrCreate?: IBPartnerCreateOrConnectWithoutUsersInput
    upsert?: IBPartnerUpsertWithoutUsersInput
    disconnect?: IBPartnerWhereInput | boolean
    delete?: IBPartnerWhereInput | boolean
    connect?: IBPartnerWhereUniqueInput
    update?: XOR<XOR<IBPartnerUpdateToOneWithWhereWithoutUsersInput, IBPartnerUpdateWithoutUsersInput>, IBPartnerUncheckedUpdateWithoutUsersInput>
  }

  export type MT5AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<MT5AccountCreateWithoutUserInput, MT5AccountUncheckedCreateWithoutUserInput> | MT5AccountCreateWithoutUserInput[] | MT5AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MT5AccountCreateOrConnectWithoutUserInput | MT5AccountCreateOrConnectWithoutUserInput[]
    upsert?: MT5AccountUpsertWithWhereUniqueWithoutUserInput | MT5AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MT5AccountCreateManyUserInputEnvelope
    set?: MT5AccountWhereUniqueInput | MT5AccountWhereUniqueInput[]
    disconnect?: MT5AccountWhereUniqueInput | MT5AccountWhereUniqueInput[]
    delete?: MT5AccountWhereUniqueInput | MT5AccountWhereUniqueInput[]
    connect?: MT5AccountWhereUniqueInput | MT5AccountWhereUniqueInput[]
    update?: MT5AccountUpdateWithWhereUniqueWithoutUserInput | MT5AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MT5AccountUpdateManyWithWhereWithoutUserInput | MT5AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MT5AccountScalarWhereInput | MT5AccountScalarWhereInput[]
  }

  export type EAUpdateManyWithoutUserNestedInput = {
    create?: XOR<EACreateWithoutUserInput, EAUncheckedCreateWithoutUserInput> | EACreateWithoutUserInput[] | EAUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EACreateOrConnectWithoutUserInput | EACreateOrConnectWithoutUserInput[]
    upsert?: EAUpsertWithWhereUniqueWithoutUserInput | EAUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EACreateManyUserInputEnvelope
    set?: EAWhereUniqueInput | EAWhereUniqueInput[]
    disconnect?: EAWhereUniqueInput | EAWhereUniqueInput[]
    delete?: EAWhereUniqueInput | EAWhereUniqueInput[]
    connect?: EAWhereUniqueInput | EAWhereUniqueInput[]
    update?: EAUpdateWithWhereUniqueWithoutUserInput | EAUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EAUpdateManyWithWhereWithoutUserInput | EAUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EAScalarWhereInput | EAScalarWhereInput[]
  }

  export type TradeUpdateManyWithoutUserNestedInput = {
    create?: XOR<TradeCreateWithoutUserInput, TradeUncheckedCreateWithoutUserInput> | TradeCreateWithoutUserInput[] | TradeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TradeCreateOrConnectWithoutUserInput | TradeCreateOrConnectWithoutUserInput[]
    upsert?: TradeUpsertWithWhereUniqueWithoutUserInput | TradeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TradeCreateManyUserInputEnvelope
    set?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    disconnect?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    delete?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    connect?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    update?: TradeUpdateWithWhereUniqueWithoutUserInput | TradeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TradeUpdateManyWithWhereWithoutUserInput | TradeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TradeScalarWhereInput | TradeScalarWhereInput[]
  }

  export type NotificationLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationLogCreateWithoutUserInput, NotificationLogUncheckedCreateWithoutUserInput> | NotificationLogCreateWithoutUserInput[] | NotificationLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationLogCreateOrConnectWithoutUserInput | NotificationLogCreateOrConnectWithoutUserInput[]
    upsert?: NotificationLogUpsertWithWhereUniqueWithoutUserInput | NotificationLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationLogCreateManyUserInputEnvelope
    set?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    disconnect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    delete?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    connect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    update?: NotificationLogUpdateWithWhereUniqueWithoutUserInput | NotificationLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationLogUpdateManyWithWhereWithoutUserInput | NotificationLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationLogScalarWhereInput | NotificationLogScalarWhereInput[]
  }

  export type UserInsightUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserInsightCreateWithoutUserInput, UserInsightUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserInsightCreateOrConnectWithoutUserInput
    upsert?: UserInsightUpsertWithoutUserInput
    disconnect?: UserInsightWhereInput | boolean
    delete?: UserInsightWhereInput | boolean
    connect?: UserInsightWhereUniqueInput
    update?: XOR<XOR<UserInsightUpdateToOneWithWhereWithoutUserInput, UserInsightUpdateWithoutUserInput>, UserInsightUncheckedUpdateWithoutUserInput>
  }

  export type AutomationUpdateManyWithoutUserNestedInput = {
    create?: XOR<AutomationCreateWithoutUserInput, AutomationUncheckedCreateWithoutUserInput> | AutomationCreateWithoutUserInput[] | AutomationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AutomationCreateOrConnectWithoutUserInput | AutomationCreateOrConnectWithoutUserInput[]
    upsert?: AutomationUpsertWithWhereUniqueWithoutUserInput | AutomationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AutomationCreateManyUserInputEnvelope
    set?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    disconnect?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    delete?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    connect?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    update?: AutomationUpdateWithWhereUniqueWithoutUserInput | AutomationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AutomationUpdateManyWithWhereWithoutUserInput | AutomationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AutomationScalarWhereInput | AutomationScalarWhereInput[]
  }

  export type LeaderboardEntryUpdateManyWithoutUserNestedInput = {
    create?: XOR<LeaderboardEntryCreateWithoutUserInput, LeaderboardEntryUncheckedCreateWithoutUserInput> | LeaderboardEntryCreateWithoutUserInput[] | LeaderboardEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaderboardEntryCreateOrConnectWithoutUserInput | LeaderboardEntryCreateOrConnectWithoutUserInput[]
    upsert?: LeaderboardEntryUpsertWithWhereUniqueWithoutUserInput | LeaderboardEntryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LeaderboardEntryCreateManyUserInputEnvelope
    set?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    disconnect?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    delete?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    connect?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    update?: LeaderboardEntryUpdateWithWhereUniqueWithoutUserInput | LeaderboardEntryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LeaderboardEntryUpdateManyWithWhereWithoutUserInput | LeaderboardEntryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LeaderboardEntryScalarWhereInput | LeaderboardEntryScalarWhereInput[]
  }

  export type AgentUpdateManyWithoutUserNestedInput = {
    create?: XOR<AgentCreateWithoutUserInput, AgentUncheckedCreateWithoutUserInput> | AgentCreateWithoutUserInput[] | AgentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutUserInput | AgentCreateOrConnectWithoutUserInput[]
    upsert?: AgentUpsertWithWhereUniqueWithoutUserInput | AgentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AgentCreateManyUserInputEnvelope
    set?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    disconnect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    delete?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    update?: AgentUpdateWithWhereUniqueWithoutUserInput | AgentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AgentUpdateManyWithWhereWithoutUserInput | AgentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AgentScalarWhereInput | AgentScalarWhereInput[]
  }

  export type MT5AccountAssignmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<MT5AccountAssignmentCreateWithoutUserInput, MT5AccountAssignmentUncheckedCreateWithoutUserInput> | MT5AccountAssignmentCreateWithoutUserInput[] | MT5AccountAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MT5AccountAssignmentCreateOrConnectWithoutUserInput | MT5AccountAssignmentCreateOrConnectWithoutUserInput[]
    upsert?: MT5AccountAssignmentUpsertWithWhereUniqueWithoutUserInput | MT5AccountAssignmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MT5AccountAssignmentCreateManyUserInputEnvelope
    set?: MT5AccountAssignmentWhereUniqueInput | MT5AccountAssignmentWhereUniqueInput[]
    disconnect?: MT5AccountAssignmentWhereUniqueInput | MT5AccountAssignmentWhereUniqueInput[]
    delete?: MT5AccountAssignmentWhereUniqueInput | MT5AccountAssignmentWhereUniqueInput[]
    connect?: MT5AccountAssignmentWhereUniqueInput | MT5AccountAssignmentWhereUniqueInput[]
    update?: MT5AccountAssignmentUpdateWithWhereUniqueWithoutUserInput | MT5AccountAssignmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MT5AccountAssignmentUpdateManyWithWhereWithoutUserInput | MT5AccountAssignmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MT5AccountAssignmentScalarWhereInput | MT5AccountAssignmentScalarWhereInput[]
  }

  export type AnonymousAccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AnonymousAccountCreateWithoutUserInput, AnonymousAccountUncheckedCreateWithoutUserInput> | AnonymousAccountCreateWithoutUserInput[] | AnonymousAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AnonymousAccountCreateOrConnectWithoutUserInput | AnonymousAccountCreateOrConnectWithoutUserInput[]
    upsert?: AnonymousAccountUpsertWithWhereUniqueWithoutUserInput | AnonymousAccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AnonymousAccountCreateManyUserInputEnvelope
    set?: AnonymousAccountWhereUniqueInput | AnonymousAccountWhereUniqueInput[]
    disconnect?: AnonymousAccountWhereUniqueInput | AnonymousAccountWhereUniqueInput[]
    delete?: AnonymousAccountWhereUniqueInput | AnonymousAccountWhereUniqueInput[]
    connect?: AnonymousAccountWhereUniqueInput | AnonymousAccountWhereUniqueInput[]
    update?: AnonymousAccountUpdateWithWhereUniqueWithoutUserInput | AnonymousAccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AnonymousAccountUpdateManyWithWhereWithoutUserInput | AnonymousAccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AnonymousAccountScalarWhereInput | AnonymousAccountScalarWhereInput[]
  }

  export type MT5AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MT5AccountCreateWithoutUserInput, MT5AccountUncheckedCreateWithoutUserInput> | MT5AccountCreateWithoutUserInput[] | MT5AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MT5AccountCreateOrConnectWithoutUserInput | MT5AccountCreateOrConnectWithoutUserInput[]
    upsert?: MT5AccountUpsertWithWhereUniqueWithoutUserInput | MT5AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MT5AccountCreateManyUserInputEnvelope
    set?: MT5AccountWhereUniqueInput | MT5AccountWhereUniqueInput[]
    disconnect?: MT5AccountWhereUniqueInput | MT5AccountWhereUniqueInput[]
    delete?: MT5AccountWhereUniqueInput | MT5AccountWhereUniqueInput[]
    connect?: MT5AccountWhereUniqueInput | MT5AccountWhereUniqueInput[]
    update?: MT5AccountUpdateWithWhereUniqueWithoutUserInput | MT5AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MT5AccountUpdateManyWithWhereWithoutUserInput | MT5AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MT5AccountScalarWhereInput | MT5AccountScalarWhereInput[]
  }

  export type EAUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EACreateWithoutUserInput, EAUncheckedCreateWithoutUserInput> | EACreateWithoutUserInput[] | EAUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EACreateOrConnectWithoutUserInput | EACreateOrConnectWithoutUserInput[]
    upsert?: EAUpsertWithWhereUniqueWithoutUserInput | EAUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EACreateManyUserInputEnvelope
    set?: EAWhereUniqueInput | EAWhereUniqueInput[]
    disconnect?: EAWhereUniqueInput | EAWhereUniqueInput[]
    delete?: EAWhereUniqueInput | EAWhereUniqueInput[]
    connect?: EAWhereUniqueInput | EAWhereUniqueInput[]
    update?: EAUpdateWithWhereUniqueWithoutUserInput | EAUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EAUpdateManyWithWhereWithoutUserInput | EAUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EAScalarWhereInput | EAScalarWhereInput[]
  }

  export type TradeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TradeCreateWithoutUserInput, TradeUncheckedCreateWithoutUserInput> | TradeCreateWithoutUserInput[] | TradeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TradeCreateOrConnectWithoutUserInput | TradeCreateOrConnectWithoutUserInput[]
    upsert?: TradeUpsertWithWhereUniqueWithoutUserInput | TradeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TradeCreateManyUserInputEnvelope
    set?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    disconnect?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    delete?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    connect?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    update?: TradeUpdateWithWhereUniqueWithoutUserInput | TradeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TradeUpdateManyWithWhereWithoutUserInput | TradeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TradeScalarWhereInput | TradeScalarWhereInput[]
  }

  export type NotificationLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationLogCreateWithoutUserInput, NotificationLogUncheckedCreateWithoutUserInput> | NotificationLogCreateWithoutUserInput[] | NotificationLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationLogCreateOrConnectWithoutUserInput | NotificationLogCreateOrConnectWithoutUserInput[]
    upsert?: NotificationLogUpsertWithWhereUniqueWithoutUserInput | NotificationLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationLogCreateManyUserInputEnvelope
    set?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    disconnect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    delete?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    connect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    update?: NotificationLogUpdateWithWhereUniqueWithoutUserInput | NotificationLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationLogUpdateManyWithWhereWithoutUserInput | NotificationLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationLogScalarWhereInput | NotificationLogScalarWhereInput[]
  }

  export type UserInsightUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserInsightCreateWithoutUserInput, UserInsightUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserInsightCreateOrConnectWithoutUserInput
    upsert?: UserInsightUpsertWithoutUserInput
    disconnect?: UserInsightWhereInput | boolean
    delete?: UserInsightWhereInput | boolean
    connect?: UserInsightWhereUniqueInput
    update?: XOR<XOR<UserInsightUpdateToOneWithWhereWithoutUserInput, UserInsightUpdateWithoutUserInput>, UserInsightUncheckedUpdateWithoutUserInput>
  }

  export type AutomationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AutomationCreateWithoutUserInput, AutomationUncheckedCreateWithoutUserInput> | AutomationCreateWithoutUserInput[] | AutomationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AutomationCreateOrConnectWithoutUserInput | AutomationCreateOrConnectWithoutUserInput[]
    upsert?: AutomationUpsertWithWhereUniqueWithoutUserInput | AutomationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AutomationCreateManyUserInputEnvelope
    set?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    disconnect?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    delete?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    connect?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    update?: AutomationUpdateWithWhereUniqueWithoutUserInput | AutomationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AutomationUpdateManyWithWhereWithoutUserInput | AutomationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AutomationScalarWhereInput | AutomationScalarWhereInput[]
  }

  export type LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LeaderboardEntryCreateWithoutUserInput, LeaderboardEntryUncheckedCreateWithoutUserInput> | LeaderboardEntryCreateWithoutUserInput[] | LeaderboardEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaderboardEntryCreateOrConnectWithoutUserInput | LeaderboardEntryCreateOrConnectWithoutUserInput[]
    upsert?: LeaderboardEntryUpsertWithWhereUniqueWithoutUserInput | LeaderboardEntryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LeaderboardEntryCreateManyUserInputEnvelope
    set?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    disconnect?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    delete?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    connect?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    update?: LeaderboardEntryUpdateWithWhereUniqueWithoutUserInput | LeaderboardEntryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LeaderboardEntryUpdateManyWithWhereWithoutUserInput | LeaderboardEntryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LeaderboardEntryScalarWhereInput | LeaderboardEntryScalarWhereInput[]
  }

  export type AgentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AgentCreateWithoutUserInput, AgentUncheckedCreateWithoutUserInput> | AgentCreateWithoutUserInput[] | AgentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutUserInput | AgentCreateOrConnectWithoutUserInput[]
    upsert?: AgentUpsertWithWhereUniqueWithoutUserInput | AgentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AgentCreateManyUserInputEnvelope
    set?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    disconnect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    delete?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    update?: AgentUpdateWithWhereUniqueWithoutUserInput | AgentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AgentUpdateManyWithWhereWithoutUserInput | AgentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AgentScalarWhereInput | AgentScalarWhereInput[]
  }

  export type MT5AccountAssignmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MT5AccountAssignmentCreateWithoutUserInput, MT5AccountAssignmentUncheckedCreateWithoutUserInput> | MT5AccountAssignmentCreateWithoutUserInput[] | MT5AccountAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MT5AccountAssignmentCreateOrConnectWithoutUserInput | MT5AccountAssignmentCreateOrConnectWithoutUserInput[]
    upsert?: MT5AccountAssignmentUpsertWithWhereUniqueWithoutUserInput | MT5AccountAssignmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MT5AccountAssignmentCreateManyUserInputEnvelope
    set?: MT5AccountAssignmentWhereUniqueInput | MT5AccountAssignmentWhereUniqueInput[]
    disconnect?: MT5AccountAssignmentWhereUniqueInput | MT5AccountAssignmentWhereUniqueInput[]
    delete?: MT5AccountAssignmentWhereUniqueInput | MT5AccountAssignmentWhereUniqueInput[]
    connect?: MT5AccountAssignmentWhereUniqueInput | MT5AccountAssignmentWhereUniqueInput[]
    update?: MT5AccountAssignmentUpdateWithWhereUniqueWithoutUserInput | MT5AccountAssignmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MT5AccountAssignmentUpdateManyWithWhereWithoutUserInput | MT5AccountAssignmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MT5AccountAssignmentScalarWhereInput | MT5AccountAssignmentScalarWhereInput[]
  }

  export type AnonymousAccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AnonymousAccountCreateWithoutUserInput, AnonymousAccountUncheckedCreateWithoutUserInput> | AnonymousAccountCreateWithoutUserInput[] | AnonymousAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AnonymousAccountCreateOrConnectWithoutUserInput | AnonymousAccountCreateOrConnectWithoutUserInput[]
    upsert?: AnonymousAccountUpsertWithWhereUniqueWithoutUserInput | AnonymousAccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AnonymousAccountCreateManyUserInputEnvelope
    set?: AnonymousAccountWhereUniqueInput | AnonymousAccountWhereUniqueInput[]
    disconnect?: AnonymousAccountWhereUniqueInput | AnonymousAccountWhereUniqueInput[]
    delete?: AnonymousAccountWhereUniqueInput | AnonymousAccountWhereUniqueInput[]
    connect?: AnonymousAccountWhereUniqueInput | AnonymousAccountWhereUniqueInput[]
    update?: AnonymousAccountUpdateWithWhereUniqueWithoutUserInput | AnonymousAccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AnonymousAccountUpdateManyWithWhereWithoutUserInput | AnonymousAccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AnonymousAccountScalarWhereInput | AnonymousAccountScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutMt5AccountsInput = {
    create?: XOR<UserCreateWithoutMt5AccountsInput, UserUncheckedCreateWithoutMt5AccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMt5AccountsInput
    connect?: UserWhereUniqueInput
  }

  export type EACreateNestedManyWithoutMt5AccountInput = {
    create?: XOR<EACreateWithoutMt5AccountInput, EAUncheckedCreateWithoutMt5AccountInput> | EACreateWithoutMt5AccountInput[] | EAUncheckedCreateWithoutMt5AccountInput[]
    connectOrCreate?: EACreateOrConnectWithoutMt5AccountInput | EACreateOrConnectWithoutMt5AccountInput[]
    createMany?: EACreateManyMt5AccountInputEnvelope
    connect?: EAWhereUniqueInput | EAWhereUniqueInput[]
  }

  export type TradeCreateNestedManyWithoutMt5AccountInput = {
    create?: XOR<TradeCreateWithoutMt5AccountInput, TradeUncheckedCreateWithoutMt5AccountInput> | TradeCreateWithoutMt5AccountInput[] | TradeUncheckedCreateWithoutMt5AccountInput[]
    connectOrCreate?: TradeCreateOrConnectWithoutMt5AccountInput | TradeCreateOrConnectWithoutMt5AccountInput[]
    createMany?: TradeCreateManyMt5AccountInputEnvelope
    connect?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
  }

  export type EAUncheckedCreateNestedManyWithoutMt5AccountInput = {
    create?: XOR<EACreateWithoutMt5AccountInput, EAUncheckedCreateWithoutMt5AccountInput> | EACreateWithoutMt5AccountInput[] | EAUncheckedCreateWithoutMt5AccountInput[]
    connectOrCreate?: EACreateOrConnectWithoutMt5AccountInput | EACreateOrConnectWithoutMt5AccountInput[]
    createMany?: EACreateManyMt5AccountInputEnvelope
    connect?: EAWhereUniqueInput | EAWhereUniqueInput[]
  }

  export type TradeUncheckedCreateNestedManyWithoutMt5AccountInput = {
    create?: XOR<TradeCreateWithoutMt5AccountInput, TradeUncheckedCreateWithoutMt5AccountInput> | TradeCreateWithoutMt5AccountInput[] | TradeUncheckedCreateWithoutMt5AccountInput[]
    connectOrCreate?: TradeCreateOrConnectWithoutMt5AccountInput | TradeCreateOrConnectWithoutMt5AccountInput[]
    createMany?: TradeCreateManyMt5AccountInputEnvelope
    connect?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutMt5AccountsNestedInput = {
    create?: XOR<UserCreateWithoutMt5AccountsInput, UserUncheckedCreateWithoutMt5AccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMt5AccountsInput
    upsert?: UserUpsertWithoutMt5AccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMt5AccountsInput, UserUpdateWithoutMt5AccountsInput>, UserUncheckedUpdateWithoutMt5AccountsInput>
  }

  export type EAUpdateManyWithoutMt5AccountNestedInput = {
    create?: XOR<EACreateWithoutMt5AccountInput, EAUncheckedCreateWithoutMt5AccountInput> | EACreateWithoutMt5AccountInput[] | EAUncheckedCreateWithoutMt5AccountInput[]
    connectOrCreate?: EACreateOrConnectWithoutMt5AccountInput | EACreateOrConnectWithoutMt5AccountInput[]
    upsert?: EAUpsertWithWhereUniqueWithoutMt5AccountInput | EAUpsertWithWhereUniqueWithoutMt5AccountInput[]
    createMany?: EACreateManyMt5AccountInputEnvelope
    set?: EAWhereUniqueInput | EAWhereUniqueInput[]
    disconnect?: EAWhereUniqueInput | EAWhereUniqueInput[]
    delete?: EAWhereUniqueInput | EAWhereUniqueInput[]
    connect?: EAWhereUniqueInput | EAWhereUniqueInput[]
    update?: EAUpdateWithWhereUniqueWithoutMt5AccountInput | EAUpdateWithWhereUniqueWithoutMt5AccountInput[]
    updateMany?: EAUpdateManyWithWhereWithoutMt5AccountInput | EAUpdateManyWithWhereWithoutMt5AccountInput[]
    deleteMany?: EAScalarWhereInput | EAScalarWhereInput[]
  }

  export type TradeUpdateManyWithoutMt5AccountNestedInput = {
    create?: XOR<TradeCreateWithoutMt5AccountInput, TradeUncheckedCreateWithoutMt5AccountInput> | TradeCreateWithoutMt5AccountInput[] | TradeUncheckedCreateWithoutMt5AccountInput[]
    connectOrCreate?: TradeCreateOrConnectWithoutMt5AccountInput | TradeCreateOrConnectWithoutMt5AccountInput[]
    upsert?: TradeUpsertWithWhereUniqueWithoutMt5AccountInput | TradeUpsertWithWhereUniqueWithoutMt5AccountInput[]
    createMany?: TradeCreateManyMt5AccountInputEnvelope
    set?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    disconnect?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    delete?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    connect?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    update?: TradeUpdateWithWhereUniqueWithoutMt5AccountInput | TradeUpdateWithWhereUniqueWithoutMt5AccountInput[]
    updateMany?: TradeUpdateManyWithWhereWithoutMt5AccountInput | TradeUpdateManyWithWhereWithoutMt5AccountInput[]
    deleteMany?: TradeScalarWhereInput | TradeScalarWhereInput[]
  }

  export type EAUncheckedUpdateManyWithoutMt5AccountNestedInput = {
    create?: XOR<EACreateWithoutMt5AccountInput, EAUncheckedCreateWithoutMt5AccountInput> | EACreateWithoutMt5AccountInput[] | EAUncheckedCreateWithoutMt5AccountInput[]
    connectOrCreate?: EACreateOrConnectWithoutMt5AccountInput | EACreateOrConnectWithoutMt5AccountInput[]
    upsert?: EAUpsertWithWhereUniqueWithoutMt5AccountInput | EAUpsertWithWhereUniqueWithoutMt5AccountInput[]
    createMany?: EACreateManyMt5AccountInputEnvelope
    set?: EAWhereUniqueInput | EAWhereUniqueInput[]
    disconnect?: EAWhereUniqueInput | EAWhereUniqueInput[]
    delete?: EAWhereUniqueInput | EAWhereUniqueInput[]
    connect?: EAWhereUniqueInput | EAWhereUniqueInput[]
    update?: EAUpdateWithWhereUniqueWithoutMt5AccountInput | EAUpdateWithWhereUniqueWithoutMt5AccountInput[]
    updateMany?: EAUpdateManyWithWhereWithoutMt5AccountInput | EAUpdateManyWithWhereWithoutMt5AccountInput[]
    deleteMany?: EAScalarWhereInput | EAScalarWhereInput[]
  }

  export type TradeUncheckedUpdateManyWithoutMt5AccountNestedInput = {
    create?: XOR<TradeCreateWithoutMt5AccountInput, TradeUncheckedCreateWithoutMt5AccountInput> | TradeCreateWithoutMt5AccountInput[] | TradeUncheckedCreateWithoutMt5AccountInput[]
    connectOrCreate?: TradeCreateOrConnectWithoutMt5AccountInput | TradeCreateOrConnectWithoutMt5AccountInput[]
    upsert?: TradeUpsertWithWhereUniqueWithoutMt5AccountInput | TradeUpsertWithWhereUniqueWithoutMt5AccountInput[]
    createMany?: TradeCreateManyMt5AccountInputEnvelope
    set?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    disconnect?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    delete?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    connect?: TradeWhereUniqueInput | TradeWhereUniqueInput[]
    update?: TradeUpdateWithWhereUniqueWithoutMt5AccountInput | TradeUpdateWithWhereUniqueWithoutMt5AccountInput[]
    updateMany?: TradeUpdateManyWithWhereWithoutMt5AccountInput | TradeUpdateManyWithWhereWithoutMt5AccountInput[]
    deleteMany?: TradeScalarWhereInput | TradeScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutEasInput = {
    create?: XOR<UserCreateWithoutEasInput, UserUncheckedCreateWithoutEasInput>
    connectOrCreate?: UserCreateOrConnectWithoutEasInput
    connect?: UserWhereUniqueInput
  }

  export type MT5AccountCreateNestedOneWithoutEasInput = {
    create?: XOR<MT5AccountCreateWithoutEasInput, MT5AccountUncheckedCreateWithoutEasInput>
    connectOrCreate?: MT5AccountCreateOrConnectWithoutEasInput
    connect?: MT5AccountWhereUniqueInput
  }

  export type EnumEAStatusFieldUpdateOperationsInput = {
    set?: $Enums.EAStatus
  }

  export type EnumSafetyIndicatorFieldUpdateOperationsInput = {
    set?: $Enums.SafetyIndicator
  }

  export type UserUpdateOneRequiredWithoutEasNestedInput = {
    create?: XOR<UserCreateWithoutEasInput, UserUncheckedCreateWithoutEasInput>
    connectOrCreate?: UserCreateOrConnectWithoutEasInput
    upsert?: UserUpsertWithoutEasInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEasInput, UserUpdateWithoutEasInput>, UserUncheckedUpdateWithoutEasInput>
  }

  export type MT5AccountUpdateOneRequiredWithoutEasNestedInput = {
    create?: XOR<MT5AccountCreateWithoutEasInput, MT5AccountUncheckedCreateWithoutEasInput>
    connectOrCreate?: MT5AccountCreateOrConnectWithoutEasInput
    upsert?: MT5AccountUpsertWithoutEasInput
    connect?: MT5AccountWhereUniqueInput
    update?: XOR<XOR<MT5AccountUpdateToOneWithWhereWithoutEasInput, MT5AccountUpdateWithoutEasInput>, MT5AccountUncheckedUpdateWithoutEasInput>
  }

  export type UserCreateNestedOneWithoutTradesInput = {
    create?: XOR<UserCreateWithoutTradesInput, UserUncheckedCreateWithoutTradesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTradesInput
    connect?: UserWhereUniqueInput
  }

  export type MT5AccountCreateNestedOneWithoutTradesInput = {
    create?: XOR<MT5AccountCreateWithoutTradesInput, MT5AccountUncheckedCreateWithoutTradesInput>
    connectOrCreate?: MT5AccountCreateOrConnectWithoutTradesInput
    connect?: MT5AccountWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutTradesNestedInput = {
    create?: XOR<UserCreateWithoutTradesInput, UserUncheckedCreateWithoutTradesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTradesInput
    upsert?: UserUpsertWithoutTradesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTradesInput, UserUpdateWithoutTradesInput>, UserUncheckedUpdateWithoutTradesInput>
  }

  export type MT5AccountUpdateOneRequiredWithoutTradesNestedInput = {
    create?: XOR<MT5AccountCreateWithoutTradesInput, MT5AccountUncheckedCreateWithoutTradesInput>
    connectOrCreate?: MT5AccountCreateOrConnectWithoutTradesInput
    upsert?: MT5AccountUpsertWithoutTradesInput
    connect?: MT5AccountWhereUniqueInput
    update?: XOR<XOR<MT5AccountUpdateToOneWithWhereWithoutTradesInput, MT5AccountUpdateWithoutTradesInput>, MT5AccountUncheckedUpdateWithoutTradesInput>
  }

  export type AutomationCreateactionTypesInput = {
    set: $Enums.AutomationActionType[]
  }

  export type UserCreateNestedOneWithoutAutomationsInput = {
    create?: XOR<UserCreateWithoutAutomationsInput, UserUncheckedCreateWithoutAutomationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAutomationsInput
    connect?: UserWhereUniqueInput
  }

  export type NotificationLogCreateNestedManyWithoutAutomationInput = {
    create?: XOR<NotificationLogCreateWithoutAutomationInput, NotificationLogUncheckedCreateWithoutAutomationInput> | NotificationLogCreateWithoutAutomationInput[] | NotificationLogUncheckedCreateWithoutAutomationInput[]
    connectOrCreate?: NotificationLogCreateOrConnectWithoutAutomationInput | NotificationLogCreateOrConnectWithoutAutomationInput[]
    createMany?: NotificationLogCreateManyAutomationInputEnvelope
    connect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
  }

  export type NotificationLogUncheckedCreateNestedManyWithoutAutomationInput = {
    create?: XOR<NotificationLogCreateWithoutAutomationInput, NotificationLogUncheckedCreateWithoutAutomationInput> | NotificationLogCreateWithoutAutomationInput[] | NotificationLogUncheckedCreateWithoutAutomationInput[]
    connectOrCreate?: NotificationLogCreateOrConnectWithoutAutomationInput | NotificationLogCreateOrConnectWithoutAutomationInput[]
    createMany?: NotificationLogCreateManyAutomationInputEnvelope
    connect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
  }

  export type EnumAutomationTriggerTypeFieldUpdateOperationsInput = {
    set?: $Enums.AutomationTriggerType
  }

  export type AutomationUpdateactionTypesInput = {
    set?: $Enums.AutomationActionType[]
    push?: $Enums.AutomationActionType | $Enums.AutomationActionType[]
  }

  export type EnumAutomationStatusFieldUpdateOperationsInput = {
    set?: $Enums.AutomationStatus
  }

  export type UserUpdateOneWithoutAutomationsNestedInput = {
    create?: XOR<UserCreateWithoutAutomationsInput, UserUncheckedCreateWithoutAutomationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAutomationsInput
    upsert?: UserUpsertWithoutAutomationsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAutomationsInput, UserUpdateWithoutAutomationsInput>, UserUncheckedUpdateWithoutAutomationsInput>
  }

  export type NotificationLogUpdateManyWithoutAutomationNestedInput = {
    create?: XOR<NotificationLogCreateWithoutAutomationInput, NotificationLogUncheckedCreateWithoutAutomationInput> | NotificationLogCreateWithoutAutomationInput[] | NotificationLogUncheckedCreateWithoutAutomationInput[]
    connectOrCreate?: NotificationLogCreateOrConnectWithoutAutomationInput | NotificationLogCreateOrConnectWithoutAutomationInput[]
    upsert?: NotificationLogUpsertWithWhereUniqueWithoutAutomationInput | NotificationLogUpsertWithWhereUniqueWithoutAutomationInput[]
    createMany?: NotificationLogCreateManyAutomationInputEnvelope
    set?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    disconnect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    delete?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    connect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    update?: NotificationLogUpdateWithWhereUniqueWithoutAutomationInput | NotificationLogUpdateWithWhereUniqueWithoutAutomationInput[]
    updateMany?: NotificationLogUpdateManyWithWhereWithoutAutomationInput | NotificationLogUpdateManyWithWhereWithoutAutomationInput[]
    deleteMany?: NotificationLogScalarWhereInput | NotificationLogScalarWhereInput[]
  }

  export type NotificationLogUncheckedUpdateManyWithoutAutomationNestedInput = {
    create?: XOR<NotificationLogCreateWithoutAutomationInput, NotificationLogUncheckedCreateWithoutAutomationInput> | NotificationLogCreateWithoutAutomationInput[] | NotificationLogUncheckedCreateWithoutAutomationInput[]
    connectOrCreate?: NotificationLogCreateOrConnectWithoutAutomationInput | NotificationLogCreateOrConnectWithoutAutomationInput[]
    upsert?: NotificationLogUpsertWithWhereUniqueWithoutAutomationInput | NotificationLogUpsertWithWhereUniqueWithoutAutomationInput[]
    createMany?: NotificationLogCreateManyAutomationInputEnvelope
    set?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    disconnect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    delete?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    connect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    update?: NotificationLogUpdateWithWhereUniqueWithoutAutomationInput | NotificationLogUpdateWithWhereUniqueWithoutAutomationInput[]
    updateMany?: NotificationLogUpdateManyWithWhereWithoutAutomationInput | NotificationLogUpdateManyWithWhereWithoutAutomationInput[]
    deleteMany?: NotificationLogScalarWhereInput | NotificationLogScalarWhereInput[]
  }

  export type AutomationCreateNestedOneWithoutLogsInput = {
    create?: XOR<AutomationCreateWithoutLogsInput, AutomationUncheckedCreateWithoutLogsInput>
    connectOrCreate?: AutomationCreateOrConnectWithoutLogsInput
    connect?: AutomationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAutomationActionTypeFieldUpdateOperationsInput = {
    set?: $Enums.AutomationActionType
  }

  export type EnumNotificationStatusFieldUpdateOperationsInput = {
    set?: $Enums.NotificationStatus
  }

  export type AutomationUpdateOneRequiredWithoutLogsNestedInput = {
    create?: XOR<AutomationCreateWithoutLogsInput, AutomationUncheckedCreateWithoutLogsInput>
    connectOrCreate?: AutomationCreateOrConnectWithoutLogsInput
    upsert?: AutomationUpsertWithoutLogsInput
    connect?: AutomationWhereUniqueInput
    update?: XOR<XOR<AutomationUpdateToOneWithWhereWithoutLogsInput, AutomationUpdateWithoutLogsInput>, AutomationUncheckedUpdateWithoutLogsInput>
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutInsightsInput = {
    create?: XOR<UserCreateWithoutInsightsInput, UserUncheckedCreateWithoutInsightsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInsightsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutInsightsNestedInput = {
    create?: XOR<UserCreateWithoutInsightsInput, UserUncheckedCreateWithoutInsightsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInsightsInput
    upsert?: UserUpsertWithoutInsightsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInsightsInput, UserUpdateWithoutInsightsInput>, UserUncheckedUpdateWithoutInsightsInput>
  }

  export type UserCreateNestedOneWithoutLeaderboardStatsInput = {
    create?: XOR<UserCreateWithoutLeaderboardStatsInput, UserUncheckedCreateWithoutLeaderboardStatsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeaderboardStatsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLeaderboardStatsNestedInput = {
    create?: XOR<UserCreateWithoutLeaderboardStatsInput, UserUncheckedCreateWithoutLeaderboardStatsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeaderboardStatsInput
    upsert?: UserUpsertWithoutLeaderboardStatsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLeaderboardStatsInput, UserUpdateWithoutLeaderboardStatsInput>, UserUncheckedUpdateWithoutLeaderboardStatsInput>
  }

  export type UserCreateNestedManyWithoutIbPartnerInput = {
    create?: XOR<UserCreateWithoutIbPartnerInput, UserUncheckedCreateWithoutIbPartnerInput> | UserCreateWithoutIbPartnerInput[] | UserUncheckedCreateWithoutIbPartnerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutIbPartnerInput | UserCreateOrConnectWithoutIbPartnerInput[]
    createMany?: UserCreateManyIbPartnerInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AnonymousAccountCreateNestedManyWithoutIbPartnerInput = {
    create?: XOR<AnonymousAccountCreateWithoutIbPartnerInput, AnonymousAccountUncheckedCreateWithoutIbPartnerInput> | AnonymousAccountCreateWithoutIbPartnerInput[] | AnonymousAccountUncheckedCreateWithoutIbPartnerInput[]
    connectOrCreate?: AnonymousAccountCreateOrConnectWithoutIbPartnerInput | AnonymousAccountCreateOrConnectWithoutIbPartnerInput[]
    createMany?: AnonymousAccountCreateManyIbPartnerInputEnvelope
    connect?: AnonymousAccountWhereUniqueInput | AnonymousAccountWhereUniqueInput[]
  }

  export type IBCommissionCreateNestedManyWithoutIbPartnerInput = {
    create?: XOR<IBCommissionCreateWithoutIbPartnerInput, IBCommissionUncheckedCreateWithoutIbPartnerInput> | IBCommissionCreateWithoutIbPartnerInput[] | IBCommissionUncheckedCreateWithoutIbPartnerInput[]
    connectOrCreate?: IBCommissionCreateOrConnectWithoutIbPartnerInput | IBCommissionCreateOrConnectWithoutIbPartnerInput[]
    createMany?: IBCommissionCreateManyIbPartnerInputEnvelope
    connect?: IBCommissionWhereUniqueInput | IBCommissionWhereUniqueInput[]
  }

  export type IBCommissionRateCreateNestedManyWithoutIbPartnerInput = {
    create?: XOR<IBCommissionRateCreateWithoutIbPartnerInput, IBCommissionRateUncheckedCreateWithoutIbPartnerInput> | IBCommissionRateCreateWithoutIbPartnerInput[] | IBCommissionRateUncheckedCreateWithoutIbPartnerInput[]
    connectOrCreate?: IBCommissionRateCreateOrConnectWithoutIbPartnerInput | IBCommissionRateCreateOrConnectWithoutIbPartnerInput[]
    createMany?: IBCommissionRateCreateManyIbPartnerInputEnvelope
    connect?: IBCommissionRateWhereUniqueInput | IBCommissionRateWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutIbPartnerInput = {
    create?: XOR<UserCreateWithoutIbPartnerInput, UserUncheckedCreateWithoutIbPartnerInput> | UserCreateWithoutIbPartnerInput[] | UserUncheckedCreateWithoutIbPartnerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutIbPartnerInput | UserCreateOrConnectWithoutIbPartnerInput[]
    createMany?: UserCreateManyIbPartnerInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AnonymousAccountUncheckedCreateNestedManyWithoutIbPartnerInput = {
    create?: XOR<AnonymousAccountCreateWithoutIbPartnerInput, AnonymousAccountUncheckedCreateWithoutIbPartnerInput> | AnonymousAccountCreateWithoutIbPartnerInput[] | AnonymousAccountUncheckedCreateWithoutIbPartnerInput[]
    connectOrCreate?: AnonymousAccountCreateOrConnectWithoutIbPartnerInput | AnonymousAccountCreateOrConnectWithoutIbPartnerInput[]
    createMany?: AnonymousAccountCreateManyIbPartnerInputEnvelope
    connect?: AnonymousAccountWhereUniqueInput | AnonymousAccountWhereUniqueInput[]
  }

  export type IBCommissionUncheckedCreateNestedManyWithoutIbPartnerInput = {
    create?: XOR<IBCommissionCreateWithoutIbPartnerInput, IBCommissionUncheckedCreateWithoutIbPartnerInput> | IBCommissionCreateWithoutIbPartnerInput[] | IBCommissionUncheckedCreateWithoutIbPartnerInput[]
    connectOrCreate?: IBCommissionCreateOrConnectWithoutIbPartnerInput | IBCommissionCreateOrConnectWithoutIbPartnerInput[]
    createMany?: IBCommissionCreateManyIbPartnerInputEnvelope
    connect?: IBCommissionWhereUniqueInput | IBCommissionWhereUniqueInput[]
  }

  export type IBCommissionRateUncheckedCreateNestedManyWithoutIbPartnerInput = {
    create?: XOR<IBCommissionRateCreateWithoutIbPartnerInput, IBCommissionRateUncheckedCreateWithoutIbPartnerInput> | IBCommissionRateCreateWithoutIbPartnerInput[] | IBCommissionRateUncheckedCreateWithoutIbPartnerInput[]
    connectOrCreate?: IBCommissionRateCreateOrConnectWithoutIbPartnerInput | IBCommissionRateCreateOrConnectWithoutIbPartnerInput[]
    createMany?: IBCommissionRateCreateManyIbPartnerInputEnvelope
    connect?: IBCommissionRateWhereUniqueInput | IBCommissionRateWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutIbPartnerNestedInput = {
    create?: XOR<UserCreateWithoutIbPartnerInput, UserUncheckedCreateWithoutIbPartnerInput> | UserCreateWithoutIbPartnerInput[] | UserUncheckedCreateWithoutIbPartnerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutIbPartnerInput | UserCreateOrConnectWithoutIbPartnerInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutIbPartnerInput | UserUpsertWithWhereUniqueWithoutIbPartnerInput[]
    createMany?: UserCreateManyIbPartnerInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutIbPartnerInput | UserUpdateWithWhereUniqueWithoutIbPartnerInput[]
    updateMany?: UserUpdateManyWithWhereWithoutIbPartnerInput | UserUpdateManyWithWhereWithoutIbPartnerInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AnonymousAccountUpdateManyWithoutIbPartnerNestedInput = {
    create?: XOR<AnonymousAccountCreateWithoutIbPartnerInput, AnonymousAccountUncheckedCreateWithoutIbPartnerInput> | AnonymousAccountCreateWithoutIbPartnerInput[] | AnonymousAccountUncheckedCreateWithoutIbPartnerInput[]
    connectOrCreate?: AnonymousAccountCreateOrConnectWithoutIbPartnerInput | AnonymousAccountCreateOrConnectWithoutIbPartnerInput[]
    upsert?: AnonymousAccountUpsertWithWhereUniqueWithoutIbPartnerInput | AnonymousAccountUpsertWithWhereUniqueWithoutIbPartnerInput[]
    createMany?: AnonymousAccountCreateManyIbPartnerInputEnvelope
    set?: AnonymousAccountWhereUniqueInput | AnonymousAccountWhereUniqueInput[]
    disconnect?: AnonymousAccountWhereUniqueInput | AnonymousAccountWhereUniqueInput[]
    delete?: AnonymousAccountWhereUniqueInput | AnonymousAccountWhereUniqueInput[]
    connect?: AnonymousAccountWhereUniqueInput | AnonymousAccountWhereUniqueInput[]
    update?: AnonymousAccountUpdateWithWhereUniqueWithoutIbPartnerInput | AnonymousAccountUpdateWithWhereUniqueWithoutIbPartnerInput[]
    updateMany?: AnonymousAccountUpdateManyWithWhereWithoutIbPartnerInput | AnonymousAccountUpdateManyWithWhereWithoutIbPartnerInput[]
    deleteMany?: AnonymousAccountScalarWhereInput | AnonymousAccountScalarWhereInput[]
  }

  export type IBCommissionUpdateManyWithoutIbPartnerNestedInput = {
    create?: XOR<IBCommissionCreateWithoutIbPartnerInput, IBCommissionUncheckedCreateWithoutIbPartnerInput> | IBCommissionCreateWithoutIbPartnerInput[] | IBCommissionUncheckedCreateWithoutIbPartnerInput[]
    connectOrCreate?: IBCommissionCreateOrConnectWithoutIbPartnerInput | IBCommissionCreateOrConnectWithoutIbPartnerInput[]
    upsert?: IBCommissionUpsertWithWhereUniqueWithoutIbPartnerInput | IBCommissionUpsertWithWhereUniqueWithoutIbPartnerInput[]
    createMany?: IBCommissionCreateManyIbPartnerInputEnvelope
    set?: IBCommissionWhereUniqueInput | IBCommissionWhereUniqueInput[]
    disconnect?: IBCommissionWhereUniqueInput | IBCommissionWhereUniqueInput[]
    delete?: IBCommissionWhereUniqueInput | IBCommissionWhereUniqueInput[]
    connect?: IBCommissionWhereUniqueInput | IBCommissionWhereUniqueInput[]
    update?: IBCommissionUpdateWithWhereUniqueWithoutIbPartnerInput | IBCommissionUpdateWithWhereUniqueWithoutIbPartnerInput[]
    updateMany?: IBCommissionUpdateManyWithWhereWithoutIbPartnerInput | IBCommissionUpdateManyWithWhereWithoutIbPartnerInput[]
    deleteMany?: IBCommissionScalarWhereInput | IBCommissionScalarWhereInput[]
  }

  export type IBCommissionRateUpdateManyWithoutIbPartnerNestedInput = {
    create?: XOR<IBCommissionRateCreateWithoutIbPartnerInput, IBCommissionRateUncheckedCreateWithoutIbPartnerInput> | IBCommissionRateCreateWithoutIbPartnerInput[] | IBCommissionRateUncheckedCreateWithoutIbPartnerInput[]
    connectOrCreate?: IBCommissionRateCreateOrConnectWithoutIbPartnerInput | IBCommissionRateCreateOrConnectWithoutIbPartnerInput[]
    upsert?: IBCommissionRateUpsertWithWhereUniqueWithoutIbPartnerInput | IBCommissionRateUpsertWithWhereUniqueWithoutIbPartnerInput[]
    createMany?: IBCommissionRateCreateManyIbPartnerInputEnvelope
    set?: IBCommissionRateWhereUniqueInput | IBCommissionRateWhereUniqueInput[]
    disconnect?: IBCommissionRateWhereUniqueInput | IBCommissionRateWhereUniqueInput[]
    delete?: IBCommissionRateWhereUniqueInput | IBCommissionRateWhereUniqueInput[]
    connect?: IBCommissionRateWhereUniqueInput | IBCommissionRateWhereUniqueInput[]
    update?: IBCommissionRateUpdateWithWhereUniqueWithoutIbPartnerInput | IBCommissionRateUpdateWithWhereUniqueWithoutIbPartnerInput[]
    updateMany?: IBCommissionRateUpdateManyWithWhereWithoutIbPartnerInput | IBCommissionRateUpdateManyWithWhereWithoutIbPartnerInput[]
    deleteMany?: IBCommissionRateScalarWhereInput | IBCommissionRateScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutIbPartnerNestedInput = {
    create?: XOR<UserCreateWithoutIbPartnerInput, UserUncheckedCreateWithoutIbPartnerInput> | UserCreateWithoutIbPartnerInput[] | UserUncheckedCreateWithoutIbPartnerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutIbPartnerInput | UserCreateOrConnectWithoutIbPartnerInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutIbPartnerInput | UserUpsertWithWhereUniqueWithoutIbPartnerInput[]
    createMany?: UserCreateManyIbPartnerInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutIbPartnerInput | UserUpdateWithWhereUniqueWithoutIbPartnerInput[]
    updateMany?: UserUpdateManyWithWhereWithoutIbPartnerInput | UserUpdateManyWithWhereWithoutIbPartnerInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AnonymousAccountUncheckedUpdateManyWithoutIbPartnerNestedInput = {
    create?: XOR<AnonymousAccountCreateWithoutIbPartnerInput, AnonymousAccountUncheckedCreateWithoutIbPartnerInput> | AnonymousAccountCreateWithoutIbPartnerInput[] | AnonymousAccountUncheckedCreateWithoutIbPartnerInput[]
    connectOrCreate?: AnonymousAccountCreateOrConnectWithoutIbPartnerInput | AnonymousAccountCreateOrConnectWithoutIbPartnerInput[]
    upsert?: AnonymousAccountUpsertWithWhereUniqueWithoutIbPartnerInput | AnonymousAccountUpsertWithWhereUniqueWithoutIbPartnerInput[]
    createMany?: AnonymousAccountCreateManyIbPartnerInputEnvelope
    set?: AnonymousAccountWhereUniqueInput | AnonymousAccountWhereUniqueInput[]
    disconnect?: AnonymousAccountWhereUniqueInput | AnonymousAccountWhereUniqueInput[]
    delete?: AnonymousAccountWhereUniqueInput | AnonymousAccountWhereUniqueInput[]
    connect?: AnonymousAccountWhereUniqueInput | AnonymousAccountWhereUniqueInput[]
    update?: AnonymousAccountUpdateWithWhereUniqueWithoutIbPartnerInput | AnonymousAccountUpdateWithWhereUniqueWithoutIbPartnerInput[]
    updateMany?: AnonymousAccountUpdateManyWithWhereWithoutIbPartnerInput | AnonymousAccountUpdateManyWithWhereWithoutIbPartnerInput[]
    deleteMany?: AnonymousAccountScalarWhereInput | AnonymousAccountScalarWhereInput[]
  }

  export type IBCommissionUncheckedUpdateManyWithoutIbPartnerNestedInput = {
    create?: XOR<IBCommissionCreateWithoutIbPartnerInput, IBCommissionUncheckedCreateWithoutIbPartnerInput> | IBCommissionCreateWithoutIbPartnerInput[] | IBCommissionUncheckedCreateWithoutIbPartnerInput[]
    connectOrCreate?: IBCommissionCreateOrConnectWithoutIbPartnerInput | IBCommissionCreateOrConnectWithoutIbPartnerInput[]
    upsert?: IBCommissionUpsertWithWhereUniqueWithoutIbPartnerInput | IBCommissionUpsertWithWhereUniqueWithoutIbPartnerInput[]
    createMany?: IBCommissionCreateManyIbPartnerInputEnvelope
    set?: IBCommissionWhereUniqueInput | IBCommissionWhereUniqueInput[]
    disconnect?: IBCommissionWhereUniqueInput | IBCommissionWhereUniqueInput[]
    delete?: IBCommissionWhereUniqueInput | IBCommissionWhereUniqueInput[]
    connect?: IBCommissionWhereUniqueInput | IBCommissionWhereUniqueInput[]
    update?: IBCommissionUpdateWithWhereUniqueWithoutIbPartnerInput | IBCommissionUpdateWithWhereUniqueWithoutIbPartnerInput[]
    updateMany?: IBCommissionUpdateManyWithWhereWithoutIbPartnerInput | IBCommissionUpdateManyWithWhereWithoutIbPartnerInput[]
    deleteMany?: IBCommissionScalarWhereInput | IBCommissionScalarWhereInput[]
  }

  export type IBCommissionRateUncheckedUpdateManyWithoutIbPartnerNestedInput = {
    create?: XOR<IBCommissionRateCreateWithoutIbPartnerInput, IBCommissionRateUncheckedCreateWithoutIbPartnerInput> | IBCommissionRateCreateWithoutIbPartnerInput[] | IBCommissionRateUncheckedCreateWithoutIbPartnerInput[]
    connectOrCreate?: IBCommissionRateCreateOrConnectWithoutIbPartnerInput | IBCommissionRateCreateOrConnectWithoutIbPartnerInput[]
    upsert?: IBCommissionRateUpsertWithWhereUniqueWithoutIbPartnerInput | IBCommissionRateUpsertWithWhereUniqueWithoutIbPartnerInput[]
    createMany?: IBCommissionRateCreateManyIbPartnerInputEnvelope
    set?: IBCommissionRateWhereUniqueInput | IBCommissionRateWhereUniqueInput[]
    disconnect?: IBCommissionRateWhereUniqueInput | IBCommissionRateWhereUniqueInput[]
    delete?: IBCommissionRateWhereUniqueInput | IBCommissionRateWhereUniqueInput[]
    connect?: IBCommissionRateWhereUniqueInput | IBCommissionRateWhereUniqueInput[]
    update?: IBCommissionRateUpdateWithWhereUniqueWithoutIbPartnerInput | IBCommissionRateUpdateWithWhereUniqueWithoutIbPartnerInput[]
    updateMany?: IBCommissionRateUpdateManyWithWhereWithoutIbPartnerInput | IBCommissionRateUpdateManyWithWhereWithoutIbPartnerInput[]
    deleteMany?: IBCommissionRateScalarWhereInput | IBCommissionRateScalarWhereInput[]
  }

  export type AgentCreatemanagedAccountsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutAgentsInput = {
    create?: XOR<UserCreateWithoutAgentsInput, UserUncheckedCreateWithoutAgentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAgentsInput
    connect?: UserWhereUniqueInput
  }

  export type AgentCreateNestedOneWithoutSlaveAgentsInput = {
    create?: XOR<AgentCreateWithoutSlaveAgentsInput, AgentUncheckedCreateWithoutSlaveAgentsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutSlaveAgentsInput
    connect?: AgentWhereUniqueInput
  }

  export type AgentCreateNestedManyWithoutMasterAgentInput = {
    create?: XOR<AgentCreateWithoutMasterAgentInput, AgentUncheckedCreateWithoutMasterAgentInput> | AgentCreateWithoutMasterAgentInput[] | AgentUncheckedCreateWithoutMasterAgentInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutMasterAgentInput | AgentCreateOrConnectWithoutMasterAgentInput[]
    createMany?: AgentCreateManyMasterAgentInputEnvelope
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
  }

  export type MT5AccountAssignmentCreateNestedManyWithoutAgentInput = {
    create?: XOR<MT5AccountAssignmentCreateWithoutAgentInput, MT5AccountAssignmentUncheckedCreateWithoutAgentInput> | MT5AccountAssignmentCreateWithoutAgentInput[] | MT5AccountAssignmentUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: MT5AccountAssignmentCreateOrConnectWithoutAgentInput | MT5AccountAssignmentCreateOrConnectWithoutAgentInput[]
    createMany?: MT5AccountAssignmentCreateManyAgentInputEnvelope
    connect?: MT5AccountAssignmentWhereUniqueInput | MT5AccountAssignmentWhereUniqueInput[]
  }

  export type AgentUncheckedCreateNestedManyWithoutMasterAgentInput = {
    create?: XOR<AgentCreateWithoutMasterAgentInput, AgentUncheckedCreateWithoutMasterAgentInput> | AgentCreateWithoutMasterAgentInput[] | AgentUncheckedCreateWithoutMasterAgentInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutMasterAgentInput | AgentCreateOrConnectWithoutMasterAgentInput[]
    createMany?: AgentCreateManyMasterAgentInputEnvelope
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
  }

  export type MT5AccountAssignmentUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<MT5AccountAssignmentCreateWithoutAgentInput, MT5AccountAssignmentUncheckedCreateWithoutAgentInput> | MT5AccountAssignmentCreateWithoutAgentInput[] | MT5AccountAssignmentUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: MT5AccountAssignmentCreateOrConnectWithoutAgentInput | MT5AccountAssignmentCreateOrConnectWithoutAgentInput[]
    createMany?: MT5AccountAssignmentCreateManyAgentInputEnvelope
    connect?: MT5AccountAssignmentWhereUniqueInput | MT5AccountAssignmentWhereUniqueInput[]
  }

  export type AgentUpdatemanagedAccountsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneWithoutAgentsNestedInput = {
    create?: XOR<UserCreateWithoutAgentsInput, UserUncheckedCreateWithoutAgentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAgentsInput
    upsert?: UserUpsertWithoutAgentsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAgentsInput, UserUpdateWithoutAgentsInput>, UserUncheckedUpdateWithoutAgentsInput>
  }

  export type AgentUpdateOneWithoutSlaveAgentsNestedInput = {
    create?: XOR<AgentCreateWithoutSlaveAgentsInput, AgentUncheckedCreateWithoutSlaveAgentsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutSlaveAgentsInput
    upsert?: AgentUpsertWithoutSlaveAgentsInput
    disconnect?: AgentWhereInput | boolean
    delete?: AgentWhereInput | boolean
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutSlaveAgentsInput, AgentUpdateWithoutSlaveAgentsInput>, AgentUncheckedUpdateWithoutSlaveAgentsInput>
  }

  export type AgentUpdateManyWithoutMasterAgentNestedInput = {
    create?: XOR<AgentCreateWithoutMasterAgentInput, AgentUncheckedCreateWithoutMasterAgentInput> | AgentCreateWithoutMasterAgentInput[] | AgentUncheckedCreateWithoutMasterAgentInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutMasterAgentInput | AgentCreateOrConnectWithoutMasterAgentInput[]
    upsert?: AgentUpsertWithWhereUniqueWithoutMasterAgentInput | AgentUpsertWithWhereUniqueWithoutMasterAgentInput[]
    createMany?: AgentCreateManyMasterAgentInputEnvelope
    set?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    disconnect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    delete?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    update?: AgentUpdateWithWhereUniqueWithoutMasterAgentInput | AgentUpdateWithWhereUniqueWithoutMasterAgentInput[]
    updateMany?: AgentUpdateManyWithWhereWithoutMasterAgentInput | AgentUpdateManyWithWhereWithoutMasterAgentInput[]
    deleteMany?: AgentScalarWhereInput | AgentScalarWhereInput[]
  }

  export type MT5AccountAssignmentUpdateManyWithoutAgentNestedInput = {
    create?: XOR<MT5AccountAssignmentCreateWithoutAgentInput, MT5AccountAssignmentUncheckedCreateWithoutAgentInput> | MT5AccountAssignmentCreateWithoutAgentInput[] | MT5AccountAssignmentUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: MT5AccountAssignmentCreateOrConnectWithoutAgentInput | MT5AccountAssignmentCreateOrConnectWithoutAgentInput[]
    upsert?: MT5AccountAssignmentUpsertWithWhereUniqueWithoutAgentInput | MT5AccountAssignmentUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: MT5AccountAssignmentCreateManyAgentInputEnvelope
    set?: MT5AccountAssignmentWhereUniqueInput | MT5AccountAssignmentWhereUniqueInput[]
    disconnect?: MT5AccountAssignmentWhereUniqueInput | MT5AccountAssignmentWhereUniqueInput[]
    delete?: MT5AccountAssignmentWhereUniqueInput | MT5AccountAssignmentWhereUniqueInput[]
    connect?: MT5AccountAssignmentWhereUniqueInput | MT5AccountAssignmentWhereUniqueInput[]
    update?: MT5AccountAssignmentUpdateWithWhereUniqueWithoutAgentInput | MT5AccountAssignmentUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: MT5AccountAssignmentUpdateManyWithWhereWithoutAgentInput | MT5AccountAssignmentUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: MT5AccountAssignmentScalarWhereInput | MT5AccountAssignmentScalarWhereInput[]
  }

  export type AgentUncheckedUpdateManyWithoutMasterAgentNestedInput = {
    create?: XOR<AgentCreateWithoutMasterAgentInput, AgentUncheckedCreateWithoutMasterAgentInput> | AgentCreateWithoutMasterAgentInput[] | AgentUncheckedCreateWithoutMasterAgentInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutMasterAgentInput | AgentCreateOrConnectWithoutMasterAgentInput[]
    upsert?: AgentUpsertWithWhereUniqueWithoutMasterAgentInput | AgentUpsertWithWhereUniqueWithoutMasterAgentInput[]
    createMany?: AgentCreateManyMasterAgentInputEnvelope
    set?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    disconnect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    delete?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    update?: AgentUpdateWithWhereUniqueWithoutMasterAgentInput | AgentUpdateWithWhereUniqueWithoutMasterAgentInput[]
    updateMany?: AgentUpdateManyWithWhereWithoutMasterAgentInput | AgentUpdateManyWithWhereWithoutMasterAgentInput[]
    deleteMany?: AgentScalarWhereInput | AgentScalarWhereInput[]
  }

  export type MT5AccountAssignmentUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<MT5AccountAssignmentCreateWithoutAgentInput, MT5AccountAssignmentUncheckedCreateWithoutAgentInput> | MT5AccountAssignmentCreateWithoutAgentInput[] | MT5AccountAssignmentUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: MT5AccountAssignmentCreateOrConnectWithoutAgentInput | MT5AccountAssignmentCreateOrConnectWithoutAgentInput[]
    upsert?: MT5AccountAssignmentUpsertWithWhereUniqueWithoutAgentInput | MT5AccountAssignmentUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: MT5AccountAssignmentCreateManyAgentInputEnvelope
    set?: MT5AccountAssignmentWhereUniqueInput | MT5AccountAssignmentWhereUniqueInput[]
    disconnect?: MT5AccountAssignmentWhereUniqueInput | MT5AccountAssignmentWhereUniqueInput[]
    delete?: MT5AccountAssignmentWhereUniqueInput | MT5AccountAssignmentWhereUniqueInput[]
    connect?: MT5AccountAssignmentWhereUniqueInput | MT5AccountAssignmentWhereUniqueInput[]
    update?: MT5AccountAssignmentUpdateWithWhereUniqueWithoutAgentInput | MT5AccountAssignmentUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: MT5AccountAssignmentUpdateManyWithWhereWithoutAgentInput | MT5AccountAssignmentUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: MT5AccountAssignmentScalarWhereInput | MT5AccountAssignmentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAccountAssignmentsInput = {
    create?: XOR<UserCreateWithoutAccountAssignmentsInput, UserUncheckedCreateWithoutAccountAssignmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountAssignmentsInput
    connect?: UserWhereUniqueInput
  }

  export type AgentCreateNestedOneWithoutAccountAssignmentsInput = {
    create?: XOR<AgentCreateWithoutAccountAssignmentsInput, AgentUncheckedCreateWithoutAccountAssignmentsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutAccountAssignmentsInput
    connect?: AgentWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAccountAssignmentsNestedInput = {
    create?: XOR<UserCreateWithoutAccountAssignmentsInput, UserUncheckedCreateWithoutAccountAssignmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountAssignmentsInput
    upsert?: UserUpsertWithoutAccountAssignmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountAssignmentsInput, UserUpdateWithoutAccountAssignmentsInput>, UserUncheckedUpdateWithoutAccountAssignmentsInput>
  }

  export type AgentUpdateOneRequiredWithoutAccountAssignmentsNestedInput = {
    create?: XOR<AgentCreateWithoutAccountAssignmentsInput, AgentUncheckedCreateWithoutAccountAssignmentsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutAccountAssignmentsInput
    upsert?: AgentUpsertWithoutAccountAssignmentsInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutAccountAssignmentsInput, AgentUpdateWithoutAccountAssignmentsInput>, AgentUncheckedUpdateWithoutAccountAssignmentsInput>
  }

  export type UserCreateNestedOneWithoutAnonymousAccountsInput = {
    create?: XOR<UserCreateWithoutAnonymousAccountsInput, UserUncheckedCreateWithoutAnonymousAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnonymousAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type IBPartnerCreateNestedOneWithoutAnonymousAccountsInput = {
    create?: XOR<IBPartnerCreateWithoutAnonymousAccountsInput, IBPartnerUncheckedCreateWithoutAnonymousAccountsInput>
    connectOrCreate?: IBPartnerCreateOrConnectWithoutAnonymousAccountsInput
    connect?: IBPartnerWhereUniqueInput
  }

  export type IBCommissionCreateNestedManyWithoutAnonymousAccountInput = {
    create?: XOR<IBCommissionCreateWithoutAnonymousAccountInput, IBCommissionUncheckedCreateWithoutAnonymousAccountInput> | IBCommissionCreateWithoutAnonymousAccountInput[] | IBCommissionUncheckedCreateWithoutAnonymousAccountInput[]
    connectOrCreate?: IBCommissionCreateOrConnectWithoutAnonymousAccountInput | IBCommissionCreateOrConnectWithoutAnonymousAccountInput[]
    createMany?: IBCommissionCreateManyAnonymousAccountInputEnvelope
    connect?: IBCommissionWhereUniqueInput | IBCommissionWhereUniqueInput[]
  }

  export type IBCommissionUncheckedCreateNestedManyWithoutAnonymousAccountInput = {
    create?: XOR<IBCommissionCreateWithoutAnonymousAccountInput, IBCommissionUncheckedCreateWithoutAnonymousAccountInput> | IBCommissionCreateWithoutAnonymousAccountInput[] | IBCommissionUncheckedCreateWithoutAnonymousAccountInput[]
    connectOrCreate?: IBCommissionCreateOrConnectWithoutAnonymousAccountInput | IBCommissionCreateOrConnectWithoutAnonymousAccountInput[]
    createMany?: IBCommissionCreateManyAnonymousAccountInputEnvelope
    connect?: IBCommissionWhereUniqueInput | IBCommissionWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutAnonymousAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAnonymousAccountsInput, UserUncheckedCreateWithoutAnonymousAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnonymousAccountsInput
    upsert?: UserUpsertWithoutAnonymousAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAnonymousAccountsInput, UserUpdateWithoutAnonymousAccountsInput>, UserUncheckedUpdateWithoutAnonymousAccountsInput>
  }

  export type IBPartnerUpdateOneRequiredWithoutAnonymousAccountsNestedInput = {
    create?: XOR<IBPartnerCreateWithoutAnonymousAccountsInput, IBPartnerUncheckedCreateWithoutAnonymousAccountsInput>
    connectOrCreate?: IBPartnerCreateOrConnectWithoutAnonymousAccountsInput
    upsert?: IBPartnerUpsertWithoutAnonymousAccountsInput
    connect?: IBPartnerWhereUniqueInput
    update?: XOR<XOR<IBPartnerUpdateToOneWithWhereWithoutAnonymousAccountsInput, IBPartnerUpdateWithoutAnonymousAccountsInput>, IBPartnerUncheckedUpdateWithoutAnonymousAccountsInput>
  }

  export type IBCommissionUpdateManyWithoutAnonymousAccountNestedInput = {
    create?: XOR<IBCommissionCreateWithoutAnonymousAccountInput, IBCommissionUncheckedCreateWithoutAnonymousAccountInput> | IBCommissionCreateWithoutAnonymousAccountInput[] | IBCommissionUncheckedCreateWithoutAnonymousAccountInput[]
    connectOrCreate?: IBCommissionCreateOrConnectWithoutAnonymousAccountInput | IBCommissionCreateOrConnectWithoutAnonymousAccountInput[]
    upsert?: IBCommissionUpsertWithWhereUniqueWithoutAnonymousAccountInput | IBCommissionUpsertWithWhereUniqueWithoutAnonymousAccountInput[]
    createMany?: IBCommissionCreateManyAnonymousAccountInputEnvelope
    set?: IBCommissionWhereUniqueInput | IBCommissionWhereUniqueInput[]
    disconnect?: IBCommissionWhereUniqueInput | IBCommissionWhereUniqueInput[]
    delete?: IBCommissionWhereUniqueInput | IBCommissionWhereUniqueInput[]
    connect?: IBCommissionWhereUniqueInput | IBCommissionWhereUniqueInput[]
    update?: IBCommissionUpdateWithWhereUniqueWithoutAnonymousAccountInput | IBCommissionUpdateWithWhereUniqueWithoutAnonymousAccountInput[]
    updateMany?: IBCommissionUpdateManyWithWhereWithoutAnonymousAccountInput | IBCommissionUpdateManyWithWhereWithoutAnonymousAccountInput[]
    deleteMany?: IBCommissionScalarWhereInput | IBCommissionScalarWhereInput[]
  }

  export type IBCommissionUncheckedUpdateManyWithoutAnonymousAccountNestedInput = {
    create?: XOR<IBCommissionCreateWithoutAnonymousAccountInput, IBCommissionUncheckedCreateWithoutAnonymousAccountInput> | IBCommissionCreateWithoutAnonymousAccountInput[] | IBCommissionUncheckedCreateWithoutAnonymousAccountInput[]
    connectOrCreate?: IBCommissionCreateOrConnectWithoutAnonymousAccountInput | IBCommissionCreateOrConnectWithoutAnonymousAccountInput[]
    upsert?: IBCommissionUpsertWithWhereUniqueWithoutAnonymousAccountInput | IBCommissionUpsertWithWhereUniqueWithoutAnonymousAccountInput[]
    createMany?: IBCommissionCreateManyAnonymousAccountInputEnvelope
    set?: IBCommissionWhereUniqueInput | IBCommissionWhereUniqueInput[]
    disconnect?: IBCommissionWhereUniqueInput | IBCommissionWhereUniqueInput[]
    delete?: IBCommissionWhereUniqueInput | IBCommissionWhereUniqueInput[]
    connect?: IBCommissionWhereUniqueInput | IBCommissionWhereUniqueInput[]
    update?: IBCommissionUpdateWithWhereUniqueWithoutAnonymousAccountInput | IBCommissionUpdateWithWhereUniqueWithoutAnonymousAccountInput[]
    updateMany?: IBCommissionUpdateManyWithWhereWithoutAnonymousAccountInput | IBCommissionUpdateManyWithWhereWithoutAnonymousAccountInput[]
    deleteMany?: IBCommissionScalarWhereInput | IBCommissionScalarWhereInput[]
  }

  export type IBPartnerCreateNestedOneWithoutCommissionsInput = {
    create?: XOR<IBPartnerCreateWithoutCommissionsInput, IBPartnerUncheckedCreateWithoutCommissionsInput>
    connectOrCreate?: IBPartnerCreateOrConnectWithoutCommissionsInput
    connect?: IBPartnerWhereUniqueInput
  }

  export type AnonymousAccountCreateNestedOneWithoutCommissionsInput = {
    create?: XOR<AnonymousAccountCreateWithoutCommissionsInput, AnonymousAccountUncheckedCreateWithoutCommissionsInput>
    connectOrCreate?: AnonymousAccountCreateOrConnectWithoutCommissionsInput
    connect?: AnonymousAccountWhereUniqueInput
  }

  export type IBPartnerUpdateOneRequiredWithoutCommissionsNestedInput = {
    create?: XOR<IBPartnerCreateWithoutCommissionsInput, IBPartnerUncheckedCreateWithoutCommissionsInput>
    connectOrCreate?: IBPartnerCreateOrConnectWithoutCommissionsInput
    upsert?: IBPartnerUpsertWithoutCommissionsInput
    connect?: IBPartnerWhereUniqueInput
    update?: XOR<XOR<IBPartnerUpdateToOneWithWhereWithoutCommissionsInput, IBPartnerUpdateWithoutCommissionsInput>, IBPartnerUncheckedUpdateWithoutCommissionsInput>
  }

  export type AnonymousAccountUpdateOneRequiredWithoutCommissionsNestedInput = {
    create?: XOR<AnonymousAccountCreateWithoutCommissionsInput, AnonymousAccountUncheckedCreateWithoutCommissionsInput>
    connectOrCreate?: AnonymousAccountCreateOrConnectWithoutCommissionsInput
    upsert?: AnonymousAccountUpsertWithoutCommissionsInput
    connect?: AnonymousAccountWhereUniqueInput
    update?: XOR<XOR<AnonymousAccountUpdateToOneWithWhereWithoutCommissionsInput, AnonymousAccountUpdateWithoutCommissionsInput>, AnonymousAccountUncheckedUpdateWithoutCommissionsInput>
  }

  export type IBPartnerCreateNestedOneWithoutCommissionRatesInput = {
    create?: XOR<IBPartnerCreateWithoutCommissionRatesInput, IBPartnerUncheckedCreateWithoutCommissionRatesInput>
    connectOrCreate?: IBPartnerCreateOrConnectWithoutCommissionRatesInput
    connect?: IBPartnerWhereUniqueInput
  }

  export type IBPartnerUpdateOneRequiredWithoutCommissionRatesNestedInput = {
    create?: XOR<IBPartnerCreateWithoutCommissionRatesInput, IBPartnerUncheckedCreateWithoutCommissionRatesInput>
    connectOrCreate?: IBPartnerCreateOrConnectWithoutCommissionRatesInput
    upsert?: IBPartnerUpsertWithoutCommissionRatesInput
    connect?: IBPartnerWhereUniqueInput
    update?: XOR<XOR<IBPartnerUpdateToOneWithWhereWithoutCommissionRatesInput, IBPartnerUpdateWithoutCommissionRatesInput>, IBPartnerUncheckedUpdateWithoutCommissionRatesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumSubscriptionTierFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionTier | EnumSubscriptionTierFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTierFilter<$PrismaModel> | $Enums.SubscriptionTier
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumAccountStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountStatus | EnumAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountStatusFilter<$PrismaModel> | $Enums.AccountStatus
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumSubscriptionTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionTier | EnumSubscriptionTierFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTierWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionTierFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionTierFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumAccountStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountStatus | EnumAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountStatusWithAggregatesFilter<$PrismaModel> | $Enums.AccountStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountStatusFilter<$PrismaModel>
    _max?: NestedEnumAccountStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumEAStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EAStatus | EnumEAStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EAStatus[] | ListEnumEAStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EAStatus[] | ListEnumEAStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEAStatusFilter<$PrismaModel> | $Enums.EAStatus
  }

  export type NestedEnumSafetyIndicatorFilter<$PrismaModel = never> = {
    equals?: $Enums.SafetyIndicator | EnumSafetyIndicatorFieldRefInput<$PrismaModel>
    in?: $Enums.SafetyIndicator[] | ListEnumSafetyIndicatorFieldRefInput<$PrismaModel>
    notIn?: $Enums.SafetyIndicator[] | ListEnumSafetyIndicatorFieldRefInput<$PrismaModel>
    not?: NestedEnumSafetyIndicatorFilter<$PrismaModel> | $Enums.SafetyIndicator
  }

  export type NestedEnumEAStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EAStatus | EnumEAStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EAStatus[] | ListEnumEAStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EAStatus[] | ListEnumEAStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEAStatusWithAggregatesFilter<$PrismaModel> | $Enums.EAStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEAStatusFilter<$PrismaModel>
    _max?: NestedEnumEAStatusFilter<$PrismaModel>
  }

  export type NestedEnumSafetyIndicatorWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SafetyIndicator | EnumSafetyIndicatorFieldRefInput<$PrismaModel>
    in?: $Enums.SafetyIndicator[] | ListEnumSafetyIndicatorFieldRefInput<$PrismaModel>
    notIn?: $Enums.SafetyIndicator[] | ListEnumSafetyIndicatorFieldRefInput<$PrismaModel>
    not?: NestedEnumSafetyIndicatorWithAggregatesFilter<$PrismaModel> | $Enums.SafetyIndicator
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSafetyIndicatorFilter<$PrismaModel>
    _max?: NestedEnumSafetyIndicatorFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumAutomationTriggerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AutomationTriggerType | EnumAutomationTriggerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AutomationTriggerType[] | ListEnumAutomationTriggerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AutomationTriggerType[] | ListEnumAutomationTriggerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAutomationTriggerTypeFilter<$PrismaModel> | $Enums.AutomationTriggerType
  }

  export type NestedEnumAutomationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AutomationStatus | EnumAutomationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AutomationStatus[] | ListEnumAutomationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AutomationStatus[] | ListEnumAutomationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAutomationStatusFilter<$PrismaModel> | $Enums.AutomationStatus
  }

  export type NestedEnumAutomationTriggerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AutomationTriggerType | EnumAutomationTriggerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AutomationTriggerType[] | ListEnumAutomationTriggerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AutomationTriggerType[] | ListEnumAutomationTriggerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAutomationTriggerTypeWithAggregatesFilter<$PrismaModel> | $Enums.AutomationTriggerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAutomationTriggerTypeFilter<$PrismaModel>
    _max?: NestedEnumAutomationTriggerTypeFilter<$PrismaModel>
  }

  export type NestedEnumAutomationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AutomationStatus | EnumAutomationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AutomationStatus[] | ListEnumAutomationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AutomationStatus[] | ListEnumAutomationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAutomationStatusWithAggregatesFilter<$PrismaModel> | $Enums.AutomationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAutomationStatusFilter<$PrismaModel>
    _max?: NestedEnumAutomationStatusFilter<$PrismaModel>
  }

  export type NestedEnumAutomationActionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AutomationActionType | EnumAutomationActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AutomationActionType[] | ListEnumAutomationActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AutomationActionType[] | ListEnumAutomationActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAutomationActionTypeFilter<$PrismaModel> | $Enums.AutomationActionType
  }

  export type NestedEnumNotificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusFilter<$PrismaModel> | $Enums.NotificationStatus
  }

  export type NestedEnumAutomationActionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AutomationActionType | EnumAutomationActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AutomationActionType[] | ListEnumAutomationActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AutomationActionType[] | ListEnumAutomationActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAutomationActionTypeWithAggregatesFilter<$PrismaModel> | $Enums.AutomationActionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAutomationActionTypeFilter<$PrismaModel>
    _max?: NestedEnumAutomationActionTypeFilter<$PrismaModel>
  }

  export type NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.NotificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationStatusFilter<$PrismaModel>
    _max?: NestedEnumNotificationStatusFilter<$PrismaModel>
  }

  export type IBPartnerCreateWithoutUsersInput = {
    id?: string
    email: string
    passwordHash: string
    companyName: string
    contactName: string
    phone: string
    ibCode: string
    domain?: string | null
    logo?: string | null
    favicon?: string | null
    brandColor?: string
    brandName?: string | null
    isActive?: boolean
    isApproved?: boolean
    currentTraders?: string | null
    message?: string | null
    companyDocument?: string | null
    idDocument?: string | null
    kycDocument?: string | null
    kycStatus?: string
    emailVerified?: boolean
    verificationCode?: string | null
    verificationExpiry?: Date | string | null
    pricingTier?: string
    monthlyFee?: number
    traderLimit?: number
    spreadRevShare?: number
    totalTraders?: number
    activeTraders?: number
    monthlyRevenue?: number
    lifetimeRevenue?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedAt?: Date | string | null
    approvedBy?: string | null
    anonymousAccounts?: AnonymousAccountCreateNestedManyWithoutIbPartnerInput
    commissions?: IBCommissionCreateNestedManyWithoutIbPartnerInput
    commissionRates?: IBCommissionRateCreateNestedManyWithoutIbPartnerInput
  }

  export type IBPartnerUncheckedCreateWithoutUsersInput = {
    id?: string
    email: string
    passwordHash: string
    companyName: string
    contactName: string
    phone: string
    ibCode: string
    domain?: string | null
    logo?: string | null
    favicon?: string | null
    brandColor?: string
    brandName?: string | null
    isActive?: boolean
    isApproved?: boolean
    currentTraders?: string | null
    message?: string | null
    companyDocument?: string | null
    idDocument?: string | null
    kycDocument?: string | null
    kycStatus?: string
    emailVerified?: boolean
    verificationCode?: string | null
    verificationExpiry?: Date | string | null
    pricingTier?: string
    monthlyFee?: number
    traderLimit?: number
    spreadRevShare?: number
    totalTraders?: number
    activeTraders?: number
    monthlyRevenue?: number
    lifetimeRevenue?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedAt?: Date | string | null
    approvedBy?: string | null
    anonymousAccounts?: AnonymousAccountUncheckedCreateNestedManyWithoutIbPartnerInput
    commissions?: IBCommissionUncheckedCreateNestedManyWithoutIbPartnerInput
    commissionRates?: IBCommissionRateUncheckedCreateNestedManyWithoutIbPartnerInput
  }

  export type IBPartnerCreateOrConnectWithoutUsersInput = {
    where: IBPartnerWhereUniqueInput
    create: XOR<IBPartnerCreateWithoutUsersInput, IBPartnerUncheckedCreateWithoutUsersInput>
  }

  export type MT5AccountCreateWithoutUserInput = {
    id?: string
    accountNumber: string
    broker: string
    serverName: string
    login: string
    password?: string | null
    vpsIp?: string | null
    vpsPort?: number | null
    status?: $Enums.AccountStatus
    balance?: number
    equity?: number
    margin?: number
    freeMargin?: number
    isEnabledForTrading?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastSyncAt?: Date | string | null
    eas?: EACreateNestedManyWithoutMt5AccountInput
    trades?: TradeCreateNestedManyWithoutMt5AccountInput
  }

  export type MT5AccountUncheckedCreateWithoutUserInput = {
    id?: string
    accountNumber: string
    broker: string
    serverName: string
    login: string
    password?: string | null
    vpsIp?: string | null
    vpsPort?: number | null
    status?: $Enums.AccountStatus
    balance?: number
    equity?: number
    margin?: number
    freeMargin?: number
    isEnabledForTrading?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastSyncAt?: Date | string | null
    eas?: EAUncheckedCreateNestedManyWithoutMt5AccountInput
    trades?: TradeUncheckedCreateNestedManyWithoutMt5AccountInput
  }

  export type MT5AccountCreateOrConnectWithoutUserInput = {
    where: MT5AccountWhereUniqueInput
    create: XOR<MT5AccountCreateWithoutUserInput, MT5AccountUncheckedCreateWithoutUserInput>
  }

  export type MT5AccountCreateManyUserInputEnvelope = {
    data: MT5AccountCreateManyUserInput | MT5AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EACreateWithoutUserInput = {
    id?: string
    name: string
    version?: string | null
    magicNumber?: number | null
    status?: $Enums.EAStatus
    safetyIndicator?: $Enums.SafetyIndicator
    indicatorScore?: number
    stoppedByIndicator?: boolean
    stoppedByIndicatorAt?: Date | string | null
    maxLotSize?: number
    riskPercent?: number
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastStartAt?: Date | string | null
    lastStopAt?: Date | string | null
    uptime?: number
    totalTrades?: number
    winningTrades?: number
    totalProfit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    mt5Account: MT5AccountCreateNestedOneWithoutEasInput
  }

  export type EAUncheckedCreateWithoutUserInput = {
    id?: string
    mt5AccountId: string
    name: string
    version?: string | null
    magicNumber?: number | null
    status?: $Enums.EAStatus
    safetyIndicator?: $Enums.SafetyIndicator
    indicatorScore?: number
    stoppedByIndicator?: boolean
    stoppedByIndicatorAt?: Date | string | null
    maxLotSize?: number
    riskPercent?: number
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastStartAt?: Date | string | null
    lastStopAt?: Date | string | null
    uptime?: number
    totalTrades?: number
    winningTrades?: number
    totalProfit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EACreateOrConnectWithoutUserInput = {
    where: EAWhereUniqueInput
    create: XOR<EACreateWithoutUserInput, EAUncheckedCreateWithoutUserInput>
  }

  export type EACreateManyUserInputEnvelope = {
    data: EACreateManyUserInput | EACreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TradeCreateWithoutUserInput = {
    id?: string
    ticket: string
    symbol: string
    type: string
    volume: number
    openPrice: number
    openTime: Date | string
    closePrice?: number | null
    closeTime?: Date | string | null
    profit?: number
    commission?: number
    swap?: number
    magicNumber?: number | null
    comment?: string | null
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mt5Account: MT5AccountCreateNestedOneWithoutTradesInput
  }

  export type TradeUncheckedCreateWithoutUserInput = {
    id?: string
    mt5AccountId: string
    ticket: string
    symbol: string
    type: string
    volume: number
    openPrice: number
    openTime: Date | string
    closePrice?: number | null
    closeTime?: Date | string | null
    profit?: number
    commission?: number
    swap?: number
    magicNumber?: number | null
    comment?: string | null
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TradeCreateOrConnectWithoutUserInput = {
    where: TradeWhereUniqueInput
    create: XOR<TradeCreateWithoutUserInput, TradeUncheckedCreateWithoutUserInput>
  }

  export type TradeCreateManyUserInputEnvelope = {
    data: TradeCreateManyUserInput | TradeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationLogCreateWithoutUserInput = {
    id?: string
    channel: $Enums.AutomationActionType
    recipient: string
    subject?: string | null
    message: string
    status?: $Enums.NotificationStatus
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    failedAt?: Date | string | null
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    automation: AutomationCreateNestedOneWithoutLogsInput
  }

  export type NotificationLogUncheckedCreateWithoutUserInput = {
    id?: string
    automationId: string
    channel: $Enums.AutomationActionType
    recipient: string
    subject?: string | null
    message: string
    status?: $Enums.NotificationStatus
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    failedAt?: Date | string | null
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationLogCreateOrConnectWithoutUserInput = {
    where: NotificationLogWhereUniqueInput
    create: XOR<NotificationLogCreateWithoutUserInput, NotificationLogUncheckedCreateWithoutUserInput>
  }

  export type NotificationLogCreateManyUserInputEnvelope = {
    data: NotificationLogCreateManyUserInput | NotificationLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserInsightCreateWithoutUserInput = {
    id?: string
    winRate?: number
    avgProfitPerTrade?: number
    avgLossPerTrade?: number
    profitFactor?: number
    maxDrawdown?: number
    sharpeRatio?: number
    tradingDaysActive?: number
    avgTradesPerDay?: number
    preferredTimeframe?: string | null
    riskLevel?: string | null
    lastTradeDate?: Date | string | null
    consecutiveWins?: number
    consecutiveLosses?: number
    daysSinceLastTrade?: number
    lifetimeValue?: number
    totalRevenue?: number
    churnRisk?: number
    engagementScore?: number
    predictedNextAction?: string | null
    retentionProbability?: number
    upsellProbability?: number
    updatedAt?: Date | string
  }

  export type UserInsightUncheckedCreateWithoutUserInput = {
    id?: string
    winRate?: number
    avgProfitPerTrade?: number
    avgLossPerTrade?: number
    profitFactor?: number
    maxDrawdown?: number
    sharpeRatio?: number
    tradingDaysActive?: number
    avgTradesPerDay?: number
    preferredTimeframe?: string | null
    riskLevel?: string | null
    lastTradeDate?: Date | string | null
    consecutiveWins?: number
    consecutiveLosses?: number
    daysSinceLastTrade?: number
    lifetimeValue?: number
    totalRevenue?: number
    churnRisk?: number
    engagementScore?: number
    predictedNextAction?: string | null
    retentionProbability?: number
    upsellProbability?: number
    updatedAt?: Date | string
  }

  export type UserInsightCreateOrConnectWithoutUserInput = {
    where: UserInsightWhereUniqueInput
    create: XOR<UserInsightCreateWithoutUserInput, UserInsightUncheckedCreateWithoutUserInput>
  }

  export type AutomationCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    triggerType: $Enums.AutomationTriggerType
    triggerValue?: number | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    actionTypes?: AutomationCreateactionTypesInput | $Enums.AutomationActionType[]
    actionData?: NullableJsonNullValueInput | InputJsonValue
    messageSubject?: string | null
    messageBody: string
    status?: $Enums.AutomationStatus
    priority?: number
    isUserEnabled?: boolean
    totalTriggered?: number
    totalSent?: number
    totalFailed?: number
    lastTriggered?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    logs?: NotificationLogCreateNestedManyWithoutAutomationInput
  }

  export type AutomationUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    triggerType: $Enums.AutomationTriggerType
    triggerValue?: number | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    actionTypes?: AutomationCreateactionTypesInput | $Enums.AutomationActionType[]
    actionData?: NullableJsonNullValueInput | InputJsonValue
    messageSubject?: string | null
    messageBody: string
    status?: $Enums.AutomationStatus
    priority?: number
    isUserEnabled?: boolean
    totalTriggered?: number
    totalSent?: number
    totalFailed?: number
    lastTriggered?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    logs?: NotificationLogUncheckedCreateNestedManyWithoutAutomationInput
  }

  export type AutomationCreateOrConnectWithoutUserInput = {
    where: AutomationWhereUniqueInput
    create: XOR<AutomationCreateWithoutUserInput, AutomationUncheckedCreateWithoutUserInput>
  }

  export type AutomationCreateManyUserInputEnvelope = {
    data: AutomationCreateManyUserInput | AutomationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LeaderboardEntryCreateWithoutUserInput = {
    id?: string
    period: string
    periodDate: Date | string
    trades?: number
    winningTrades?: number
    losingTrades?: number
    profit?: number
    volume?: number
    winRate?: number
    rank?: number | null
    previousRank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaderboardEntryUncheckedCreateWithoutUserInput = {
    id?: string
    period: string
    periodDate: Date | string
    trades?: number
    winningTrades?: number
    losingTrades?: number
    profit?: number
    volume?: number
    winRate?: number
    rank?: number | null
    previousRank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaderboardEntryCreateOrConnectWithoutUserInput = {
    where: LeaderboardEntryWhereUniqueInput
    create: XOR<LeaderboardEntryCreateWithoutUserInput, LeaderboardEntryUncheckedCreateWithoutUserInput>
  }

  export type LeaderboardEntryCreateManyUserInputEnvelope = {
    data: LeaderboardEntryCreateManyUserInput | LeaderboardEntryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AgentCreateWithoutUserInput = {
    id?: string
    machineId: string
    machineName?: string | null
    isPoolAgent?: boolean
    managedAccounts?: AgentCreatemanagedAccountsInput | string[]
    maxCapacity?: number
    currentLoad?: number
    vpsName?: string | null
    vpsRegion?: string | null
    vpsIp?: string | null
    mt5AccountNumber?: string | null
    mt5Broker?: string | null
    mt5ServerName?: string | null
    mt5Version?: string | null
    status?: string
    lastHeartbeat?: Date | string | null
    connectedAt?: Date | string | null
    disconnectedAt?: Date | string | null
    eaLoaded?: boolean
    eaRunning?: boolean
    eaName?: string | null
    chartSymbol?: string | null
    chartTimeframe?: string | null
    tradeCopierActive?: boolean
    isMasterAccount?: boolean
    totalTrades?: number
    profitableTrades?: number
    losingTrades?: number
    totalProfit?: number
    winRate?: number
    indicatorSettings?: NullableJsonNullValueInput | InputJsonValue
    aiOptimizationScore?: number
    lastOptimizedAt?: Date | string | null
    apiKey?: string | null
    osVersion?: string | null
    agentVersion?: string | null
    cpuUsage?: number | null
    memoryUsage?: number | null
    diskUsage?: number | null
    mt5InstanceCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    masterAgent?: AgentCreateNestedOneWithoutSlaveAgentsInput
    slaveAgents?: AgentCreateNestedManyWithoutMasterAgentInput
    accountAssignments?: MT5AccountAssignmentCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutUserInput = {
    id?: string
    machineId: string
    machineName?: string | null
    isPoolAgent?: boolean
    managedAccounts?: AgentCreatemanagedAccountsInput | string[]
    maxCapacity?: number
    currentLoad?: number
    vpsName?: string | null
    vpsRegion?: string | null
    vpsIp?: string | null
    mt5AccountNumber?: string | null
    mt5Broker?: string | null
    mt5ServerName?: string | null
    mt5Version?: string | null
    status?: string
    lastHeartbeat?: Date | string | null
    connectedAt?: Date | string | null
    disconnectedAt?: Date | string | null
    eaLoaded?: boolean
    eaRunning?: boolean
    eaName?: string | null
    chartSymbol?: string | null
    chartTimeframe?: string | null
    tradeCopierActive?: boolean
    isMasterAccount?: boolean
    masterAgentId?: string | null
    totalTrades?: number
    profitableTrades?: number
    losingTrades?: number
    totalProfit?: number
    winRate?: number
    indicatorSettings?: NullableJsonNullValueInput | InputJsonValue
    aiOptimizationScore?: number
    lastOptimizedAt?: Date | string | null
    apiKey?: string | null
    osVersion?: string | null
    agentVersion?: string | null
    cpuUsage?: number | null
    memoryUsage?: number | null
    diskUsage?: number | null
    mt5InstanceCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slaveAgents?: AgentUncheckedCreateNestedManyWithoutMasterAgentInput
    accountAssignments?: MT5AccountAssignmentUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutUserInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutUserInput, AgentUncheckedCreateWithoutUserInput>
  }

  export type AgentCreateManyUserInputEnvelope = {
    data: AgentCreateManyUserInput | AgentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MT5AccountAssignmentCreateWithoutUserInput = {
    id?: string
    mt5AccountNumber: string
    mt5Broker?: string | null
    mt5ServerName?: string | null
    assignedAt?: Date | string
    isActive?: boolean
    status?: string
    eaStatus?: string
    lastHeartbeat?: Date | string | null
    balance?: number
    equity?: number
    margin?: number
    freeMargin?: number
    profit?: number
    eaLoaded?: boolean
    eaRunning?: boolean
    eaName?: string | null
    chartSymbol?: string | null
    chartTimeframe?: string | null
    totalTrades?: number
    profitableTrades?: number
    losingTrades?: number
    totalProfit?: number
    winRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutAccountAssignmentsInput
  }

  export type MT5AccountAssignmentUncheckedCreateWithoutUserInput = {
    id?: string
    agentId: string
    mt5AccountNumber: string
    mt5Broker?: string | null
    mt5ServerName?: string | null
    assignedAt?: Date | string
    isActive?: boolean
    status?: string
    eaStatus?: string
    lastHeartbeat?: Date | string | null
    balance?: number
    equity?: number
    margin?: number
    freeMargin?: number
    profit?: number
    eaLoaded?: boolean
    eaRunning?: boolean
    eaName?: string | null
    chartSymbol?: string | null
    chartTimeframe?: string | null
    totalTrades?: number
    profitableTrades?: number
    losingTrades?: number
    totalProfit?: number
    winRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MT5AccountAssignmentCreateOrConnectWithoutUserInput = {
    where: MT5AccountAssignmentWhereUniqueInput
    create: XOR<MT5AccountAssignmentCreateWithoutUserInput, MT5AccountAssignmentUncheckedCreateWithoutUserInput>
  }

  export type MT5AccountAssignmentCreateManyUserInputEnvelope = {
    data: MT5AccountAssignmentCreateManyUserInput | MT5AccountAssignmentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AnonymousAccountCreateWithoutUserInput = {
    id?: string
    anonymousId: string
    mt5AccountNumber: string
    isActive?: boolean
    registeredAt?: Date | string
    ibPartner: IBPartnerCreateNestedOneWithoutAnonymousAccountsInput
    commissions?: IBCommissionCreateNestedManyWithoutAnonymousAccountInput
  }

  export type AnonymousAccountUncheckedCreateWithoutUserInput = {
    id?: string
    anonymousId: string
    mt5AccountNumber: string
    ibPartnerId: string
    isActive?: boolean
    registeredAt?: Date | string
    commissions?: IBCommissionUncheckedCreateNestedManyWithoutAnonymousAccountInput
  }

  export type AnonymousAccountCreateOrConnectWithoutUserInput = {
    where: AnonymousAccountWhereUniqueInput
    create: XOR<AnonymousAccountCreateWithoutUserInput, AnonymousAccountUncheckedCreateWithoutUserInput>
  }

  export type AnonymousAccountCreateManyUserInputEnvelope = {
    data: AnonymousAccountCreateManyUserInput | AnonymousAccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type IBPartnerUpsertWithoutUsersInput = {
    update: XOR<IBPartnerUpdateWithoutUsersInput, IBPartnerUncheckedUpdateWithoutUsersInput>
    create: XOR<IBPartnerCreateWithoutUsersInput, IBPartnerUncheckedCreateWithoutUsersInput>
    where?: IBPartnerWhereInput
  }

  export type IBPartnerUpdateToOneWithWhereWithoutUsersInput = {
    where?: IBPartnerWhereInput
    data: XOR<IBPartnerUpdateWithoutUsersInput, IBPartnerUncheckedUpdateWithoutUsersInput>
  }

  export type IBPartnerUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    ibCode?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    brandColor?: StringFieldUpdateOperationsInput | string
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    currentTraders?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    companyDocument?: NullableStringFieldUpdateOperationsInput | string | null
    idDocument?: NullableStringFieldUpdateOperationsInput | string | null
    kycDocument?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pricingTier?: StringFieldUpdateOperationsInput | string
    monthlyFee?: FloatFieldUpdateOperationsInput | number
    traderLimit?: IntFieldUpdateOperationsInput | number
    spreadRevShare?: FloatFieldUpdateOperationsInput | number
    totalTraders?: IntFieldUpdateOperationsInput | number
    activeTraders?: IntFieldUpdateOperationsInput | number
    monthlyRevenue?: FloatFieldUpdateOperationsInput | number
    lifetimeRevenue?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    anonymousAccounts?: AnonymousAccountUpdateManyWithoutIbPartnerNestedInput
    commissions?: IBCommissionUpdateManyWithoutIbPartnerNestedInput
    commissionRates?: IBCommissionRateUpdateManyWithoutIbPartnerNestedInput
  }

  export type IBPartnerUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    ibCode?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    brandColor?: StringFieldUpdateOperationsInput | string
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    currentTraders?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    companyDocument?: NullableStringFieldUpdateOperationsInput | string | null
    idDocument?: NullableStringFieldUpdateOperationsInput | string | null
    kycDocument?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pricingTier?: StringFieldUpdateOperationsInput | string
    monthlyFee?: FloatFieldUpdateOperationsInput | number
    traderLimit?: IntFieldUpdateOperationsInput | number
    spreadRevShare?: FloatFieldUpdateOperationsInput | number
    totalTraders?: IntFieldUpdateOperationsInput | number
    activeTraders?: IntFieldUpdateOperationsInput | number
    monthlyRevenue?: FloatFieldUpdateOperationsInput | number
    lifetimeRevenue?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    anonymousAccounts?: AnonymousAccountUncheckedUpdateManyWithoutIbPartnerNestedInput
    commissions?: IBCommissionUncheckedUpdateManyWithoutIbPartnerNestedInput
    commissionRates?: IBCommissionRateUncheckedUpdateManyWithoutIbPartnerNestedInput
  }

  export type MT5AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: MT5AccountWhereUniqueInput
    update: XOR<MT5AccountUpdateWithoutUserInput, MT5AccountUncheckedUpdateWithoutUserInput>
    create: XOR<MT5AccountCreateWithoutUserInput, MT5AccountUncheckedCreateWithoutUserInput>
  }

  export type MT5AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: MT5AccountWhereUniqueInput
    data: XOR<MT5AccountUpdateWithoutUserInput, MT5AccountUncheckedUpdateWithoutUserInput>
  }

  export type MT5AccountUpdateManyWithWhereWithoutUserInput = {
    where: MT5AccountScalarWhereInput
    data: XOR<MT5AccountUpdateManyMutationInput, MT5AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type MT5AccountScalarWhereInput = {
    AND?: MT5AccountScalarWhereInput | MT5AccountScalarWhereInput[]
    OR?: MT5AccountScalarWhereInput[]
    NOT?: MT5AccountScalarWhereInput | MT5AccountScalarWhereInput[]
    id?: StringFilter<"MT5Account"> | string
    userId?: StringFilter<"MT5Account"> | string
    accountNumber?: StringFilter<"MT5Account"> | string
    broker?: StringFilter<"MT5Account"> | string
    serverName?: StringFilter<"MT5Account"> | string
    login?: StringFilter<"MT5Account"> | string
    password?: StringNullableFilter<"MT5Account"> | string | null
    vpsIp?: StringNullableFilter<"MT5Account"> | string | null
    vpsPort?: IntNullableFilter<"MT5Account"> | number | null
    status?: EnumAccountStatusFilter<"MT5Account"> | $Enums.AccountStatus
    balance?: FloatFilter<"MT5Account"> | number
    equity?: FloatFilter<"MT5Account"> | number
    margin?: FloatFilter<"MT5Account"> | number
    freeMargin?: FloatFilter<"MT5Account"> | number
    isEnabledForTrading?: BoolFilter<"MT5Account"> | boolean
    createdAt?: DateTimeFilter<"MT5Account"> | Date | string
    updatedAt?: DateTimeFilter<"MT5Account"> | Date | string
    lastSyncAt?: DateTimeNullableFilter<"MT5Account"> | Date | string | null
  }

  export type EAUpsertWithWhereUniqueWithoutUserInput = {
    where: EAWhereUniqueInput
    update: XOR<EAUpdateWithoutUserInput, EAUncheckedUpdateWithoutUserInput>
    create: XOR<EACreateWithoutUserInput, EAUncheckedCreateWithoutUserInput>
  }

  export type EAUpdateWithWhereUniqueWithoutUserInput = {
    where: EAWhereUniqueInput
    data: XOR<EAUpdateWithoutUserInput, EAUncheckedUpdateWithoutUserInput>
  }

  export type EAUpdateManyWithWhereWithoutUserInput = {
    where: EAScalarWhereInput
    data: XOR<EAUpdateManyMutationInput, EAUncheckedUpdateManyWithoutUserInput>
  }

  export type EAScalarWhereInput = {
    AND?: EAScalarWhereInput | EAScalarWhereInput[]
    OR?: EAScalarWhereInput[]
    NOT?: EAScalarWhereInput | EAScalarWhereInput[]
    id?: StringFilter<"EA"> | string
    userId?: StringFilter<"EA"> | string
    mt5AccountId?: StringFilter<"EA"> | string
    name?: StringFilter<"EA"> | string
    version?: StringNullableFilter<"EA"> | string | null
    magicNumber?: IntNullableFilter<"EA"> | number | null
    status?: EnumEAStatusFilter<"EA"> | $Enums.EAStatus
    safetyIndicator?: EnumSafetyIndicatorFilter<"EA"> | $Enums.SafetyIndicator
    indicatorScore?: FloatFilter<"EA"> | number
    stoppedByIndicator?: BoolFilter<"EA"> | boolean
    stoppedByIndicatorAt?: DateTimeNullableFilter<"EA"> | Date | string | null
    maxLotSize?: FloatFilter<"EA"> | number
    riskPercent?: FloatFilter<"EA"> | number
    settings?: JsonNullableFilter<"EA">
    lastStartAt?: DateTimeNullableFilter<"EA"> | Date | string | null
    lastStopAt?: DateTimeNullableFilter<"EA"> | Date | string | null
    uptime?: IntFilter<"EA"> | number
    totalTrades?: IntFilter<"EA"> | number
    winningTrades?: IntFilter<"EA"> | number
    totalProfit?: FloatFilter<"EA"> | number
    createdAt?: DateTimeFilter<"EA"> | Date | string
    updatedAt?: DateTimeFilter<"EA"> | Date | string
  }

  export type TradeUpsertWithWhereUniqueWithoutUserInput = {
    where: TradeWhereUniqueInput
    update: XOR<TradeUpdateWithoutUserInput, TradeUncheckedUpdateWithoutUserInput>
    create: XOR<TradeCreateWithoutUserInput, TradeUncheckedCreateWithoutUserInput>
  }

  export type TradeUpdateWithWhereUniqueWithoutUserInput = {
    where: TradeWhereUniqueInput
    data: XOR<TradeUpdateWithoutUserInput, TradeUncheckedUpdateWithoutUserInput>
  }

  export type TradeUpdateManyWithWhereWithoutUserInput = {
    where: TradeScalarWhereInput
    data: XOR<TradeUpdateManyMutationInput, TradeUncheckedUpdateManyWithoutUserInput>
  }

  export type TradeScalarWhereInput = {
    AND?: TradeScalarWhereInput | TradeScalarWhereInput[]
    OR?: TradeScalarWhereInput[]
    NOT?: TradeScalarWhereInput | TradeScalarWhereInput[]
    id?: StringFilter<"Trade"> | string
    userId?: StringFilter<"Trade"> | string
    mt5AccountId?: StringFilter<"Trade"> | string
    ticket?: StringFilter<"Trade"> | string
    symbol?: StringFilter<"Trade"> | string
    type?: StringFilter<"Trade"> | string
    volume?: FloatFilter<"Trade"> | number
    openPrice?: FloatFilter<"Trade"> | number
    openTime?: DateTimeFilter<"Trade"> | Date | string
    closePrice?: FloatNullableFilter<"Trade"> | number | null
    closeTime?: DateTimeNullableFilter<"Trade"> | Date | string | null
    profit?: FloatFilter<"Trade"> | number
    commission?: FloatFilter<"Trade"> | number
    swap?: FloatFilter<"Trade"> | number
    magicNumber?: IntNullableFilter<"Trade"> | number | null
    comment?: StringNullableFilter<"Trade"> | string | null
    isClosed?: BoolFilter<"Trade"> | boolean
    createdAt?: DateTimeFilter<"Trade"> | Date | string
    updatedAt?: DateTimeFilter<"Trade"> | Date | string
  }

  export type NotificationLogUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationLogWhereUniqueInput
    update: XOR<NotificationLogUpdateWithoutUserInput, NotificationLogUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationLogCreateWithoutUserInput, NotificationLogUncheckedCreateWithoutUserInput>
  }

  export type NotificationLogUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationLogWhereUniqueInput
    data: XOR<NotificationLogUpdateWithoutUserInput, NotificationLogUncheckedUpdateWithoutUserInput>
  }

  export type NotificationLogUpdateManyWithWhereWithoutUserInput = {
    where: NotificationLogScalarWhereInput
    data: XOR<NotificationLogUpdateManyMutationInput, NotificationLogUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationLogScalarWhereInput = {
    AND?: NotificationLogScalarWhereInput | NotificationLogScalarWhereInput[]
    OR?: NotificationLogScalarWhereInput[]
    NOT?: NotificationLogScalarWhereInput | NotificationLogScalarWhereInput[]
    id?: StringFilter<"NotificationLog"> | string
    automationId?: StringFilter<"NotificationLog"> | string
    userId?: StringFilter<"NotificationLog"> | string
    channel?: EnumAutomationActionTypeFilter<"NotificationLog"> | $Enums.AutomationActionType
    recipient?: StringFilter<"NotificationLog"> | string
    subject?: StringNullableFilter<"NotificationLog"> | string | null
    message?: StringFilter<"NotificationLog"> | string
    status?: EnumNotificationStatusFilter<"NotificationLog"> | $Enums.NotificationStatus
    sentAt?: DateTimeNullableFilter<"NotificationLog"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"NotificationLog"> | Date | string | null
    failedAt?: DateTimeNullableFilter<"NotificationLog"> | Date | string | null
    errorMessage?: StringNullableFilter<"NotificationLog"> | string | null
    metadata?: JsonNullableFilter<"NotificationLog">
    createdAt?: DateTimeFilter<"NotificationLog"> | Date | string
  }

  export type UserInsightUpsertWithoutUserInput = {
    update: XOR<UserInsightUpdateWithoutUserInput, UserInsightUncheckedUpdateWithoutUserInput>
    create: XOR<UserInsightCreateWithoutUserInput, UserInsightUncheckedCreateWithoutUserInput>
    where?: UserInsightWhereInput
  }

  export type UserInsightUpdateToOneWithWhereWithoutUserInput = {
    where?: UserInsightWhereInput
    data: XOR<UserInsightUpdateWithoutUserInput, UserInsightUncheckedUpdateWithoutUserInput>
  }

  export type UserInsightUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    winRate?: FloatFieldUpdateOperationsInput | number
    avgProfitPerTrade?: FloatFieldUpdateOperationsInput | number
    avgLossPerTrade?: FloatFieldUpdateOperationsInput | number
    profitFactor?: FloatFieldUpdateOperationsInput | number
    maxDrawdown?: FloatFieldUpdateOperationsInput | number
    sharpeRatio?: FloatFieldUpdateOperationsInput | number
    tradingDaysActive?: IntFieldUpdateOperationsInput | number
    avgTradesPerDay?: FloatFieldUpdateOperationsInput | number
    preferredTimeframe?: NullableStringFieldUpdateOperationsInput | string | null
    riskLevel?: NullableStringFieldUpdateOperationsInput | string | null
    lastTradeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consecutiveWins?: IntFieldUpdateOperationsInput | number
    consecutiveLosses?: IntFieldUpdateOperationsInput | number
    daysSinceLastTrade?: IntFieldUpdateOperationsInput | number
    lifetimeValue?: FloatFieldUpdateOperationsInput | number
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    churnRisk?: FloatFieldUpdateOperationsInput | number
    engagementScore?: FloatFieldUpdateOperationsInput | number
    predictedNextAction?: NullableStringFieldUpdateOperationsInput | string | null
    retentionProbability?: FloatFieldUpdateOperationsInput | number
    upsellProbability?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserInsightUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    winRate?: FloatFieldUpdateOperationsInput | number
    avgProfitPerTrade?: FloatFieldUpdateOperationsInput | number
    avgLossPerTrade?: FloatFieldUpdateOperationsInput | number
    profitFactor?: FloatFieldUpdateOperationsInput | number
    maxDrawdown?: FloatFieldUpdateOperationsInput | number
    sharpeRatio?: FloatFieldUpdateOperationsInput | number
    tradingDaysActive?: IntFieldUpdateOperationsInput | number
    avgTradesPerDay?: FloatFieldUpdateOperationsInput | number
    preferredTimeframe?: NullableStringFieldUpdateOperationsInput | string | null
    riskLevel?: NullableStringFieldUpdateOperationsInput | string | null
    lastTradeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consecutiveWins?: IntFieldUpdateOperationsInput | number
    consecutiveLosses?: IntFieldUpdateOperationsInput | number
    daysSinceLastTrade?: IntFieldUpdateOperationsInput | number
    lifetimeValue?: FloatFieldUpdateOperationsInput | number
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    churnRisk?: FloatFieldUpdateOperationsInput | number
    engagementScore?: FloatFieldUpdateOperationsInput | number
    predictedNextAction?: NullableStringFieldUpdateOperationsInput | string | null
    retentionProbability?: FloatFieldUpdateOperationsInput | number
    upsellProbability?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutomationUpsertWithWhereUniqueWithoutUserInput = {
    where: AutomationWhereUniqueInput
    update: XOR<AutomationUpdateWithoutUserInput, AutomationUncheckedUpdateWithoutUserInput>
    create: XOR<AutomationCreateWithoutUserInput, AutomationUncheckedCreateWithoutUserInput>
  }

  export type AutomationUpdateWithWhereUniqueWithoutUserInput = {
    where: AutomationWhereUniqueInput
    data: XOR<AutomationUpdateWithoutUserInput, AutomationUncheckedUpdateWithoutUserInput>
  }

  export type AutomationUpdateManyWithWhereWithoutUserInput = {
    where: AutomationScalarWhereInput
    data: XOR<AutomationUpdateManyMutationInput, AutomationUncheckedUpdateManyWithoutUserInput>
  }

  export type AutomationScalarWhereInput = {
    AND?: AutomationScalarWhereInput | AutomationScalarWhereInput[]
    OR?: AutomationScalarWhereInput[]
    NOT?: AutomationScalarWhereInput | AutomationScalarWhereInput[]
    id?: StringFilter<"Automation"> | string
    name?: StringFilter<"Automation"> | string
    description?: StringNullableFilter<"Automation"> | string | null
    userId?: StringNullableFilter<"Automation"> | string | null
    triggerType?: EnumAutomationTriggerTypeFilter<"Automation"> | $Enums.AutomationTriggerType
    triggerValue?: IntNullableFilter<"Automation"> | number | null
    triggerData?: JsonNullableFilter<"Automation">
    actionTypes?: EnumAutomationActionTypeNullableListFilter<"Automation">
    actionData?: JsonNullableFilter<"Automation">
    messageSubject?: StringNullableFilter<"Automation"> | string | null
    messageBody?: StringFilter<"Automation"> | string
    status?: EnumAutomationStatusFilter<"Automation"> | $Enums.AutomationStatus
    priority?: IntFilter<"Automation"> | number
    isUserEnabled?: BoolFilter<"Automation"> | boolean
    totalTriggered?: IntFilter<"Automation"> | number
    totalSent?: IntFilter<"Automation"> | number
    totalFailed?: IntFilter<"Automation"> | number
    lastTriggered?: DateTimeNullableFilter<"Automation"> | Date | string | null
    createdAt?: DateTimeFilter<"Automation"> | Date | string
    updatedAt?: DateTimeFilter<"Automation"> | Date | string
    createdBy?: StringNullableFilter<"Automation"> | string | null
  }

  export type LeaderboardEntryUpsertWithWhereUniqueWithoutUserInput = {
    where: LeaderboardEntryWhereUniqueInput
    update: XOR<LeaderboardEntryUpdateWithoutUserInput, LeaderboardEntryUncheckedUpdateWithoutUserInput>
    create: XOR<LeaderboardEntryCreateWithoutUserInput, LeaderboardEntryUncheckedCreateWithoutUserInput>
  }

  export type LeaderboardEntryUpdateWithWhereUniqueWithoutUserInput = {
    where: LeaderboardEntryWhereUniqueInput
    data: XOR<LeaderboardEntryUpdateWithoutUserInput, LeaderboardEntryUncheckedUpdateWithoutUserInput>
  }

  export type LeaderboardEntryUpdateManyWithWhereWithoutUserInput = {
    where: LeaderboardEntryScalarWhereInput
    data: XOR<LeaderboardEntryUpdateManyMutationInput, LeaderboardEntryUncheckedUpdateManyWithoutUserInput>
  }

  export type LeaderboardEntryScalarWhereInput = {
    AND?: LeaderboardEntryScalarWhereInput | LeaderboardEntryScalarWhereInput[]
    OR?: LeaderboardEntryScalarWhereInput[]
    NOT?: LeaderboardEntryScalarWhereInput | LeaderboardEntryScalarWhereInput[]
    id?: StringFilter<"LeaderboardEntry"> | string
    userId?: StringFilter<"LeaderboardEntry"> | string
    period?: StringFilter<"LeaderboardEntry"> | string
    periodDate?: DateTimeFilter<"LeaderboardEntry"> | Date | string
    trades?: IntFilter<"LeaderboardEntry"> | number
    winningTrades?: IntFilter<"LeaderboardEntry"> | number
    losingTrades?: IntFilter<"LeaderboardEntry"> | number
    profit?: FloatFilter<"LeaderboardEntry"> | number
    volume?: FloatFilter<"LeaderboardEntry"> | number
    winRate?: FloatFilter<"LeaderboardEntry"> | number
    rank?: IntNullableFilter<"LeaderboardEntry"> | number | null
    previousRank?: IntNullableFilter<"LeaderboardEntry"> | number | null
    createdAt?: DateTimeFilter<"LeaderboardEntry"> | Date | string
    updatedAt?: DateTimeFilter<"LeaderboardEntry"> | Date | string
  }

  export type AgentUpsertWithWhereUniqueWithoutUserInput = {
    where: AgentWhereUniqueInput
    update: XOR<AgentUpdateWithoutUserInput, AgentUncheckedUpdateWithoutUserInput>
    create: XOR<AgentCreateWithoutUserInput, AgentUncheckedCreateWithoutUserInput>
  }

  export type AgentUpdateWithWhereUniqueWithoutUserInput = {
    where: AgentWhereUniqueInput
    data: XOR<AgentUpdateWithoutUserInput, AgentUncheckedUpdateWithoutUserInput>
  }

  export type AgentUpdateManyWithWhereWithoutUserInput = {
    where: AgentScalarWhereInput
    data: XOR<AgentUpdateManyMutationInput, AgentUncheckedUpdateManyWithoutUserInput>
  }

  export type AgentScalarWhereInput = {
    AND?: AgentScalarWhereInput | AgentScalarWhereInput[]
    OR?: AgentScalarWhereInput[]
    NOT?: AgentScalarWhereInput | AgentScalarWhereInput[]
    id?: StringFilter<"Agent"> | string
    userId?: StringNullableFilter<"Agent"> | string | null
    machineId?: StringFilter<"Agent"> | string
    machineName?: StringNullableFilter<"Agent"> | string | null
    isPoolAgent?: BoolFilter<"Agent"> | boolean
    managedAccounts?: StringNullableListFilter<"Agent">
    maxCapacity?: IntFilter<"Agent"> | number
    currentLoad?: IntFilter<"Agent"> | number
    vpsName?: StringNullableFilter<"Agent"> | string | null
    vpsRegion?: StringNullableFilter<"Agent"> | string | null
    vpsIp?: StringNullableFilter<"Agent"> | string | null
    mt5AccountNumber?: StringNullableFilter<"Agent"> | string | null
    mt5Broker?: StringNullableFilter<"Agent"> | string | null
    mt5ServerName?: StringNullableFilter<"Agent"> | string | null
    mt5Version?: StringNullableFilter<"Agent"> | string | null
    status?: StringFilter<"Agent"> | string
    lastHeartbeat?: DateTimeNullableFilter<"Agent"> | Date | string | null
    connectedAt?: DateTimeNullableFilter<"Agent"> | Date | string | null
    disconnectedAt?: DateTimeNullableFilter<"Agent"> | Date | string | null
    eaLoaded?: BoolFilter<"Agent"> | boolean
    eaRunning?: BoolFilter<"Agent"> | boolean
    eaName?: StringNullableFilter<"Agent"> | string | null
    chartSymbol?: StringNullableFilter<"Agent"> | string | null
    chartTimeframe?: StringNullableFilter<"Agent"> | string | null
    tradeCopierActive?: BoolFilter<"Agent"> | boolean
    isMasterAccount?: BoolFilter<"Agent"> | boolean
    masterAgentId?: StringNullableFilter<"Agent"> | string | null
    totalTrades?: IntFilter<"Agent"> | number
    profitableTrades?: IntFilter<"Agent"> | number
    losingTrades?: IntFilter<"Agent"> | number
    totalProfit?: FloatFilter<"Agent"> | number
    winRate?: FloatFilter<"Agent"> | number
    indicatorSettings?: JsonNullableFilter<"Agent">
    aiOptimizationScore?: FloatFilter<"Agent"> | number
    lastOptimizedAt?: DateTimeNullableFilter<"Agent"> | Date | string | null
    apiKey?: StringNullableFilter<"Agent"> | string | null
    osVersion?: StringNullableFilter<"Agent"> | string | null
    agentVersion?: StringNullableFilter<"Agent"> | string | null
    cpuUsage?: FloatNullableFilter<"Agent"> | number | null
    memoryUsage?: FloatNullableFilter<"Agent"> | number | null
    diskUsage?: FloatNullableFilter<"Agent"> | number | null
    mt5InstanceCount?: IntFilter<"Agent"> | number
    createdAt?: DateTimeFilter<"Agent"> | Date | string
    updatedAt?: DateTimeFilter<"Agent"> | Date | string
  }

  export type MT5AccountAssignmentUpsertWithWhereUniqueWithoutUserInput = {
    where: MT5AccountAssignmentWhereUniqueInput
    update: XOR<MT5AccountAssignmentUpdateWithoutUserInput, MT5AccountAssignmentUncheckedUpdateWithoutUserInput>
    create: XOR<MT5AccountAssignmentCreateWithoutUserInput, MT5AccountAssignmentUncheckedCreateWithoutUserInput>
  }

  export type MT5AccountAssignmentUpdateWithWhereUniqueWithoutUserInput = {
    where: MT5AccountAssignmentWhereUniqueInput
    data: XOR<MT5AccountAssignmentUpdateWithoutUserInput, MT5AccountAssignmentUncheckedUpdateWithoutUserInput>
  }

  export type MT5AccountAssignmentUpdateManyWithWhereWithoutUserInput = {
    where: MT5AccountAssignmentScalarWhereInput
    data: XOR<MT5AccountAssignmentUpdateManyMutationInput, MT5AccountAssignmentUncheckedUpdateManyWithoutUserInput>
  }

  export type MT5AccountAssignmentScalarWhereInput = {
    AND?: MT5AccountAssignmentScalarWhereInput | MT5AccountAssignmentScalarWhereInput[]
    OR?: MT5AccountAssignmentScalarWhereInput[]
    NOT?: MT5AccountAssignmentScalarWhereInput | MT5AccountAssignmentScalarWhereInput[]
    id?: StringFilter<"MT5AccountAssignment"> | string
    userId?: StringFilter<"MT5AccountAssignment"> | string
    agentId?: StringFilter<"MT5AccountAssignment"> | string
    mt5AccountNumber?: StringFilter<"MT5AccountAssignment"> | string
    mt5Broker?: StringNullableFilter<"MT5AccountAssignment"> | string | null
    mt5ServerName?: StringNullableFilter<"MT5AccountAssignment"> | string | null
    assignedAt?: DateTimeFilter<"MT5AccountAssignment"> | Date | string
    isActive?: BoolFilter<"MT5AccountAssignment"> | boolean
    status?: StringFilter<"MT5AccountAssignment"> | string
    eaStatus?: StringFilter<"MT5AccountAssignment"> | string
    lastHeartbeat?: DateTimeNullableFilter<"MT5AccountAssignment"> | Date | string | null
    balance?: FloatFilter<"MT5AccountAssignment"> | number
    equity?: FloatFilter<"MT5AccountAssignment"> | number
    margin?: FloatFilter<"MT5AccountAssignment"> | number
    freeMargin?: FloatFilter<"MT5AccountAssignment"> | number
    profit?: FloatFilter<"MT5AccountAssignment"> | number
    eaLoaded?: BoolFilter<"MT5AccountAssignment"> | boolean
    eaRunning?: BoolFilter<"MT5AccountAssignment"> | boolean
    eaName?: StringNullableFilter<"MT5AccountAssignment"> | string | null
    chartSymbol?: StringNullableFilter<"MT5AccountAssignment"> | string | null
    chartTimeframe?: StringNullableFilter<"MT5AccountAssignment"> | string | null
    totalTrades?: IntFilter<"MT5AccountAssignment"> | number
    profitableTrades?: IntFilter<"MT5AccountAssignment"> | number
    losingTrades?: IntFilter<"MT5AccountAssignment"> | number
    totalProfit?: FloatFilter<"MT5AccountAssignment"> | number
    winRate?: FloatFilter<"MT5AccountAssignment"> | number
    createdAt?: DateTimeFilter<"MT5AccountAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"MT5AccountAssignment"> | Date | string
  }

  export type AnonymousAccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AnonymousAccountWhereUniqueInput
    update: XOR<AnonymousAccountUpdateWithoutUserInput, AnonymousAccountUncheckedUpdateWithoutUserInput>
    create: XOR<AnonymousAccountCreateWithoutUserInput, AnonymousAccountUncheckedCreateWithoutUserInput>
  }

  export type AnonymousAccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AnonymousAccountWhereUniqueInput
    data: XOR<AnonymousAccountUpdateWithoutUserInput, AnonymousAccountUncheckedUpdateWithoutUserInput>
  }

  export type AnonymousAccountUpdateManyWithWhereWithoutUserInput = {
    where: AnonymousAccountScalarWhereInput
    data: XOR<AnonymousAccountUpdateManyMutationInput, AnonymousAccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AnonymousAccountScalarWhereInput = {
    AND?: AnonymousAccountScalarWhereInput | AnonymousAccountScalarWhereInput[]
    OR?: AnonymousAccountScalarWhereInput[]
    NOT?: AnonymousAccountScalarWhereInput | AnonymousAccountScalarWhereInput[]
    id?: StringFilter<"AnonymousAccount"> | string
    anonymousId?: StringFilter<"AnonymousAccount"> | string
    userId?: StringFilter<"AnonymousAccount"> | string
    mt5AccountNumber?: StringFilter<"AnonymousAccount"> | string
    ibPartnerId?: StringFilter<"AnonymousAccount"> | string
    isActive?: BoolFilter<"AnonymousAccount"> | boolean
    registeredAt?: DateTimeFilter<"AnonymousAccount"> | Date | string
  }

  export type UserCreateWithoutMt5AccountsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    phone?: string | null
    ibCode?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    monthlyFee?: number
    totalTrades?: number
    winningTrades?: number
    losingTrades?: number
    totalProfit?: number
    totalVolume?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    lastActiveAt?: Date | string | null
    isActive?: boolean
    status?: $Enums.AccountStatus
    emailVerified?: boolean
    verificationCode?: string | null
    verificationExpiry?: Date | string | null
    ibPartner?: IBPartnerCreateNestedOneWithoutUsersInput
    eas?: EACreateNestedManyWithoutUserInput
    trades?: TradeCreateNestedManyWithoutUserInput
    notifications?: NotificationLogCreateNestedManyWithoutUserInput
    insights?: UserInsightCreateNestedOneWithoutUserInput
    automations?: AutomationCreateNestedManyWithoutUserInput
    leaderboardStats?: LeaderboardEntryCreateNestedManyWithoutUserInput
    agents?: AgentCreateNestedManyWithoutUserInput
    accountAssignments?: MT5AccountAssignmentCreateNestedManyWithoutUserInput
    anonymousAccounts?: AnonymousAccountCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMt5AccountsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    phone?: string | null
    ibCode?: string | null
    ibPartnerId?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    monthlyFee?: number
    totalTrades?: number
    winningTrades?: number
    losingTrades?: number
    totalProfit?: number
    totalVolume?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    lastActiveAt?: Date | string | null
    isActive?: boolean
    status?: $Enums.AccountStatus
    emailVerified?: boolean
    verificationCode?: string | null
    verificationExpiry?: Date | string | null
    eas?: EAUncheckedCreateNestedManyWithoutUserInput
    trades?: TradeUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationLogUncheckedCreateNestedManyWithoutUserInput
    insights?: UserInsightUncheckedCreateNestedOneWithoutUserInput
    automations?: AutomationUncheckedCreateNestedManyWithoutUserInput
    leaderboardStats?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    agents?: AgentUncheckedCreateNestedManyWithoutUserInput
    accountAssignments?: MT5AccountAssignmentUncheckedCreateNestedManyWithoutUserInput
    anonymousAccounts?: AnonymousAccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMt5AccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMt5AccountsInput, UserUncheckedCreateWithoutMt5AccountsInput>
  }

  export type EACreateWithoutMt5AccountInput = {
    id?: string
    name: string
    version?: string | null
    magicNumber?: number | null
    status?: $Enums.EAStatus
    safetyIndicator?: $Enums.SafetyIndicator
    indicatorScore?: number
    stoppedByIndicator?: boolean
    stoppedByIndicatorAt?: Date | string | null
    maxLotSize?: number
    riskPercent?: number
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastStartAt?: Date | string | null
    lastStopAt?: Date | string | null
    uptime?: number
    totalTrades?: number
    winningTrades?: number
    totalProfit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEasInput
  }

  export type EAUncheckedCreateWithoutMt5AccountInput = {
    id?: string
    userId: string
    name: string
    version?: string | null
    magicNumber?: number | null
    status?: $Enums.EAStatus
    safetyIndicator?: $Enums.SafetyIndicator
    indicatorScore?: number
    stoppedByIndicator?: boolean
    stoppedByIndicatorAt?: Date | string | null
    maxLotSize?: number
    riskPercent?: number
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastStartAt?: Date | string | null
    lastStopAt?: Date | string | null
    uptime?: number
    totalTrades?: number
    winningTrades?: number
    totalProfit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EACreateOrConnectWithoutMt5AccountInput = {
    where: EAWhereUniqueInput
    create: XOR<EACreateWithoutMt5AccountInput, EAUncheckedCreateWithoutMt5AccountInput>
  }

  export type EACreateManyMt5AccountInputEnvelope = {
    data: EACreateManyMt5AccountInput | EACreateManyMt5AccountInput[]
    skipDuplicates?: boolean
  }

  export type TradeCreateWithoutMt5AccountInput = {
    id?: string
    ticket: string
    symbol: string
    type: string
    volume: number
    openPrice: number
    openTime: Date | string
    closePrice?: number | null
    closeTime?: Date | string | null
    profit?: number
    commission?: number
    swap?: number
    magicNumber?: number | null
    comment?: string | null
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTradesInput
  }

  export type TradeUncheckedCreateWithoutMt5AccountInput = {
    id?: string
    userId: string
    ticket: string
    symbol: string
    type: string
    volume: number
    openPrice: number
    openTime: Date | string
    closePrice?: number | null
    closeTime?: Date | string | null
    profit?: number
    commission?: number
    swap?: number
    magicNumber?: number | null
    comment?: string | null
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TradeCreateOrConnectWithoutMt5AccountInput = {
    where: TradeWhereUniqueInput
    create: XOR<TradeCreateWithoutMt5AccountInput, TradeUncheckedCreateWithoutMt5AccountInput>
  }

  export type TradeCreateManyMt5AccountInputEnvelope = {
    data: TradeCreateManyMt5AccountInput | TradeCreateManyMt5AccountInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutMt5AccountsInput = {
    update: XOR<UserUpdateWithoutMt5AccountsInput, UserUncheckedUpdateWithoutMt5AccountsInput>
    create: XOR<UserCreateWithoutMt5AccountsInput, UserUncheckedCreateWithoutMt5AccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMt5AccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMt5AccountsInput, UserUncheckedUpdateWithoutMt5AccountsInput>
  }

  export type UserUpdateWithoutMt5AccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ibCode?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyFee?: FloatFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    winningTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ibPartner?: IBPartnerUpdateOneWithoutUsersNestedInput
    eas?: EAUpdateManyWithoutUserNestedInput
    trades?: TradeUpdateManyWithoutUserNestedInput
    notifications?: NotificationLogUpdateManyWithoutUserNestedInput
    insights?: UserInsightUpdateOneWithoutUserNestedInput
    automations?: AutomationUpdateManyWithoutUserNestedInput
    leaderboardStats?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    agents?: AgentUpdateManyWithoutUserNestedInput
    accountAssignments?: MT5AccountAssignmentUpdateManyWithoutUserNestedInput
    anonymousAccounts?: AnonymousAccountUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMt5AccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ibCode?: NullableStringFieldUpdateOperationsInput | string | null
    ibPartnerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyFee?: FloatFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    winningTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eas?: EAUncheckedUpdateManyWithoutUserNestedInput
    trades?: TradeUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationLogUncheckedUpdateManyWithoutUserNestedInput
    insights?: UserInsightUncheckedUpdateOneWithoutUserNestedInput
    automations?: AutomationUncheckedUpdateManyWithoutUserNestedInput
    leaderboardStats?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    agents?: AgentUncheckedUpdateManyWithoutUserNestedInput
    accountAssignments?: MT5AccountAssignmentUncheckedUpdateManyWithoutUserNestedInput
    anonymousAccounts?: AnonymousAccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EAUpsertWithWhereUniqueWithoutMt5AccountInput = {
    where: EAWhereUniqueInput
    update: XOR<EAUpdateWithoutMt5AccountInput, EAUncheckedUpdateWithoutMt5AccountInput>
    create: XOR<EACreateWithoutMt5AccountInput, EAUncheckedCreateWithoutMt5AccountInput>
  }

  export type EAUpdateWithWhereUniqueWithoutMt5AccountInput = {
    where: EAWhereUniqueInput
    data: XOR<EAUpdateWithoutMt5AccountInput, EAUncheckedUpdateWithoutMt5AccountInput>
  }

  export type EAUpdateManyWithWhereWithoutMt5AccountInput = {
    where: EAScalarWhereInput
    data: XOR<EAUpdateManyMutationInput, EAUncheckedUpdateManyWithoutMt5AccountInput>
  }

  export type TradeUpsertWithWhereUniqueWithoutMt5AccountInput = {
    where: TradeWhereUniqueInput
    update: XOR<TradeUpdateWithoutMt5AccountInput, TradeUncheckedUpdateWithoutMt5AccountInput>
    create: XOR<TradeCreateWithoutMt5AccountInput, TradeUncheckedCreateWithoutMt5AccountInput>
  }

  export type TradeUpdateWithWhereUniqueWithoutMt5AccountInput = {
    where: TradeWhereUniqueInput
    data: XOR<TradeUpdateWithoutMt5AccountInput, TradeUncheckedUpdateWithoutMt5AccountInput>
  }

  export type TradeUpdateManyWithWhereWithoutMt5AccountInput = {
    where: TradeScalarWhereInput
    data: XOR<TradeUpdateManyMutationInput, TradeUncheckedUpdateManyWithoutMt5AccountInput>
  }

  export type UserCreateWithoutEasInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    phone?: string | null
    ibCode?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    monthlyFee?: number
    totalTrades?: number
    winningTrades?: number
    losingTrades?: number
    totalProfit?: number
    totalVolume?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    lastActiveAt?: Date | string | null
    isActive?: boolean
    status?: $Enums.AccountStatus
    emailVerified?: boolean
    verificationCode?: string | null
    verificationExpiry?: Date | string | null
    ibPartner?: IBPartnerCreateNestedOneWithoutUsersInput
    mt5Accounts?: MT5AccountCreateNestedManyWithoutUserInput
    trades?: TradeCreateNestedManyWithoutUserInput
    notifications?: NotificationLogCreateNestedManyWithoutUserInput
    insights?: UserInsightCreateNestedOneWithoutUserInput
    automations?: AutomationCreateNestedManyWithoutUserInput
    leaderboardStats?: LeaderboardEntryCreateNestedManyWithoutUserInput
    agents?: AgentCreateNestedManyWithoutUserInput
    accountAssignments?: MT5AccountAssignmentCreateNestedManyWithoutUserInput
    anonymousAccounts?: AnonymousAccountCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEasInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    phone?: string | null
    ibCode?: string | null
    ibPartnerId?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    monthlyFee?: number
    totalTrades?: number
    winningTrades?: number
    losingTrades?: number
    totalProfit?: number
    totalVolume?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    lastActiveAt?: Date | string | null
    isActive?: boolean
    status?: $Enums.AccountStatus
    emailVerified?: boolean
    verificationCode?: string | null
    verificationExpiry?: Date | string | null
    mt5Accounts?: MT5AccountUncheckedCreateNestedManyWithoutUserInput
    trades?: TradeUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationLogUncheckedCreateNestedManyWithoutUserInput
    insights?: UserInsightUncheckedCreateNestedOneWithoutUserInput
    automations?: AutomationUncheckedCreateNestedManyWithoutUserInput
    leaderboardStats?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    agents?: AgentUncheckedCreateNestedManyWithoutUserInput
    accountAssignments?: MT5AccountAssignmentUncheckedCreateNestedManyWithoutUserInput
    anonymousAccounts?: AnonymousAccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEasInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEasInput, UserUncheckedCreateWithoutEasInput>
  }

  export type MT5AccountCreateWithoutEasInput = {
    id?: string
    accountNumber: string
    broker: string
    serverName: string
    login: string
    password?: string | null
    vpsIp?: string | null
    vpsPort?: number | null
    status?: $Enums.AccountStatus
    balance?: number
    equity?: number
    margin?: number
    freeMargin?: number
    isEnabledForTrading?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastSyncAt?: Date | string | null
    user: UserCreateNestedOneWithoutMt5AccountsInput
    trades?: TradeCreateNestedManyWithoutMt5AccountInput
  }

  export type MT5AccountUncheckedCreateWithoutEasInput = {
    id?: string
    userId: string
    accountNumber: string
    broker: string
    serverName: string
    login: string
    password?: string | null
    vpsIp?: string | null
    vpsPort?: number | null
    status?: $Enums.AccountStatus
    balance?: number
    equity?: number
    margin?: number
    freeMargin?: number
    isEnabledForTrading?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastSyncAt?: Date | string | null
    trades?: TradeUncheckedCreateNestedManyWithoutMt5AccountInput
  }

  export type MT5AccountCreateOrConnectWithoutEasInput = {
    where: MT5AccountWhereUniqueInput
    create: XOR<MT5AccountCreateWithoutEasInput, MT5AccountUncheckedCreateWithoutEasInput>
  }

  export type UserUpsertWithoutEasInput = {
    update: XOR<UserUpdateWithoutEasInput, UserUncheckedUpdateWithoutEasInput>
    create: XOR<UserCreateWithoutEasInput, UserUncheckedCreateWithoutEasInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEasInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEasInput, UserUncheckedUpdateWithoutEasInput>
  }

  export type UserUpdateWithoutEasInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ibCode?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyFee?: FloatFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    winningTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ibPartner?: IBPartnerUpdateOneWithoutUsersNestedInput
    mt5Accounts?: MT5AccountUpdateManyWithoutUserNestedInput
    trades?: TradeUpdateManyWithoutUserNestedInput
    notifications?: NotificationLogUpdateManyWithoutUserNestedInput
    insights?: UserInsightUpdateOneWithoutUserNestedInput
    automations?: AutomationUpdateManyWithoutUserNestedInput
    leaderboardStats?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    agents?: AgentUpdateManyWithoutUserNestedInput
    accountAssignments?: MT5AccountAssignmentUpdateManyWithoutUserNestedInput
    anonymousAccounts?: AnonymousAccountUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEasInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ibCode?: NullableStringFieldUpdateOperationsInput | string | null
    ibPartnerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyFee?: FloatFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    winningTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mt5Accounts?: MT5AccountUncheckedUpdateManyWithoutUserNestedInput
    trades?: TradeUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationLogUncheckedUpdateManyWithoutUserNestedInput
    insights?: UserInsightUncheckedUpdateOneWithoutUserNestedInput
    automations?: AutomationUncheckedUpdateManyWithoutUserNestedInput
    leaderboardStats?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    agents?: AgentUncheckedUpdateManyWithoutUserNestedInput
    accountAssignments?: MT5AccountAssignmentUncheckedUpdateManyWithoutUserNestedInput
    anonymousAccounts?: AnonymousAccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MT5AccountUpsertWithoutEasInput = {
    update: XOR<MT5AccountUpdateWithoutEasInput, MT5AccountUncheckedUpdateWithoutEasInput>
    create: XOR<MT5AccountCreateWithoutEasInput, MT5AccountUncheckedCreateWithoutEasInput>
    where?: MT5AccountWhereInput
  }

  export type MT5AccountUpdateToOneWithWhereWithoutEasInput = {
    where?: MT5AccountWhereInput
    data: XOR<MT5AccountUpdateWithoutEasInput, MT5AccountUncheckedUpdateWithoutEasInput>
  }

  export type MT5AccountUpdateWithoutEasInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    broker?: StringFieldUpdateOperationsInput | string
    serverName?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    vpsIp?: NullableStringFieldUpdateOperationsInput | string | null
    vpsPort?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    balance?: FloatFieldUpdateOperationsInput | number
    equity?: FloatFieldUpdateOperationsInput | number
    margin?: FloatFieldUpdateOperationsInput | number
    freeMargin?: FloatFieldUpdateOperationsInput | number
    isEnabledForTrading?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutMt5AccountsNestedInput
    trades?: TradeUpdateManyWithoutMt5AccountNestedInput
  }

  export type MT5AccountUncheckedUpdateWithoutEasInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    broker?: StringFieldUpdateOperationsInput | string
    serverName?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    vpsIp?: NullableStringFieldUpdateOperationsInput | string | null
    vpsPort?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    balance?: FloatFieldUpdateOperationsInput | number
    equity?: FloatFieldUpdateOperationsInput | number
    margin?: FloatFieldUpdateOperationsInput | number
    freeMargin?: FloatFieldUpdateOperationsInput | number
    isEnabledForTrading?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trades?: TradeUncheckedUpdateManyWithoutMt5AccountNestedInput
  }

  export type UserCreateWithoutTradesInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    phone?: string | null
    ibCode?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    monthlyFee?: number
    totalTrades?: number
    winningTrades?: number
    losingTrades?: number
    totalProfit?: number
    totalVolume?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    lastActiveAt?: Date | string | null
    isActive?: boolean
    status?: $Enums.AccountStatus
    emailVerified?: boolean
    verificationCode?: string | null
    verificationExpiry?: Date | string | null
    ibPartner?: IBPartnerCreateNestedOneWithoutUsersInput
    mt5Accounts?: MT5AccountCreateNestedManyWithoutUserInput
    eas?: EACreateNestedManyWithoutUserInput
    notifications?: NotificationLogCreateNestedManyWithoutUserInput
    insights?: UserInsightCreateNestedOneWithoutUserInput
    automations?: AutomationCreateNestedManyWithoutUserInput
    leaderboardStats?: LeaderboardEntryCreateNestedManyWithoutUserInput
    agents?: AgentCreateNestedManyWithoutUserInput
    accountAssignments?: MT5AccountAssignmentCreateNestedManyWithoutUserInput
    anonymousAccounts?: AnonymousAccountCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTradesInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    phone?: string | null
    ibCode?: string | null
    ibPartnerId?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    monthlyFee?: number
    totalTrades?: number
    winningTrades?: number
    losingTrades?: number
    totalProfit?: number
    totalVolume?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    lastActiveAt?: Date | string | null
    isActive?: boolean
    status?: $Enums.AccountStatus
    emailVerified?: boolean
    verificationCode?: string | null
    verificationExpiry?: Date | string | null
    mt5Accounts?: MT5AccountUncheckedCreateNestedManyWithoutUserInput
    eas?: EAUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationLogUncheckedCreateNestedManyWithoutUserInput
    insights?: UserInsightUncheckedCreateNestedOneWithoutUserInput
    automations?: AutomationUncheckedCreateNestedManyWithoutUserInput
    leaderboardStats?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    agents?: AgentUncheckedCreateNestedManyWithoutUserInput
    accountAssignments?: MT5AccountAssignmentUncheckedCreateNestedManyWithoutUserInput
    anonymousAccounts?: AnonymousAccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTradesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTradesInput, UserUncheckedCreateWithoutTradesInput>
  }

  export type MT5AccountCreateWithoutTradesInput = {
    id?: string
    accountNumber: string
    broker: string
    serverName: string
    login: string
    password?: string | null
    vpsIp?: string | null
    vpsPort?: number | null
    status?: $Enums.AccountStatus
    balance?: number
    equity?: number
    margin?: number
    freeMargin?: number
    isEnabledForTrading?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastSyncAt?: Date | string | null
    user: UserCreateNestedOneWithoutMt5AccountsInput
    eas?: EACreateNestedManyWithoutMt5AccountInput
  }

  export type MT5AccountUncheckedCreateWithoutTradesInput = {
    id?: string
    userId: string
    accountNumber: string
    broker: string
    serverName: string
    login: string
    password?: string | null
    vpsIp?: string | null
    vpsPort?: number | null
    status?: $Enums.AccountStatus
    balance?: number
    equity?: number
    margin?: number
    freeMargin?: number
    isEnabledForTrading?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastSyncAt?: Date | string | null
    eas?: EAUncheckedCreateNestedManyWithoutMt5AccountInput
  }

  export type MT5AccountCreateOrConnectWithoutTradesInput = {
    where: MT5AccountWhereUniqueInput
    create: XOR<MT5AccountCreateWithoutTradesInput, MT5AccountUncheckedCreateWithoutTradesInput>
  }

  export type UserUpsertWithoutTradesInput = {
    update: XOR<UserUpdateWithoutTradesInput, UserUncheckedUpdateWithoutTradesInput>
    create: XOR<UserCreateWithoutTradesInput, UserUncheckedCreateWithoutTradesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTradesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTradesInput, UserUncheckedUpdateWithoutTradesInput>
  }

  export type UserUpdateWithoutTradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ibCode?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyFee?: FloatFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    winningTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ibPartner?: IBPartnerUpdateOneWithoutUsersNestedInput
    mt5Accounts?: MT5AccountUpdateManyWithoutUserNestedInput
    eas?: EAUpdateManyWithoutUserNestedInput
    notifications?: NotificationLogUpdateManyWithoutUserNestedInput
    insights?: UserInsightUpdateOneWithoutUserNestedInput
    automations?: AutomationUpdateManyWithoutUserNestedInput
    leaderboardStats?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    agents?: AgentUpdateManyWithoutUserNestedInput
    accountAssignments?: MT5AccountAssignmentUpdateManyWithoutUserNestedInput
    anonymousAccounts?: AnonymousAccountUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ibCode?: NullableStringFieldUpdateOperationsInput | string | null
    ibPartnerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyFee?: FloatFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    winningTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mt5Accounts?: MT5AccountUncheckedUpdateManyWithoutUserNestedInput
    eas?: EAUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationLogUncheckedUpdateManyWithoutUserNestedInput
    insights?: UserInsightUncheckedUpdateOneWithoutUserNestedInput
    automations?: AutomationUncheckedUpdateManyWithoutUserNestedInput
    leaderboardStats?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    agents?: AgentUncheckedUpdateManyWithoutUserNestedInput
    accountAssignments?: MT5AccountAssignmentUncheckedUpdateManyWithoutUserNestedInput
    anonymousAccounts?: AnonymousAccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MT5AccountUpsertWithoutTradesInput = {
    update: XOR<MT5AccountUpdateWithoutTradesInput, MT5AccountUncheckedUpdateWithoutTradesInput>
    create: XOR<MT5AccountCreateWithoutTradesInput, MT5AccountUncheckedCreateWithoutTradesInput>
    where?: MT5AccountWhereInput
  }

  export type MT5AccountUpdateToOneWithWhereWithoutTradesInput = {
    where?: MT5AccountWhereInput
    data: XOR<MT5AccountUpdateWithoutTradesInput, MT5AccountUncheckedUpdateWithoutTradesInput>
  }

  export type MT5AccountUpdateWithoutTradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    broker?: StringFieldUpdateOperationsInput | string
    serverName?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    vpsIp?: NullableStringFieldUpdateOperationsInput | string | null
    vpsPort?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    balance?: FloatFieldUpdateOperationsInput | number
    equity?: FloatFieldUpdateOperationsInput | number
    margin?: FloatFieldUpdateOperationsInput | number
    freeMargin?: FloatFieldUpdateOperationsInput | number
    isEnabledForTrading?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutMt5AccountsNestedInput
    eas?: EAUpdateManyWithoutMt5AccountNestedInput
  }

  export type MT5AccountUncheckedUpdateWithoutTradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    broker?: StringFieldUpdateOperationsInput | string
    serverName?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    vpsIp?: NullableStringFieldUpdateOperationsInput | string | null
    vpsPort?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    balance?: FloatFieldUpdateOperationsInput | number
    equity?: FloatFieldUpdateOperationsInput | number
    margin?: FloatFieldUpdateOperationsInput | number
    freeMargin?: FloatFieldUpdateOperationsInput | number
    isEnabledForTrading?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eas?: EAUncheckedUpdateManyWithoutMt5AccountNestedInput
  }

  export type UserCreateWithoutAutomationsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    phone?: string | null
    ibCode?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    monthlyFee?: number
    totalTrades?: number
    winningTrades?: number
    losingTrades?: number
    totalProfit?: number
    totalVolume?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    lastActiveAt?: Date | string | null
    isActive?: boolean
    status?: $Enums.AccountStatus
    emailVerified?: boolean
    verificationCode?: string | null
    verificationExpiry?: Date | string | null
    ibPartner?: IBPartnerCreateNestedOneWithoutUsersInput
    mt5Accounts?: MT5AccountCreateNestedManyWithoutUserInput
    eas?: EACreateNestedManyWithoutUserInput
    trades?: TradeCreateNestedManyWithoutUserInput
    notifications?: NotificationLogCreateNestedManyWithoutUserInput
    insights?: UserInsightCreateNestedOneWithoutUserInput
    leaderboardStats?: LeaderboardEntryCreateNestedManyWithoutUserInput
    agents?: AgentCreateNestedManyWithoutUserInput
    accountAssignments?: MT5AccountAssignmentCreateNestedManyWithoutUserInput
    anonymousAccounts?: AnonymousAccountCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAutomationsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    phone?: string | null
    ibCode?: string | null
    ibPartnerId?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    monthlyFee?: number
    totalTrades?: number
    winningTrades?: number
    losingTrades?: number
    totalProfit?: number
    totalVolume?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    lastActiveAt?: Date | string | null
    isActive?: boolean
    status?: $Enums.AccountStatus
    emailVerified?: boolean
    verificationCode?: string | null
    verificationExpiry?: Date | string | null
    mt5Accounts?: MT5AccountUncheckedCreateNestedManyWithoutUserInput
    eas?: EAUncheckedCreateNestedManyWithoutUserInput
    trades?: TradeUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationLogUncheckedCreateNestedManyWithoutUserInput
    insights?: UserInsightUncheckedCreateNestedOneWithoutUserInput
    leaderboardStats?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    agents?: AgentUncheckedCreateNestedManyWithoutUserInput
    accountAssignments?: MT5AccountAssignmentUncheckedCreateNestedManyWithoutUserInput
    anonymousAccounts?: AnonymousAccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAutomationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAutomationsInput, UserUncheckedCreateWithoutAutomationsInput>
  }

  export type NotificationLogCreateWithoutAutomationInput = {
    id?: string
    channel: $Enums.AutomationActionType
    recipient: string
    subject?: string | null
    message: string
    status?: $Enums.NotificationStatus
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    failedAt?: Date | string | null
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationLogUncheckedCreateWithoutAutomationInput = {
    id?: string
    userId: string
    channel: $Enums.AutomationActionType
    recipient: string
    subject?: string | null
    message: string
    status?: $Enums.NotificationStatus
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    failedAt?: Date | string | null
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationLogCreateOrConnectWithoutAutomationInput = {
    where: NotificationLogWhereUniqueInput
    create: XOR<NotificationLogCreateWithoutAutomationInput, NotificationLogUncheckedCreateWithoutAutomationInput>
  }

  export type NotificationLogCreateManyAutomationInputEnvelope = {
    data: NotificationLogCreateManyAutomationInput | NotificationLogCreateManyAutomationInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAutomationsInput = {
    update: XOR<UserUpdateWithoutAutomationsInput, UserUncheckedUpdateWithoutAutomationsInput>
    create: XOR<UserCreateWithoutAutomationsInput, UserUncheckedCreateWithoutAutomationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAutomationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAutomationsInput, UserUncheckedUpdateWithoutAutomationsInput>
  }

  export type UserUpdateWithoutAutomationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ibCode?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyFee?: FloatFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    winningTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ibPartner?: IBPartnerUpdateOneWithoutUsersNestedInput
    mt5Accounts?: MT5AccountUpdateManyWithoutUserNestedInput
    eas?: EAUpdateManyWithoutUserNestedInput
    trades?: TradeUpdateManyWithoutUserNestedInput
    notifications?: NotificationLogUpdateManyWithoutUserNestedInput
    insights?: UserInsightUpdateOneWithoutUserNestedInput
    leaderboardStats?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    agents?: AgentUpdateManyWithoutUserNestedInput
    accountAssignments?: MT5AccountAssignmentUpdateManyWithoutUserNestedInput
    anonymousAccounts?: AnonymousAccountUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAutomationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ibCode?: NullableStringFieldUpdateOperationsInput | string | null
    ibPartnerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyFee?: FloatFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    winningTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mt5Accounts?: MT5AccountUncheckedUpdateManyWithoutUserNestedInput
    eas?: EAUncheckedUpdateManyWithoutUserNestedInput
    trades?: TradeUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationLogUncheckedUpdateManyWithoutUserNestedInput
    insights?: UserInsightUncheckedUpdateOneWithoutUserNestedInput
    leaderboardStats?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    agents?: AgentUncheckedUpdateManyWithoutUserNestedInput
    accountAssignments?: MT5AccountAssignmentUncheckedUpdateManyWithoutUserNestedInput
    anonymousAccounts?: AnonymousAccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type NotificationLogUpsertWithWhereUniqueWithoutAutomationInput = {
    where: NotificationLogWhereUniqueInput
    update: XOR<NotificationLogUpdateWithoutAutomationInput, NotificationLogUncheckedUpdateWithoutAutomationInput>
    create: XOR<NotificationLogCreateWithoutAutomationInput, NotificationLogUncheckedCreateWithoutAutomationInput>
  }

  export type NotificationLogUpdateWithWhereUniqueWithoutAutomationInput = {
    where: NotificationLogWhereUniqueInput
    data: XOR<NotificationLogUpdateWithoutAutomationInput, NotificationLogUncheckedUpdateWithoutAutomationInput>
  }

  export type NotificationLogUpdateManyWithWhereWithoutAutomationInput = {
    where: NotificationLogScalarWhereInput
    data: XOR<NotificationLogUpdateManyMutationInput, NotificationLogUncheckedUpdateManyWithoutAutomationInput>
  }

  export type AutomationCreateWithoutLogsInput = {
    id?: string
    name: string
    description?: string | null
    triggerType: $Enums.AutomationTriggerType
    triggerValue?: number | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    actionTypes?: AutomationCreateactionTypesInput | $Enums.AutomationActionType[]
    actionData?: NullableJsonNullValueInput | InputJsonValue
    messageSubject?: string | null
    messageBody: string
    status?: $Enums.AutomationStatus
    priority?: number
    isUserEnabled?: boolean
    totalTriggered?: number
    totalSent?: number
    totalFailed?: number
    lastTriggered?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    user?: UserCreateNestedOneWithoutAutomationsInput
  }

  export type AutomationUncheckedCreateWithoutLogsInput = {
    id?: string
    name: string
    description?: string | null
    userId?: string | null
    triggerType: $Enums.AutomationTriggerType
    triggerValue?: number | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    actionTypes?: AutomationCreateactionTypesInput | $Enums.AutomationActionType[]
    actionData?: NullableJsonNullValueInput | InputJsonValue
    messageSubject?: string | null
    messageBody: string
    status?: $Enums.AutomationStatus
    priority?: number
    isUserEnabled?: boolean
    totalTriggered?: number
    totalSent?: number
    totalFailed?: number
    lastTriggered?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
  }

  export type AutomationCreateOrConnectWithoutLogsInput = {
    where: AutomationWhereUniqueInput
    create: XOR<AutomationCreateWithoutLogsInput, AutomationUncheckedCreateWithoutLogsInput>
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    phone?: string | null
    ibCode?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    monthlyFee?: number
    totalTrades?: number
    winningTrades?: number
    losingTrades?: number
    totalProfit?: number
    totalVolume?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    lastActiveAt?: Date | string | null
    isActive?: boolean
    status?: $Enums.AccountStatus
    emailVerified?: boolean
    verificationCode?: string | null
    verificationExpiry?: Date | string | null
    ibPartner?: IBPartnerCreateNestedOneWithoutUsersInput
    mt5Accounts?: MT5AccountCreateNestedManyWithoutUserInput
    eas?: EACreateNestedManyWithoutUserInput
    trades?: TradeCreateNestedManyWithoutUserInput
    insights?: UserInsightCreateNestedOneWithoutUserInput
    automations?: AutomationCreateNestedManyWithoutUserInput
    leaderboardStats?: LeaderboardEntryCreateNestedManyWithoutUserInput
    agents?: AgentCreateNestedManyWithoutUserInput
    accountAssignments?: MT5AccountAssignmentCreateNestedManyWithoutUserInput
    anonymousAccounts?: AnonymousAccountCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    phone?: string | null
    ibCode?: string | null
    ibPartnerId?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    monthlyFee?: number
    totalTrades?: number
    winningTrades?: number
    losingTrades?: number
    totalProfit?: number
    totalVolume?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    lastActiveAt?: Date | string | null
    isActive?: boolean
    status?: $Enums.AccountStatus
    emailVerified?: boolean
    verificationCode?: string | null
    verificationExpiry?: Date | string | null
    mt5Accounts?: MT5AccountUncheckedCreateNestedManyWithoutUserInput
    eas?: EAUncheckedCreateNestedManyWithoutUserInput
    trades?: TradeUncheckedCreateNestedManyWithoutUserInput
    insights?: UserInsightUncheckedCreateNestedOneWithoutUserInput
    automations?: AutomationUncheckedCreateNestedManyWithoutUserInput
    leaderboardStats?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    agents?: AgentUncheckedCreateNestedManyWithoutUserInput
    accountAssignments?: MT5AccountAssignmentUncheckedCreateNestedManyWithoutUserInput
    anonymousAccounts?: AnonymousAccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type AutomationUpsertWithoutLogsInput = {
    update: XOR<AutomationUpdateWithoutLogsInput, AutomationUncheckedUpdateWithoutLogsInput>
    create: XOR<AutomationCreateWithoutLogsInput, AutomationUncheckedCreateWithoutLogsInput>
    where?: AutomationWhereInput
  }

  export type AutomationUpdateToOneWithWhereWithoutLogsInput = {
    where?: AutomationWhereInput
    data: XOR<AutomationUpdateWithoutLogsInput, AutomationUncheckedUpdateWithoutLogsInput>
  }

  export type AutomationUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: EnumAutomationTriggerTypeFieldUpdateOperationsInput | $Enums.AutomationTriggerType
    triggerValue?: NullableIntFieldUpdateOperationsInput | number | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    actionTypes?: AutomationUpdateactionTypesInput | $Enums.AutomationActionType[]
    actionData?: NullableJsonNullValueInput | InputJsonValue
    messageSubject?: NullableStringFieldUpdateOperationsInput | string | null
    messageBody?: StringFieldUpdateOperationsInput | string
    status?: EnumAutomationStatusFieldUpdateOperationsInput | $Enums.AutomationStatus
    priority?: IntFieldUpdateOperationsInput | number
    isUserEnabled?: BoolFieldUpdateOperationsInput | boolean
    totalTriggered?: IntFieldUpdateOperationsInput | number
    totalSent?: IntFieldUpdateOperationsInput | number
    totalFailed?: IntFieldUpdateOperationsInput | number
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutAutomationsNestedInput
  }

  export type AutomationUncheckedUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: EnumAutomationTriggerTypeFieldUpdateOperationsInput | $Enums.AutomationTriggerType
    triggerValue?: NullableIntFieldUpdateOperationsInput | number | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    actionTypes?: AutomationUpdateactionTypesInput | $Enums.AutomationActionType[]
    actionData?: NullableJsonNullValueInput | InputJsonValue
    messageSubject?: NullableStringFieldUpdateOperationsInput | string | null
    messageBody?: StringFieldUpdateOperationsInput | string
    status?: EnumAutomationStatusFieldUpdateOperationsInput | $Enums.AutomationStatus
    priority?: IntFieldUpdateOperationsInput | number
    isUserEnabled?: BoolFieldUpdateOperationsInput | boolean
    totalTriggered?: IntFieldUpdateOperationsInput | number
    totalSent?: IntFieldUpdateOperationsInput | number
    totalFailed?: IntFieldUpdateOperationsInput | number
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ibCode?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyFee?: FloatFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    winningTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ibPartner?: IBPartnerUpdateOneWithoutUsersNestedInput
    mt5Accounts?: MT5AccountUpdateManyWithoutUserNestedInput
    eas?: EAUpdateManyWithoutUserNestedInput
    trades?: TradeUpdateManyWithoutUserNestedInput
    insights?: UserInsightUpdateOneWithoutUserNestedInput
    automations?: AutomationUpdateManyWithoutUserNestedInput
    leaderboardStats?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    agents?: AgentUpdateManyWithoutUserNestedInput
    accountAssignments?: MT5AccountAssignmentUpdateManyWithoutUserNestedInput
    anonymousAccounts?: AnonymousAccountUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ibCode?: NullableStringFieldUpdateOperationsInput | string | null
    ibPartnerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyFee?: FloatFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    winningTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mt5Accounts?: MT5AccountUncheckedUpdateManyWithoutUserNestedInput
    eas?: EAUncheckedUpdateManyWithoutUserNestedInput
    trades?: TradeUncheckedUpdateManyWithoutUserNestedInput
    insights?: UserInsightUncheckedUpdateOneWithoutUserNestedInput
    automations?: AutomationUncheckedUpdateManyWithoutUserNestedInput
    leaderboardStats?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    agents?: AgentUncheckedUpdateManyWithoutUserNestedInput
    accountAssignments?: MT5AccountAssignmentUncheckedUpdateManyWithoutUserNestedInput
    anonymousAccounts?: AnonymousAccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutInsightsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    phone?: string | null
    ibCode?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    monthlyFee?: number
    totalTrades?: number
    winningTrades?: number
    losingTrades?: number
    totalProfit?: number
    totalVolume?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    lastActiveAt?: Date | string | null
    isActive?: boolean
    status?: $Enums.AccountStatus
    emailVerified?: boolean
    verificationCode?: string | null
    verificationExpiry?: Date | string | null
    ibPartner?: IBPartnerCreateNestedOneWithoutUsersInput
    mt5Accounts?: MT5AccountCreateNestedManyWithoutUserInput
    eas?: EACreateNestedManyWithoutUserInput
    trades?: TradeCreateNestedManyWithoutUserInput
    notifications?: NotificationLogCreateNestedManyWithoutUserInput
    automations?: AutomationCreateNestedManyWithoutUserInput
    leaderboardStats?: LeaderboardEntryCreateNestedManyWithoutUserInput
    agents?: AgentCreateNestedManyWithoutUserInput
    accountAssignments?: MT5AccountAssignmentCreateNestedManyWithoutUserInput
    anonymousAccounts?: AnonymousAccountCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInsightsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    phone?: string | null
    ibCode?: string | null
    ibPartnerId?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    monthlyFee?: number
    totalTrades?: number
    winningTrades?: number
    losingTrades?: number
    totalProfit?: number
    totalVolume?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    lastActiveAt?: Date | string | null
    isActive?: boolean
    status?: $Enums.AccountStatus
    emailVerified?: boolean
    verificationCode?: string | null
    verificationExpiry?: Date | string | null
    mt5Accounts?: MT5AccountUncheckedCreateNestedManyWithoutUserInput
    eas?: EAUncheckedCreateNestedManyWithoutUserInput
    trades?: TradeUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationLogUncheckedCreateNestedManyWithoutUserInput
    automations?: AutomationUncheckedCreateNestedManyWithoutUserInput
    leaderboardStats?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    agents?: AgentUncheckedCreateNestedManyWithoutUserInput
    accountAssignments?: MT5AccountAssignmentUncheckedCreateNestedManyWithoutUserInput
    anonymousAccounts?: AnonymousAccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInsightsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInsightsInput, UserUncheckedCreateWithoutInsightsInput>
  }

  export type UserUpsertWithoutInsightsInput = {
    update: XOR<UserUpdateWithoutInsightsInput, UserUncheckedUpdateWithoutInsightsInput>
    create: XOR<UserCreateWithoutInsightsInput, UserUncheckedCreateWithoutInsightsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInsightsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInsightsInput, UserUncheckedUpdateWithoutInsightsInput>
  }

  export type UserUpdateWithoutInsightsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ibCode?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyFee?: FloatFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    winningTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ibPartner?: IBPartnerUpdateOneWithoutUsersNestedInput
    mt5Accounts?: MT5AccountUpdateManyWithoutUserNestedInput
    eas?: EAUpdateManyWithoutUserNestedInput
    trades?: TradeUpdateManyWithoutUserNestedInput
    notifications?: NotificationLogUpdateManyWithoutUserNestedInput
    automations?: AutomationUpdateManyWithoutUserNestedInput
    leaderboardStats?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    agents?: AgentUpdateManyWithoutUserNestedInput
    accountAssignments?: MT5AccountAssignmentUpdateManyWithoutUserNestedInput
    anonymousAccounts?: AnonymousAccountUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInsightsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ibCode?: NullableStringFieldUpdateOperationsInput | string | null
    ibPartnerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyFee?: FloatFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    winningTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mt5Accounts?: MT5AccountUncheckedUpdateManyWithoutUserNestedInput
    eas?: EAUncheckedUpdateManyWithoutUserNestedInput
    trades?: TradeUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationLogUncheckedUpdateManyWithoutUserNestedInput
    automations?: AutomationUncheckedUpdateManyWithoutUserNestedInput
    leaderboardStats?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    agents?: AgentUncheckedUpdateManyWithoutUserNestedInput
    accountAssignments?: MT5AccountAssignmentUncheckedUpdateManyWithoutUserNestedInput
    anonymousAccounts?: AnonymousAccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutLeaderboardStatsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    phone?: string | null
    ibCode?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    monthlyFee?: number
    totalTrades?: number
    winningTrades?: number
    losingTrades?: number
    totalProfit?: number
    totalVolume?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    lastActiveAt?: Date | string | null
    isActive?: boolean
    status?: $Enums.AccountStatus
    emailVerified?: boolean
    verificationCode?: string | null
    verificationExpiry?: Date | string | null
    ibPartner?: IBPartnerCreateNestedOneWithoutUsersInput
    mt5Accounts?: MT5AccountCreateNestedManyWithoutUserInput
    eas?: EACreateNestedManyWithoutUserInput
    trades?: TradeCreateNestedManyWithoutUserInput
    notifications?: NotificationLogCreateNestedManyWithoutUserInput
    insights?: UserInsightCreateNestedOneWithoutUserInput
    automations?: AutomationCreateNestedManyWithoutUserInput
    agents?: AgentCreateNestedManyWithoutUserInput
    accountAssignments?: MT5AccountAssignmentCreateNestedManyWithoutUserInput
    anonymousAccounts?: AnonymousAccountCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLeaderboardStatsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    phone?: string | null
    ibCode?: string | null
    ibPartnerId?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    monthlyFee?: number
    totalTrades?: number
    winningTrades?: number
    losingTrades?: number
    totalProfit?: number
    totalVolume?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    lastActiveAt?: Date | string | null
    isActive?: boolean
    status?: $Enums.AccountStatus
    emailVerified?: boolean
    verificationCode?: string | null
    verificationExpiry?: Date | string | null
    mt5Accounts?: MT5AccountUncheckedCreateNestedManyWithoutUserInput
    eas?: EAUncheckedCreateNestedManyWithoutUserInput
    trades?: TradeUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationLogUncheckedCreateNestedManyWithoutUserInput
    insights?: UserInsightUncheckedCreateNestedOneWithoutUserInput
    automations?: AutomationUncheckedCreateNestedManyWithoutUserInput
    agents?: AgentUncheckedCreateNestedManyWithoutUserInput
    accountAssignments?: MT5AccountAssignmentUncheckedCreateNestedManyWithoutUserInput
    anonymousAccounts?: AnonymousAccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLeaderboardStatsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLeaderboardStatsInput, UserUncheckedCreateWithoutLeaderboardStatsInput>
  }

  export type UserUpsertWithoutLeaderboardStatsInput = {
    update: XOR<UserUpdateWithoutLeaderboardStatsInput, UserUncheckedUpdateWithoutLeaderboardStatsInput>
    create: XOR<UserCreateWithoutLeaderboardStatsInput, UserUncheckedCreateWithoutLeaderboardStatsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLeaderboardStatsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLeaderboardStatsInput, UserUncheckedUpdateWithoutLeaderboardStatsInput>
  }

  export type UserUpdateWithoutLeaderboardStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ibCode?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyFee?: FloatFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    winningTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ibPartner?: IBPartnerUpdateOneWithoutUsersNestedInput
    mt5Accounts?: MT5AccountUpdateManyWithoutUserNestedInput
    eas?: EAUpdateManyWithoutUserNestedInput
    trades?: TradeUpdateManyWithoutUserNestedInput
    notifications?: NotificationLogUpdateManyWithoutUserNestedInput
    insights?: UserInsightUpdateOneWithoutUserNestedInput
    automations?: AutomationUpdateManyWithoutUserNestedInput
    agents?: AgentUpdateManyWithoutUserNestedInput
    accountAssignments?: MT5AccountAssignmentUpdateManyWithoutUserNestedInput
    anonymousAccounts?: AnonymousAccountUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLeaderboardStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ibCode?: NullableStringFieldUpdateOperationsInput | string | null
    ibPartnerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyFee?: FloatFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    winningTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mt5Accounts?: MT5AccountUncheckedUpdateManyWithoutUserNestedInput
    eas?: EAUncheckedUpdateManyWithoutUserNestedInput
    trades?: TradeUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationLogUncheckedUpdateManyWithoutUserNestedInput
    insights?: UserInsightUncheckedUpdateOneWithoutUserNestedInput
    automations?: AutomationUncheckedUpdateManyWithoutUserNestedInput
    agents?: AgentUncheckedUpdateManyWithoutUserNestedInput
    accountAssignments?: MT5AccountAssignmentUncheckedUpdateManyWithoutUserNestedInput
    anonymousAccounts?: AnonymousAccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutIbPartnerInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    phone?: string | null
    ibCode?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    monthlyFee?: number
    totalTrades?: number
    winningTrades?: number
    losingTrades?: number
    totalProfit?: number
    totalVolume?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    lastActiveAt?: Date | string | null
    isActive?: boolean
    status?: $Enums.AccountStatus
    emailVerified?: boolean
    verificationCode?: string | null
    verificationExpiry?: Date | string | null
    mt5Accounts?: MT5AccountCreateNestedManyWithoutUserInput
    eas?: EACreateNestedManyWithoutUserInput
    trades?: TradeCreateNestedManyWithoutUserInput
    notifications?: NotificationLogCreateNestedManyWithoutUserInput
    insights?: UserInsightCreateNestedOneWithoutUserInput
    automations?: AutomationCreateNestedManyWithoutUserInput
    leaderboardStats?: LeaderboardEntryCreateNestedManyWithoutUserInput
    agents?: AgentCreateNestedManyWithoutUserInput
    accountAssignments?: MT5AccountAssignmentCreateNestedManyWithoutUserInput
    anonymousAccounts?: AnonymousAccountCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutIbPartnerInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    phone?: string | null
    ibCode?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    monthlyFee?: number
    totalTrades?: number
    winningTrades?: number
    losingTrades?: number
    totalProfit?: number
    totalVolume?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    lastActiveAt?: Date | string | null
    isActive?: boolean
    status?: $Enums.AccountStatus
    emailVerified?: boolean
    verificationCode?: string | null
    verificationExpiry?: Date | string | null
    mt5Accounts?: MT5AccountUncheckedCreateNestedManyWithoutUserInput
    eas?: EAUncheckedCreateNestedManyWithoutUserInput
    trades?: TradeUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationLogUncheckedCreateNestedManyWithoutUserInput
    insights?: UserInsightUncheckedCreateNestedOneWithoutUserInput
    automations?: AutomationUncheckedCreateNestedManyWithoutUserInput
    leaderboardStats?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    agents?: AgentUncheckedCreateNestedManyWithoutUserInput
    accountAssignments?: MT5AccountAssignmentUncheckedCreateNestedManyWithoutUserInput
    anonymousAccounts?: AnonymousAccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutIbPartnerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIbPartnerInput, UserUncheckedCreateWithoutIbPartnerInput>
  }

  export type UserCreateManyIbPartnerInputEnvelope = {
    data: UserCreateManyIbPartnerInput | UserCreateManyIbPartnerInput[]
    skipDuplicates?: boolean
  }

  export type AnonymousAccountCreateWithoutIbPartnerInput = {
    id?: string
    anonymousId: string
    mt5AccountNumber: string
    isActive?: boolean
    registeredAt?: Date | string
    user: UserCreateNestedOneWithoutAnonymousAccountsInput
    commissions?: IBCommissionCreateNestedManyWithoutAnonymousAccountInput
  }

  export type AnonymousAccountUncheckedCreateWithoutIbPartnerInput = {
    id?: string
    anonymousId: string
    userId: string
    mt5AccountNumber: string
    isActive?: boolean
    registeredAt?: Date | string
    commissions?: IBCommissionUncheckedCreateNestedManyWithoutAnonymousAccountInput
  }

  export type AnonymousAccountCreateOrConnectWithoutIbPartnerInput = {
    where: AnonymousAccountWhereUniqueInput
    create: XOR<AnonymousAccountCreateWithoutIbPartnerInput, AnonymousAccountUncheckedCreateWithoutIbPartnerInput>
  }

  export type AnonymousAccountCreateManyIbPartnerInputEnvelope = {
    data: AnonymousAccountCreateManyIbPartnerInput | AnonymousAccountCreateManyIbPartnerInput[]
    skipDuplicates?: boolean
  }

  export type IBCommissionCreateWithoutIbPartnerInput = {
    id?: string
    period: Date | string
    periodEnd: Date | string
    tradingVolume?: number
    numberOfTrades?: number
    averageSpread?: number
    commissionRate: number
    grossCommission?: number
    platformFee?: number
    netCommission?: number
    isPaid?: boolean
    paidAt?: Date | string | null
    paymentReference?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    anonymousAccount: AnonymousAccountCreateNestedOneWithoutCommissionsInput
  }

  export type IBCommissionUncheckedCreateWithoutIbPartnerInput = {
    id?: string
    anonymousAccountId: string
    period: Date | string
    periodEnd: Date | string
    tradingVolume?: number
    numberOfTrades?: number
    averageSpread?: number
    commissionRate: number
    grossCommission?: number
    platformFee?: number
    netCommission?: number
    isPaid?: boolean
    paidAt?: Date | string | null
    paymentReference?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IBCommissionCreateOrConnectWithoutIbPartnerInput = {
    where: IBCommissionWhereUniqueInput
    create: XOR<IBCommissionCreateWithoutIbPartnerInput, IBCommissionUncheckedCreateWithoutIbPartnerInput>
  }

  export type IBCommissionCreateManyIbPartnerInputEnvelope = {
    data: IBCommissionCreateManyIbPartnerInput | IBCommissionCreateManyIbPartnerInput[]
    skipDuplicates?: boolean
  }

  export type IBCommissionRateCreateWithoutIbPartnerInput = {
    id?: string
    commissionRate?: number
    minVolume?: number
    maxVolume?: number | null
    effectiveFrom?: Date | string
    effectiveTo?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IBCommissionRateUncheckedCreateWithoutIbPartnerInput = {
    id?: string
    commissionRate?: number
    minVolume?: number
    maxVolume?: number | null
    effectiveFrom?: Date | string
    effectiveTo?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IBCommissionRateCreateOrConnectWithoutIbPartnerInput = {
    where: IBCommissionRateWhereUniqueInput
    create: XOR<IBCommissionRateCreateWithoutIbPartnerInput, IBCommissionRateUncheckedCreateWithoutIbPartnerInput>
  }

  export type IBCommissionRateCreateManyIbPartnerInputEnvelope = {
    data: IBCommissionRateCreateManyIbPartnerInput | IBCommissionRateCreateManyIbPartnerInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutIbPartnerInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutIbPartnerInput, UserUncheckedUpdateWithoutIbPartnerInput>
    create: XOR<UserCreateWithoutIbPartnerInput, UserUncheckedCreateWithoutIbPartnerInput>
  }

  export type UserUpdateWithWhereUniqueWithoutIbPartnerInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutIbPartnerInput, UserUncheckedUpdateWithoutIbPartnerInput>
  }

  export type UserUpdateManyWithWhereWithoutIbPartnerInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutIbPartnerInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    phone?: StringNullableFilter<"User"> | string | null
    ibCode?: StringNullableFilter<"User"> | string | null
    ibPartnerId?: StringNullableFilter<"User"> | string | null
    subscriptionTier?: EnumSubscriptionTierFilter<"User"> | $Enums.SubscriptionTier
    subscriptionStart?: DateTimeNullableFilter<"User"> | Date | string | null
    subscriptionEnd?: DateTimeNullableFilter<"User"> | Date | string | null
    monthlyFee?: FloatFilter<"User"> | number
    totalTrades?: IntFilter<"User"> | number
    winningTrades?: IntFilter<"User"> | number
    losingTrades?: IntFilter<"User"> | number
    totalProfit?: FloatFilter<"User"> | number
    totalVolume?: FloatFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    lastActiveAt?: DateTimeNullableFilter<"User"> | Date | string | null
    isActive?: BoolFilter<"User"> | boolean
    status?: EnumAccountStatusFilter<"User"> | $Enums.AccountStatus
    emailVerified?: BoolFilter<"User"> | boolean
    verificationCode?: StringNullableFilter<"User"> | string | null
    verificationExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
  }

  export type AnonymousAccountUpsertWithWhereUniqueWithoutIbPartnerInput = {
    where: AnonymousAccountWhereUniqueInput
    update: XOR<AnonymousAccountUpdateWithoutIbPartnerInput, AnonymousAccountUncheckedUpdateWithoutIbPartnerInput>
    create: XOR<AnonymousAccountCreateWithoutIbPartnerInput, AnonymousAccountUncheckedCreateWithoutIbPartnerInput>
  }

  export type AnonymousAccountUpdateWithWhereUniqueWithoutIbPartnerInput = {
    where: AnonymousAccountWhereUniqueInput
    data: XOR<AnonymousAccountUpdateWithoutIbPartnerInput, AnonymousAccountUncheckedUpdateWithoutIbPartnerInput>
  }

  export type AnonymousAccountUpdateManyWithWhereWithoutIbPartnerInput = {
    where: AnonymousAccountScalarWhereInput
    data: XOR<AnonymousAccountUpdateManyMutationInput, AnonymousAccountUncheckedUpdateManyWithoutIbPartnerInput>
  }

  export type IBCommissionUpsertWithWhereUniqueWithoutIbPartnerInput = {
    where: IBCommissionWhereUniqueInput
    update: XOR<IBCommissionUpdateWithoutIbPartnerInput, IBCommissionUncheckedUpdateWithoutIbPartnerInput>
    create: XOR<IBCommissionCreateWithoutIbPartnerInput, IBCommissionUncheckedCreateWithoutIbPartnerInput>
  }

  export type IBCommissionUpdateWithWhereUniqueWithoutIbPartnerInput = {
    where: IBCommissionWhereUniqueInput
    data: XOR<IBCommissionUpdateWithoutIbPartnerInput, IBCommissionUncheckedUpdateWithoutIbPartnerInput>
  }

  export type IBCommissionUpdateManyWithWhereWithoutIbPartnerInput = {
    where: IBCommissionScalarWhereInput
    data: XOR<IBCommissionUpdateManyMutationInput, IBCommissionUncheckedUpdateManyWithoutIbPartnerInput>
  }

  export type IBCommissionScalarWhereInput = {
    AND?: IBCommissionScalarWhereInput | IBCommissionScalarWhereInput[]
    OR?: IBCommissionScalarWhereInput[]
    NOT?: IBCommissionScalarWhereInput | IBCommissionScalarWhereInput[]
    id?: StringFilter<"IBCommission"> | string
    ibPartnerId?: StringFilter<"IBCommission"> | string
    anonymousAccountId?: StringFilter<"IBCommission"> | string
    period?: DateTimeFilter<"IBCommission"> | Date | string
    periodEnd?: DateTimeFilter<"IBCommission"> | Date | string
    tradingVolume?: FloatFilter<"IBCommission"> | number
    numberOfTrades?: IntFilter<"IBCommission"> | number
    averageSpread?: FloatFilter<"IBCommission"> | number
    commissionRate?: FloatFilter<"IBCommission"> | number
    grossCommission?: FloatFilter<"IBCommission"> | number
    platformFee?: FloatFilter<"IBCommission"> | number
    netCommission?: FloatFilter<"IBCommission"> | number
    isPaid?: BoolFilter<"IBCommission"> | boolean
    paidAt?: DateTimeNullableFilter<"IBCommission"> | Date | string | null
    paymentReference?: StringNullableFilter<"IBCommission"> | string | null
    notes?: StringNullableFilter<"IBCommission"> | string | null
    createdAt?: DateTimeFilter<"IBCommission"> | Date | string
    updatedAt?: DateTimeFilter<"IBCommission"> | Date | string
  }

  export type IBCommissionRateUpsertWithWhereUniqueWithoutIbPartnerInput = {
    where: IBCommissionRateWhereUniqueInput
    update: XOR<IBCommissionRateUpdateWithoutIbPartnerInput, IBCommissionRateUncheckedUpdateWithoutIbPartnerInput>
    create: XOR<IBCommissionRateCreateWithoutIbPartnerInput, IBCommissionRateUncheckedCreateWithoutIbPartnerInput>
  }

  export type IBCommissionRateUpdateWithWhereUniqueWithoutIbPartnerInput = {
    where: IBCommissionRateWhereUniqueInput
    data: XOR<IBCommissionRateUpdateWithoutIbPartnerInput, IBCommissionRateUncheckedUpdateWithoutIbPartnerInput>
  }

  export type IBCommissionRateUpdateManyWithWhereWithoutIbPartnerInput = {
    where: IBCommissionRateScalarWhereInput
    data: XOR<IBCommissionRateUpdateManyMutationInput, IBCommissionRateUncheckedUpdateManyWithoutIbPartnerInput>
  }

  export type IBCommissionRateScalarWhereInput = {
    AND?: IBCommissionRateScalarWhereInput | IBCommissionRateScalarWhereInput[]
    OR?: IBCommissionRateScalarWhereInput[]
    NOT?: IBCommissionRateScalarWhereInput | IBCommissionRateScalarWhereInput[]
    id?: StringFilter<"IBCommissionRate"> | string
    ibPartnerId?: StringFilter<"IBCommissionRate"> | string
    commissionRate?: FloatFilter<"IBCommissionRate"> | number
    minVolume?: FloatFilter<"IBCommissionRate"> | number
    maxVolume?: FloatNullableFilter<"IBCommissionRate"> | number | null
    effectiveFrom?: DateTimeFilter<"IBCommissionRate"> | Date | string
    effectiveTo?: DateTimeNullableFilter<"IBCommissionRate"> | Date | string | null
    isActive?: BoolFilter<"IBCommissionRate"> | boolean
    createdAt?: DateTimeFilter<"IBCommissionRate"> | Date | string
    updatedAt?: DateTimeFilter<"IBCommissionRate"> | Date | string
  }

  export type UserCreateWithoutAgentsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    phone?: string | null
    ibCode?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    monthlyFee?: number
    totalTrades?: number
    winningTrades?: number
    losingTrades?: number
    totalProfit?: number
    totalVolume?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    lastActiveAt?: Date | string | null
    isActive?: boolean
    status?: $Enums.AccountStatus
    emailVerified?: boolean
    verificationCode?: string | null
    verificationExpiry?: Date | string | null
    ibPartner?: IBPartnerCreateNestedOneWithoutUsersInput
    mt5Accounts?: MT5AccountCreateNestedManyWithoutUserInput
    eas?: EACreateNestedManyWithoutUserInput
    trades?: TradeCreateNestedManyWithoutUserInput
    notifications?: NotificationLogCreateNestedManyWithoutUserInput
    insights?: UserInsightCreateNestedOneWithoutUserInput
    automations?: AutomationCreateNestedManyWithoutUserInput
    leaderboardStats?: LeaderboardEntryCreateNestedManyWithoutUserInput
    accountAssignments?: MT5AccountAssignmentCreateNestedManyWithoutUserInput
    anonymousAccounts?: AnonymousAccountCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAgentsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    phone?: string | null
    ibCode?: string | null
    ibPartnerId?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    monthlyFee?: number
    totalTrades?: number
    winningTrades?: number
    losingTrades?: number
    totalProfit?: number
    totalVolume?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    lastActiveAt?: Date | string | null
    isActive?: boolean
    status?: $Enums.AccountStatus
    emailVerified?: boolean
    verificationCode?: string | null
    verificationExpiry?: Date | string | null
    mt5Accounts?: MT5AccountUncheckedCreateNestedManyWithoutUserInput
    eas?: EAUncheckedCreateNestedManyWithoutUserInput
    trades?: TradeUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationLogUncheckedCreateNestedManyWithoutUserInput
    insights?: UserInsightUncheckedCreateNestedOneWithoutUserInput
    automations?: AutomationUncheckedCreateNestedManyWithoutUserInput
    leaderboardStats?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    accountAssignments?: MT5AccountAssignmentUncheckedCreateNestedManyWithoutUserInput
    anonymousAccounts?: AnonymousAccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAgentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAgentsInput, UserUncheckedCreateWithoutAgentsInput>
  }

  export type AgentCreateWithoutSlaveAgentsInput = {
    id?: string
    machineId: string
    machineName?: string | null
    isPoolAgent?: boolean
    managedAccounts?: AgentCreatemanagedAccountsInput | string[]
    maxCapacity?: number
    currentLoad?: number
    vpsName?: string | null
    vpsRegion?: string | null
    vpsIp?: string | null
    mt5AccountNumber?: string | null
    mt5Broker?: string | null
    mt5ServerName?: string | null
    mt5Version?: string | null
    status?: string
    lastHeartbeat?: Date | string | null
    connectedAt?: Date | string | null
    disconnectedAt?: Date | string | null
    eaLoaded?: boolean
    eaRunning?: boolean
    eaName?: string | null
    chartSymbol?: string | null
    chartTimeframe?: string | null
    tradeCopierActive?: boolean
    isMasterAccount?: boolean
    totalTrades?: number
    profitableTrades?: number
    losingTrades?: number
    totalProfit?: number
    winRate?: number
    indicatorSettings?: NullableJsonNullValueInput | InputJsonValue
    aiOptimizationScore?: number
    lastOptimizedAt?: Date | string | null
    apiKey?: string | null
    osVersion?: string | null
    agentVersion?: string | null
    cpuUsage?: number | null
    memoryUsage?: number | null
    diskUsage?: number | null
    mt5InstanceCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutAgentsInput
    masterAgent?: AgentCreateNestedOneWithoutSlaveAgentsInput
    accountAssignments?: MT5AccountAssignmentCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutSlaveAgentsInput = {
    id?: string
    userId?: string | null
    machineId: string
    machineName?: string | null
    isPoolAgent?: boolean
    managedAccounts?: AgentCreatemanagedAccountsInput | string[]
    maxCapacity?: number
    currentLoad?: number
    vpsName?: string | null
    vpsRegion?: string | null
    vpsIp?: string | null
    mt5AccountNumber?: string | null
    mt5Broker?: string | null
    mt5ServerName?: string | null
    mt5Version?: string | null
    status?: string
    lastHeartbeat?: Date | string | null
    connectedAt?: Date | string | null
    disconnectedAt?: Date | string | null
    eaLoaded?: boolean
    eaRunning?: boolean
    eaName?: string | null
    chartSymbol?: string | null
    chartTimeframe?: string | null
    tradeCopierActive?: boolean
    isMasterAccount?: boolean
    masterAgentId?: string | null
    totalTrades?: number
    profitableTrades?: number
    losingTrades?: number
    totalProfit?: number
    winRate?: number
    indicatorSettings?: NullableJsonNullValueInput | InputJsonValue
    aiOptimizationScore?: number
    lastOptimizedAt?: Date | string | null
    apiKey?: string | null
    osVersion?: string | null
    agentVersion?: string | null
    cpuUsage?: number | null
    memoryUsage?: number | null
    diskUsage?: number | null
    mt5InstanceCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accountAssignments?: MT5AccountAssignmentUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutSlaveAgentsInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutSlaveAgentsInput, AgentUncheckedCreateWithoutSlaveAgentsInput>
  }

  export type AgentCreateWithoutMasterAgentInput = {
    id?: string
    machineId: string
    machineName?: string | null
    isPoolAgent?: boolean
    managedAccounts?: AgentCreatemanagedAccountsInput | string[]
    maxCapacity?: number
    currentLoad?: number
    vpsName?: string | null
    vpsRegion?: string | null
    vpsIp?: string | null
    mt5AccountNumber?: string | null
    mt5Broker?: string | null
    mt5ServerName?: string | null
    mt5Version?: string | null
    status?: string
    lastHeartbeat?: Date | string | null
    connectedAt?: Date | string | null
    disconnectedAt?: Date | string | null
    eaLoaded?: boolean
    eaRunning?: boolean
    eaName?: string | null
    chartSymbol?: string | null
    chartTimeframe?: string | null
    tradeCopierActive?: boolean
    isMasterAccount?: boolean
    totalTrades?: number
    profitableTrades?: number
    losingTrades?: number
    totalProfit?: number
    winRate?: number
    indicatorSettings?: NullableJsonNullValueInput | InputJsonValue
    aiOptimizationScore?: number
    lastOptimizedAt?: Date | string | null
    apiKey?: string | null
    osVersion?: string | null
    agentVersion?: string | null
    cpuUsage?: number | null
    memoryUsage?: number | null
    diskUsage?: number | null
    mt5InstanceCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutAgentsInput
    slaveAgents?: AgentCreateNestedManyWithoutMasterAgentInput
    accountAssignments?: MT5AccountAssignmentCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutMasterAgentInput = {
    id?: string
    userId?: string | null
    machineId: string
    machineName?: string | null
    isPoolAgent?: boolean
    managedAccounts?: AgentCreatemanagedAccountsInput | string[]
    maxCapacity?: number
    currentLoad?: number
    vpsName?: string | null
    vpsRegion?: string | null
    vpsIp?: string | null
    mt5AccountNumber?: string | null
    mt5Broker?: string | null
    mt5ServerName?: string | null
    mt5Version?: string | null
    status?: string
    lastHeartbeat?: Date | string | null
    connectedAt?: Date | string | null
    disconnectedAt?: Date | string | null
    eaLoaded?: boolean
    eaRunning?: boolean
    eaName?: string | null
    chartSymbol?: string | null
    chartTimeframe?: string | null
    tradeCopierActive?: boolean
    isMasterAccount?: boolean
    totalTrades?: number
    profitableTrades?: number
    losingTrades?: number
    totalProfit?: number
    winRate?: number
    indicatorSettings?: NullableJsonNullValueInput | InputJsonValue
    aiOptimizationScore?: number
    lastOptimizedAt?: Date | string | null
    apiKey?: string | null
    osVersion?: string | null
    agentVersion?: string | null
    cpuUsage?: number | null
    memoryUsage?: number | null
    diskUsage?: number | null
    mt5InstanceCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slaveAgents?: AgentUncheckedCreateNestedManyWithoutMasterAgentInput
    accountAssignments?: MT5AccountAssignmentUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutMasterAgentInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutMasterAgentInput, AgentUncheckedCreateWithoutMasterAgentInput>
  }

  export type AgentCreateManyMasterAgentInputEnvelope = {
    data: AgentCreateManyMasterAgentInput | AgentCreateManyMasterAgentInput[]
    skipDuplicates?: boolean
  }

  export type MT5AccountAssignmentCreateWithoutAgentInput = {
    id?: string
    mt5AccountNumber: string
    mt5Broker?: string | null
    mt5ServerName?: string | null
    assignedAt?: Date | string
    isActive?: boolean
    status?: string
    eaStatus?: string
    lastHeartbeat?: Date | string | null
    balance?: number
    equity?: number
    margin?: number
    freeMargin?: number
    profit?: number
    eaLoaded?: boolean
    eaRunning?: boolean
    eaName?: string | null
    chartSymbol?: string | null
    chartTimeframe?: string | null
    totalTrades?: number
    profitableTrades?: number
    losingTrades?: number
    totalProfit?: number
    winRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAccountAssignmentsInput
  }

  export type MT5AccountAssignmentUncheckedCreateWithoutAgentInput = {
    id?: string
    userId: string
    mt5AccountNumber: string
    mt5Broker?: string | null
    mt5ServerName?: string | null
    assignedAt?: Date | string
    isActive?: boolean
    status?: string
    eaStatus?: string
    lastHeartbeat?: Date | string | null
    balance?: number
    equity?: number
    margin?: number
    freeMargin?: number
    profit?: number
    eaLoaded?: boolean
    eaRunning?: boolean
    eaName?: string | null
    chartSymbol?: string | null
    chartTimeframe?: string | null
    totalTrades?: number
    profitableTrades?: number
    losingTrades?: number
    totalProfit?: number
    winRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MT5AccountAssignmentCreateOrConnectWithoutAgentInput = {
    where: MT5AccountAssignmentWhereUniqueInput
    create: XOR<MT5AccountAssignmentCreateWithoutAgentInput, MT5AccountAssignmentUncheckedCreateWithoutAgentInput>
  }

  export type MT5AccountAssignmentCreateManyAgentInputEnvelope = {
    data: MT5AccountAssignmentCreateManyAgentInput | MT5AccountAssignmentCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAgentsInput = {
    update: XOR<UserUpdateWithoutAgentsInput, UserUncheckedUpdateWithoutAgentsInput>
    create: XOR<UserCreateWithoutAgentsInput, UserUncheckedCreateWithoutAgentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAgentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAgentsInput, UserUncheckedUpdateWithoutAgentsInput>
  }

  export type UserUpdateWithoutAgentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ibCode?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyFee?: FloatFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    winningTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ibPartner?: IBPartnerUpdateOneWithoutUsersNestedInput
    mt5Accounts?: MT5AccountUpdateManyWithoutUserNestedInput
    eas?: EAUpdateManyWithoutUserNestedInput
    trades?: TradeUpdateManyWithoutUserNestedInput
    notifications?: NotificationLogUpdateManyWithoutUserNestedInput
    insights?: UserInsightUpdateOneWithoutUserNestedInput
    automations?: AutomationUpdateManyWithoutUserNestedInput
    leaderboardStats?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    accountAssignments?: MT5AccountAssignmentUpdateManyWithoutUserNestedInput
    anonymousAccounts?: AnonymousAccountUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAgentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ibCode?: NullableStringFieldUpdateOperationsInput | string | null
    ibPartnerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyFee?: FloatFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    winningTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mt5Accounts?: MT5AccountUncheckedUpdateManyWithoutUserNestedInput
    eas?: EAUncheckedUpdateManyWithoutUserNestedInput
    trades?: TradeUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationLogUncheckedUpdateManyWithoutUserNestedInput
    insights?: UserInsightUncheckedUpdateOneWithoutUserNestedInput
    automations?: AutomationUncheckedUpdateManyWithoutUserNestedInput
    leaderboardStats?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    accountAssignments?: MT5AccountAssignmentUncheckedUpdateManyWithoutUserNestedInput
    anonymousAccounts?: AnonymousAccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AgentUpsertWithoutSlaveAgentsInput = {
    update: XOR<AgentUpdateWithoutSlaveAgentsInput, AgentUncheckedUpdateWithoutSlaveAgentsInput>
    create: XOR<AgentCreateWithoutSlaveAgentsInput, AgentUncheckedCreateWithoutSlaveAgentsInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutSlaveAgentsInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutSlaveAgentsInput, AgentUncheckedUpdateWithoutSlaveAgentsInput>
  }

  export type AgentUpdateWithoutSlaveAgentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    machineId?: StringFieldUpdateOperationsInput | string
    machineName?: NullableStringFieldUpdateOperationsInput | string | null
    isPoolAgent?: BoolFieldUpdateOperationsInput | boolean
    managedAccounts?: AgentUpdatemanagedAccountsInput | string[]
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentLoad?: IntFieldUpdateOperationsInput | number
    vpsName?: NullableStringFieldUpdateOperationsInput | string | null
    vpsRegion?: NullableStringFieldUpdateOperationsInput | string | null
    vpsIp?: NullableStringFieldUpdateOperationsInput | string | null
    mt5AccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    mt5Broker?: NullableStringFieldUpdateOperationsInput | string | null
    mt5ServerName?: NullableStringFieldUpdateOperationsInput | string | null
    mt5Version?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastHeartbeat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    connectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eaLoaded?: BoolFieldUpdateOperationsInput | boolean
    eaRunning?: BoolFieldUpdateOperationsInput | boolean
    eaName?: NullableStringFieldUpdateOperationsInput | string | null
    chartSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    chartTimeframe?: NullableStringFieldUpdateOperationsInput | string | null
    tradeCopierActive?: BoolFieldUpdateOperationsInput | boolean
    isMasterAccount?: BoolFieldUpdateOperationsInput | boolean
    totalTrades?: IntFieldUpdateOperationsInput | number
    profitableTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    indicatorSettings?: NullableJsonNullValueInput | InputJsonValue
    aiOptimizationScore?: FloatFieldUpdateOperationsInput | number
    lastOptimizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    agentVersion?: NullableStringFieldUpdateOperationsInput | string | null
    cpuUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    memoryUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    diskUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    mt5InstanceCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAgentsNestedInput
    masterAgent?: AgentUpdateOneWithoutSlaveAgentsNestedInput
    accountAssignments?: MT5AccountAssignmentUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutSlaveAgentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    machineId?: StringFieldUpdateOperationsInput | string
    machineName?: NullableStringFieldUpdateOperationsInput | string | null
    isPoolAgent?: BoolFieldUpdateOperationsInput | boolean
    managedAccounts?: AgentUpdatemanagedAccountsInput | string[]
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentLoad?: IntFieldUpdateOperationsInput | number
    vpsName?: NullableStringFieldUpdateOperationsInput | string | null
    vpsRegion?: NullableStringFieldUpdateOperationsInput | string | null
    vpsIp?: NullableStringFieldUpdateOperationsInput | string | null
    mt5AccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    mt5Broker?: NullableStringFieldUpdateOperationsInput | string | null
    mt5ServerName?: NullableStringFieldUpdateOperationsInput | string | null
    mt5Version?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastHeartbeat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    connectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eaLoaded?: BoolFieldUpdateOperationsInput | boolean
    eaRunning?: BoolFieldUpdateOperationsInput | boolean
    eaName?: NullableStringFieldUpdateOperationsInput | string | null
    chartSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    chartTimeframe?: NullableStringFieldUpdateOperationsInput | string | null
    tradeCopierActive?: BoolFieldUpdateOperationsInput | boolean
    isMasterAccount?: BoolFieldUpdateOperationsInput | boolean
    masterAgentId?: NullableStringFieldUpdateOperationsInput | string | null
    totalTrades?: IntFieldUpdateOperationsInput | number
    profitableTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    indicatorSettings?: NullableJsonNullValueInput | InputJsonValue
    aiOptimizationScore?: FloatFieldUpdateOperationsInput | number
    lastOptimizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    agentVersion?: NullableStringFieldUpdateOperationsInput | string | null
    cpuUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    memoryUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    diskUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    mt5InstanceCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountAssignments?: MT5AccountAssignmentUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AgentUpsertWithWhereUniqueWithoutMasterAgentInput = {
    where: AgentWhereUniqueInput
    update: XOR<AgentUpdateWithoutMasterAgentInput, AgentUncheckedUpdateWithoutMasterAgentInput>
    create: XOR<AgentCreateWithoutMasterAgentInput, AgentUncheckedCreateWithoutMasterAgentInput>
  }

  export type AgentUpdateWithWhereUniqueWithoutMasterAgentInput = {
    where: AgentWhereUniqueInput
    data: XOR<AgentUpdateWithoutMasterAgentInput, AgentUncheckedUpdateWithoutMasterAgentInput>
  }

  export type AgentUpdateManyWithWhereWithoutMasterAgentInput = {
    where: AgentScalarWhereInput
    data: XOR<AgentUpdateManyMutationInput, AgentUncheckedUpdateManyWithoutMasterAgentInput>
  }

  export type MT5AccountAssignmentUpsertWithWhereUniqueWithoutAgentInput = {
    where: MT5AccountAssignmentWhereUniqueInput
    update: XOR<MT5AccountAssignmentUpdateWithoutAgentInput, MT5AccountAssignmentUncheckedUpdateWithoutAgentInput>
    create: XOR<MT5AccountAssignmentCreateWithoutAgentInput, MT5AccountAssignmentUncheckedCreateWithoutAgentInput>
  }

  export type MT5AccountAssignmentUpdateWithWhereUniqueWithoutAgentInput = {
    where: MT5AccountAssignmentWhereUniqueInput
    data: XOR<MT5AccountAssignmentUpdateWithoutAgentInput, MT5AccountAssignmentUncheckedUpdateWithoutAgentInput>
  }

  export type MT5AccountAssignmentUpdateManyWithWhereWithoutAgentInput = {
    where: MT5AccountAssignmentScalarWhereInput
    data: XOR<MT5AccountAssignmentUpdateManyMutationInput, MT5AccountAssignmentUncheckedUpdateManyWithoutAgentInput>
  }

  export type UserCreateWithoutAccountAssignmentsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    phone?: string | null
    ibCode?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    monthlyFee?: number
    totalTrades?: number
    winningTrades?: number
    losingTrades?: number
    totalProfit?: number
    totalVolume?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    lastActiveAt?: Date | string | null
    isActive?: boolean
    status?: $Enums.AccountStatus
    emailVerified?: boolean
    verificationCode?: string | null
    verificationExpiry?: Date | string | null
    ibPartner?: IBPartnerCreateNestedOneWithoutUsersInput
    mt5Accounts?: MT5AccountCreateNestedManyWithoutUserInput
    eas?: EACreateNestedManyWithoutUserInput
    trades?: TradeCreateNestedManyWithoutUserInput
    notifications?: NotificationLogCreateNestedManyWithoutUserInput
    insights?: UserInsightCreateNestedOneWithoutUserInput
    automations?: AutomationCreateNestedManyWithoutUserInput
    leaderboardStats?: LeaderboardEntryCreateNestedManyWithoutUserInput
    agents?: AgentCreateNestedManyWithoutUserInput
    anonymousAccounts?: AnonymousAccountCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountAssignmentsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    phone?: string | null
    ibCode?: string | null
    ibPartnerId?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    monthlyFee?: number
    totalTrades?: number
    winningTrades?: number
    losingTrades?: number
    totalProfit?: number
    totalVolume?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    lastActiveAt?: Date | string | null
    isActive?: boolean
    status?: $Enums.AccountStatus
    emailVerified?: boolean
    verificationCode?: string | null
    verificationExpiry?: Date | string | null
    mt5Accounts?: MT5AccountUncheckedCreateNestedManyWithoutUserInput
    eas?: EAUncheckedCreateNestedManyWithoutUserInput
    trades?: TradeUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationLogUncheckedCreateNestedManyWithoutUserInput
    insights?: UserInsightUncheckedCreateNestedOneWithoutUserInput
    automations?: AutomationUncheckedCreateNestedManyWithoutUserInput
    leaderboardStats?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    agents?: AgentUncheckedCreateNestedManyWithoutUserInput
    anonymousAccounts?: AnonymousAccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountAssignmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountAssignmentsInput, UserUncheckedCreateWithoutAccountAssignmentsInput>
  }

  export type AgentCreateWithoutAccountAssignmentsInput = {
    id?: string
    machineId: string
    machineName?: string | null
    isPoolAgent?: boolean
    managedAccounts?: AgentCreatemanagedAccountsInput | string[]
    maxCapacity?: number
    currentLoad?: number
    vpsName?: string | null
    vpsRegion?: string | null
    vpsIp?: string | null
    mt5AccountNumber?: string | null
    mt5Broker?: string | null
    mt5ServerName?: string | null
    mt5Version?: string | null
    status?: string
    lastHeartbeat?: Date | string | null
    connectedAt?: Date | string | null
    disconnectedAt?: Date | string | null
    eaLoaded?: boolean
    eaRunning?: boolean
    eaName?: string | null
    chartSymbol?: string | null
    chartTimeframe?: string | null
    tradeCopierActive?: boolean
    isMasterAccount?: boolean
    totalTrades?: number
    profitableTrades?: number
    losingTrades?: number
    totalProfit?: number
    winRate?: number
    indicatorSettings?: NullableJsonNullValueInput | InputJsonValue
    aiOptimizationScore?: number
    lastOptimizedAt?: Date | string | null
    apiKey?: string | null
    osVersion?: string | null
    agentVersion?: string | null
    cpuUsage?: number | null
    memoryUsage?: number | null
    diskUsage?: number | null
    mt5InstanceCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutAgentsInput
    masterAgent?: AgentCreateNestedOneWithoutSlaveAgentsInput
    slaveAgents?: AgentCreateNestedManyWithoutMasterAgentInput
  }

  export type AgentUncheckedCreateWithoutAccountAssignmentsInput = {
    id?: string
    userId?: string | null
    machineId: string
    machineName?: string | null
    isPoolAgent?: boolean
    managedAccounts?: AgentCreatemanagedAccountsInput | string[]
    maxCapacity?: number
    currentLoad?: number
    vpsName?: string | null
    vpsRegion?: string | null
    vpsIp?: string | null
    mt5AccountNumber?: string | null
    mt5Broker?: string | null
    mt5ServerName?: string | null
    mt5Version?: string | null
    status?: string
    lastHeartbeat?: Date | string | null
    connectedAt?: Date | string | null
    disconnectedAt?: Date | string | null
    eaLoaded?: boolean
    eaRunning?: boolean
    eaName?: string | null
    chartSymbol?: string | null
    chartTimeframe?: string | null
    tradeCopierActive?: boolean
    isMasterAccount?: boolean
    masterAgentId?: string | null
    totalTrades?: number
    profitableTrades?: number
    losingTrades?: number
    totalProfit?: number
    winRate?: number
    indicatorSettings?: NullableJsonNullValueInput | InputJsonValue
    aiOptimizationScore?: number
    lastOptimizedAt?: Date | string | null
    apiKey?: string | null
    osVersion?: string | null
    agentVersion?: string | null
    cpuUsage?: number | null
    memoryUsage?: number | null
    diskUsage?: number | null
    mt5InstanceCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slaveAgents?: AgentUncheckedCreateNestedManyWithoutMasterAgentInput
  }

  export type AgentCreateOrConnectWithoutAccountAssignmentsInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutAccountAssignmentsInput, AgentUncheckedCreateWithoutAccountAssignmentsInput>
  }

  export type UserUpsertWithoutAccountAssignmentsInput = {
    update: XOR<UserUpdateWithoutAccountAssignmentsInput, UserUncheckedUpdateWithoutAccountAssignmentsInput>
    create: XOR<UserCreateWithoutAccountAssignmentsInput, UserUncheckedCreateWithoutAccountAssignmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountAssignmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountAssignmentsInput, UserUncheckedUpdateWithoutAccountAssignmentsInput>
  }

  export type UserUpdateWithoutAccountAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ibCode?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyFee?: FloatFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    winningTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ibPartner?: IBPartnerUpdateOneWithoutUsersNestedInput
    mt5Accounts?: MT5AccountUpdateManyWithoutUserNestedInput
    eas?: EAUpdateManyWithoutUserNestedInput
    trades?: TradeUpdateManyWithoutUserNestedInput
    notifications?: NotificationLogUpdateManyWithoutUserNestedInput
    insights?: UserInsightUpdateOneWithoutUserNestedInput
    automations?: AutomationUpdateManyWithoutUserNestedInput
    leaderboardStats?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    agents?: AgentUpdateManyWithoutUserNestedInput
    anonymousAccounts?: AnonymousAccountUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ibCode?: NullableStringFieldUpdateOperationsInput | string | null
    ibPartnerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyFee?: FloatFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    winningTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mt5Accounts?: MT5AccountUncheckedUpdateManyWithoutUserNestedInput
    eas?: EAUncheckedUpdateManyWithoutUserNestedInput
    trades?: TradeUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationLogUncheckedUpdateManyWithoutUserNestedInput
    insights?: UserInsightUncheckedUpdateOneWithoutUserNestedInput
    automations?: AutomationUncheckedUpdateManyWithoutUserNestedInput
    leaderboardStats?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    agents?: AgentUncheckedUpdateManyWithoutUserNestedInput
    anonymousAccounts?: AnonymousAccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AgentUpsertWithoutAccountAssignmentsInput = {
    update: XOR<AgentUpdateWithoutAccountAssignmentsInput, AgentUncheckedUpdateWithoutAccountAssignmentsInput>
    create: XOR<AgentCreateWithoutAccountAssignmentsInput, AgentUncheckedCreateWithoutAccountAssignmentsInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutAccountAssignmentsInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutAccountAssignmentsInput, AgentUncheckedUpdateWithoutAccountAssignmentsInput>
  }

  export type AgentUpdateWithoutAccountAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    machineId?: StringFieldUpdateOperationsInput | string
    machineName?: NullableStringFieldUpdateOperationsInput | string | null
    isPoolAgent?: BoolFieldUpdateOperationsInput | boolean
    managedAccounts?: AgentUpdatemanagedAccountsInput | string[]
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentLoad?: IntFieldUpdateOperationsInput | number
    vpsName?: NullableStringFieldUpdateOperationsInput | string | null
    vpsRegion?: NullableStringFieldUpdateOperationsInput | string | null
    vpsIp?: NullableStringFieldUpdateOperationsInput | string | null
    mt5AccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    mt5Broker?: NullableStringFieldUpdateOperationsInput | string | null
    mt5ServerName?: NullableStringFieldUpdateOperationsInput | string | null
    mt5Version?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastHeartbeat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    connectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eaLoaded?: BoolFieldUpdateOperationsInput | boolean
    eaRunning?: BoolFieldUpdateOperationsInput | boolean
    eaName?: NullableStringFieldUpdateOperationsInput | string | null
    chartSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    chartTimeframe?: NullableStringFieldUpdateOperationsInput | string | null
    tradeCopierActive?: BoolFieldUpdateOperationsInput | boolean
    isMasterAccount?: BoolFieldUpdateOperationsInput | boolean
    totalTrades?: IntFieldUpdateOperationsInput | number
    profitableTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    indicatorSettings?: NullableJsonNullValueInput | InputJsonValue
    aiOptimizationScore?: FloatFieldUpdateOperationsInput | number
    lastOptimizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    agentVersion?: NullableStringFieldUpdateOperationsInput | string | null
    cpuUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    memoryUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    diskUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    mt5InstanceCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAgentsNestedInput
    masterAgent?: AgentUpdateOneWithoutSlaveAgentsNestedInput
    slaveAgents?: AgentUpdateManyWithoutMasterAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutAccountAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    machineId?: StringFieldUpdateOperationsInput | string
    machineName?: NullableStringFieldUpdateOperationsInput | string | null
    isPoolAgent?: BoolFieldUpdateOperationsInput | boolean
    managedAccounts?: AgentUpdatemanagedAccountsInput | string[]
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentLoad?: IntFieldUpdateOperationsInput | number
    vpsName?: NullableStringFieldUpdateOperationsInput | string | null
    vpsRegion?: NullableStringFieldUpdateOperationsInput | string | null
    vpsIp?: NullableStringFieldUpdateOperationsInput | string | null
    mt5AccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    mt5Broker?: NullableStringFieldUpdateOperationsInput | string | null
    mt5ServerName?: NullableStringFieldUpdateOperationsInput | string | null
    mt5Version?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastHeartbeat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    connectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eaLoaded?: BoolFieldUpdateOperationsInput | boolean
    eaRunning?: BoolFieldUpdateOperationsInput | boolean
    eaName?: NullableStringFieldUpdateOperationsInput | string | null
    chartSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    chartTimeframe?: NullableStringFieldUpdateOperationsInput | string | null
    tradeCopierActive?: BoolFieldUpdateOperationsInput | boolean
    isMasterAccount?: BoolFieldUpdateOperationsInput | boolean
    masterAgentId?: NullableStringFieldUpdateOperationsInput | string | null
    totalTrades?: IntFieldUpdateOperationsInput | number
    profitableTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    indicatorSettings?: NullableJsonNullValueInput | InputJsonValue
    aiOptimizationScore?: FloatFieldUpdateOperationsInput | number
    lastOptimizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    agentVersion?: NullableStringFieldUpdateOperationsInput | string | null
    cpuUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    memoryUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    diskUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    mt5InstanceCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slaveAgents?: AgentUncheckedUpdateManyWithoutMasterAgentNestedInput
  }

  export type UserCreateWithoutAnonymousAccountsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    phone?: string | null
    ibCode?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    monthlyFee?: number
    totalTrades?: number
    winningTrades?: number
    losingTrades?: number
    totalProfit?: number
    totalVolume?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    lastActiveAt?: Date | string | null
    isActive?: boolean
    status?: $Enums.AccountStatus
    emailVerified?: boolean
    verificationCode?: string | null
    verificationExpiry?: Date | string | null
    ibPartner?: IBPartnerCreateNestedOneWithoutUsersInput
    mt5Accounts?: MT5AccountCreateNestedManyWithoutUserInput
    eas?: EACreateNestedManyWithoutUserInput
    trades?: TradeCreateNestedManyWithoutUserInput
    notifications?: NotificationLogCreateNestedManyWithoutUserInput
    insights?: UserInsightCreateNestedOneWithoutUserInput
    automations?: AutomationCreateNestedManyWithoutUserInput
    leaderboardStats?: LeaderboardEntryCreateNestedManyWithoutUserInput
    agents?: AgentCreateNestedManyWithoutUserInput
    accountAssignments?: MT5AccountAssignmentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAnonymousAccountsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    phone?: string | null
    ibCode?: string | null
    ibPartnerId?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    monthlyFee?: number
    totalTrades?: number
    winningTrades?: number
    losingTrades?: number
    totalProfit?: number
    totalVolume?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    lastActiveAt?: Date | string | null
    isActive?: boolean
    status?: $Enums.AccountStatus
    emailVerified?: boolean
    verificationCode?: string | null
    verificationExpiry?: Date | string | null
    mt5Accounts?: MT5AccountUncheckedCreateNestedManyWithoutUserInput
    eas?: EAUncheckedCreateNestedManyWithoutUserInput
    trades?: TradeUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationLogUncheckedCreateNestedManyWithoutUserInput
    insights?: UserInsightUncheckedCreateNestedOneWithoutUserInput
    automations?: AutomationUncheckedCreateNestedManyWithoutUserInput
    leaderboardStats?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    agents?: AgentUncheckedCreateNestedManyWithoutUserInput
    accountAssignments?: MT5AccountAssignmentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAnonymousAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAnonymousAccountsInput, UserUncheckedCreateWithoutAnonymousAccountsInput>
  }

  export type IBPartnerCreateWithoutAnonymousAccountsInput = {
    id?: string
    email: string
    passwordHash: string
    companyName: string
    contactName: string
    phone: string
    ibCode: string
    domain?: string | null
    logo?: string | null
    favicon?: string | null
    brandColor?: string
    brandName?: string | null
    isActive?: boolean
    isApproved?: boolean
    currentTraders?: string | null
    message?: string | null
    companyDocument?: string | null
    idDocument?: string | null
    kycDocument?: string | null
    kycStatus?: string
    emailVerified?: boolean
    verificationCode?: string | null
    verificationExpiry?: Date | string | null
    pricingTier?: string
    monthlyFee?: number
    traderLimit?: number
    spreadRevShare?: number
    totalTraders?: number
    activeTraders?: number
    monthlyRevenue?: number
    lifetimeRevenue?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedAt?: Date | string | null
    approvedBy?: string | null
    users?: UserCreateNestedManyWithoutIbPartnerInput
    commissions?: IBCommissionCreateNestedManyWithoutIbPartnerInput
    commissionRates?: IBCommissionRateCreateNestedManyWithoutIbPartnerInput
  }

  export type IBPartnerUncheckedCreateWithoutAnonymousAccountsInput = {
    id?: string
    email: string
    passwordHash: string
    companyName: string
    contactName: string
    phone: string
    ibCode: string
    domain?: string | null
    logo?: string | null
    favicon?: string | null
    brandColor?: string
    brandName?: string | null
    isActive?: boolean
    isApproved?: boolean
    currentTraders?: string | null
    message?: string | null
    companyDocument?: string | null
    idDocument?: string | null
    kycDocument?: string | null
    kycStatus?: string
    emailVerified?: boolean
    verificationCode?: string | null
    verificationExpiry?: Date | string | null
    pricingTier?: string
    monthlyFee?: number
    traderLimit?: number
    spreadRevShare?: number
    totalTraders?: number
    activeTraders?: number
    monthlyRevenue?: number
    lifetimeRevenue?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedAt?: Date | string | null
    approvedBy?: string | null
    users?: UserUncheckedCreateNestedManyWithoutIbPartnerInput
    commissions?: IBCommissionUncheckedCreateNestedManyWithoutIbPartnerInput
    commissionRates?: IBCommissionRateUncheckedCreateNestedManyWithoutIbPartnerInput
  }

  export type IBPartnerCreateOrConnectWithoutAnonymousAccountsInput = {
    where: IBPartnerWhereUniqueInput
    create: XOR<IBPartnerCreateWithoutAnonymousAccountsInput, IBPartnerUncheckedCreateWithoutAnonymousAccountsInput>
  }

  export type IBCommissionCreateWithoutAnonymousAccountInput = {
    id?: string
    period: Date | string
    periodEnd: Date | string
    tradingVolume?: number
    numberOfTrades?: number
    averageSpread?: number
    commissionRate: number
    grossCommission?: number
    platformFee?: number
    netCommission?: number
    isPaid?: boolean
    paidAt?: Date | string | null
    paymentReference?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ibPartner: IBPartnerCreateNestedOneWithoutCommissionsInput
  }

  export type IBCommissionUncheckedCreateWithoutAnonymousAccountInput = {
    id?: string
    ibPartnerId: string
    period: Date | string
    periodEnd: Date | string
    tradingVolume?: number
    numberOfTrades?: number
    averageSpread?: number
    commissionRate: number
    grossCommission?: number
    platformFee?: number
    netCommission?: number
    isPaid?: boolean
    paidAt?: Date | string | null
    paymentReference?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IBCommissionCreateOrConnectWithoutAnonymousAccountInput = {
    where: IBCommissionWhereUniqueInput
    create: XOR<IBCommissionCreateWithoutAnonymousAccountInput, IBCommissionUncheckedCreateWithoutAnonymousAccountInput>
  }

  export type IBCommissionCreateManyAnonymousAccountInputEnvelope = {
    data: IBCommissionCreateManyAnonymousAccountInput | IBCommissionCreateManyAnonymousAccountInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAnonymousAccountsInput = {
    update: XOR<UserUpdateWithoutAnonymousAccountsInput, UserUncheckedUpdateWithoutAnonymousAccountsInput>
    create: XOR<UserCreateWithoutAnonymousAccountsInput, UserUncheckedCreateWithoutAnonymousAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAnonymousAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAnonymousAccountsInput, UserUncheckedUpdateWithoutAnonymousAccountsInput>
  }

  export type UserUpdateWithoutAnonymousAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ibCode?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyFee?: FloatFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    winningTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ibPartner?: IBPartnerUpdateOneWithoutUsersNestedInput
    mt5Accounts?: MT5AccountUpdateManyWithoutUserNestedInput
    eas?: EAUpdateManyWithoutUserNestedInput
    trades?: TradeUpdateManyWithoutUserNestedInput
    notifications?: NotificationLogUpdateManyWithoutUserNestedInput
    insights?: UserInsightUpdateOneWithoutUserNestedInput
    automations?: AutomationUpdateManyWithoutUserNestedInput
    leaderboardStats?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    agents?: AgentUpdateManyWithoutUserNestedInput
    accountAssignments?: MT5AccountAssignmentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAnonymousAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ibCode?: NullableStringFieldUpdateOperationsInput | string | null
    ibPartnerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyFee?: FloatFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    winningTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mt5Accounts?: MT5AccountUncheckedUpdateManyWithoutUserNestedInput
    eas?: EAUncheckedUpdateManyWithoutUserNestedInput
    trades?: TradeUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationLogUncheckedUpdateManyWithoutUserNestedInput
    insights?: UserInsightUncheckedUpdateOneWithoutUserNestedInput
    automations?: AutomationUncheckedUpdateManyWithoutUserNestedInput
    leaderboardStats?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    agents?: AgentUncheckedUpdateManyWithoutUserNestedInput
    accountAssignments?: MT5AccountAssignmentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type IBPartnerUpsertWithoutAnonymousAccountsInput = {
    update: XOR<IBPartnerUpdateWithoutAnonymousAccountsInput, IBPartnerUncheckedUpdateWithoutAnonymousAccountsInput>
    create: XOR<IBPartnerCreateWithoutAnonymousAccountsInput, IBPartnerUncheckedCreateWithoutAnonymousAccountsInput>
    where?: IBPartnerWhereInput
  }

  export type IBPartnerUpdateToOneWithWhereWithoutAnonymousAccountsInput = {
    where?: IBPartnerWhereInput
    data: XOR<IBPartnerUpdateWithoutAnonymousAccountsInput, IBPartnerUncheckedUpdateWithoutAnonymousAccountsInput>
  }

  export type IBPartnerUpdateWithoutAnonymousAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    ibCode?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    brandColor?: StringFieldUpdateOperationsInput | string
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    currentTraders?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    companyDocument?: NullableStringFieldUpdateOperationsInput | string | null
    idDocument?: NullableStringFieldUpdateOperationsInput | string | null
    kycDocument?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pricingTier?: StringFieldUpdateOperationsInput | string
    monthlyFee?: FloatFieldUpdateOperationsInput | number
    traderLimit?: IntFieldUpdateOperationsInput | number
    spreadRevShare?: FloatFieldUpdateOperationsInput | number
    totalTraders?: IntFieldUpdateOperationsInput | number
    activeTraders?: IntFieldUpdateOperationsInput | number
    monthlyRevenue?: FloatFieldUpdateOperationsInput | number
    lifetimeRevenue?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUpdateManyWithoutIbPartnerNestedInput
    commissions?: IBCommissionUpdateManyWithoutIbPartnerNestedInput
    commissionRates?: IBCommissionRateUpdateManyWithoutIbPartnerNestedInput
  }

  export type IBPartnerUncheckedUpdateWithoutAnonymousAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    ibCode?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    brandColor?: StringFieldUpdateOperationsInput | string
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    currentTraders?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    companyDocument?: NullableStringFieldUpdateOperationsInput | string | null
    idDocument?: NullableStringFieldUpdateOperationsInput | string | null
    kycDocument?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pricingTier?: StringFieldUpdateOperationsInput | string
    monthlyFee?: FloatFieldUpdateOperationsInput | number
    traderLimit?: IntFieldUpdateOperationsInput | number
    spreadRevShare?: FloatFieldUpdateOperationsInput | number
    totalTraders?: IntFieldUpdateOperationsInput | number
    activeTraders?: IntFieldUpdateOperationsInput | number
    monthlyRevenue?: FloatFieldUpdateOperationsInput | number
    lifetimeRevenue?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutIbPartnerNestedInput
    commissions?: IBCommissionUncheckedUpdateManyWithoutIbPartnerNestedInput
    commissionRates?: IBCommissionRateUncheckedUpdateManyWithoutIbPartnerNestedInput
  }

  export type IBCommissionUpsertWithWhereUniqueWithoutAnonymousAccountInput = {
    where: IBCommissionWhereUniqueInput
    update: XOR<IBCommissionUpdateWithoutAnonymousAccountInput, IBCommissionUncheckedUpdateWithoutAnonymousAccountInput>
    create: XOR<IBCommissionCreateWithoutAnonymousAccountInput, IBCommissionUncheckedCreateWithoutAnonymousAccountInput>
  }

  export type IBCommissionUpdateWithWhereUniqueWithoutAnonymousAccountInput = {
    where: IBCommissionWhereUniqueInput
    data: XOR<IBCommissionUpdateWithoutAnonymousAccountInput, IBCommissionUncheckedUpdateWithoutAnonymousAccountInput>
  }

  export type IBCommissionUpdateManyWithWhereWithoutAnonymousAccountInput = {
    where: IBCommissionScalarWhereInput
    data: XOR<IBCommissionUpdateManyMutationInput, IBCommissionUncheckedUpdateManyWithoutAnonymousAccountInput>
  }

  export type IBPartnerCreateWithoutCommissionsInput = {
    id?: string
    email: string
    passwordHash: string
    companyName: string
    contactName: string
    phone: string
    ibCode: string
    domain?: string | null
    logo?: string | null
    favicon?: string | null
    brandColor?: string
    brandName?: string | null
    isActive?: boolean
    isApproved?: boolean
    currentTraders?: string | null
    message?: string | null
    companyDocument?: string | null
    idDocument?: string | null
    kycDocument?: string | null
    kycStatus?: string
    emailVerified?: boolean
    verificationCode?: string | null
    verificationExpiry?: Date | string | null
    pricingTier?: string
    monthlyFee?: number
    traderLimit?: number
    spreadRevShare?: number
    totalTraders?: number
    activeTraders?: number
    monthlyRevenue?: number
    lifetimeRevenue?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedAt?: Date | string | null
    approvedBy?: string | null
    users?: UserCreateNestedManyWithoutIbPartnerInput
    anonymousAccounts?: AnonymousAccountCreateNestedManyWithoutIbPartnerInput
    commissionRates?: IBCommissionRateCreateNestedManyWithoutIbPartnerInput
  }

  export type IBPartnerUncheckedCreateWithoutCommissionsInput = {
    id?: string
    email: string
    passwordHash: string
    companyName: string
    contactName: string
    phone: string
    ibCode: string
    domain?: string | null
    logo?: string | null
    favicon?: string | null
    brandColor?: string
    brandName?: string | null
    isActive?: boolean
    isApproved?: boolean
    currentTraders?: string | null
    message?: string | null
    companyDocument?: string | null
    idDocument?: string | null
    kycDocument?: string | null
    kycStatus?: string
    emailVerified?: boolean
    verificationCode?: string | null
    verificationExpiry?: Date | string | null
    pricingTier?: string
    monthlyFee?: number
    traderLimit?: number
    spreadRevShare?: number
    totalTraders?: number
    activeTraders?: number
    monthlyRevenue?: number
    lifetimeRevenue?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedAt?: Date | string | null
    approvedBy?: string | null
    users?: UserUncheckedCreateNestedManyWithoutIbPartnerInput
    anonymousAccounts?: AnonymousAccountUncheckedCreateNestedManyWithoutIbPartnerInput
    commissionRates?: IBCommissionRateUncheckedCreateNestedManyWithoutIbPartnerInput
  }

  export type IBPartnerCreateOrConnectWithoutCommissionsInput = {
    where: IBPartnerWhereUniqueInput
    create: XOR<IBPartnerCreateWithoutCommissionsInput, IBPartnerUncheckedCreateWithoutCommissionsInput>
  }

  export type AnonymousAccountCreateWithoutCommissionsInput = {
    id?: string
    anonymousId: string
    mt5AccountNumber: string
    isActive?: boolean
    registeredAt?: Date | string
    user: UserCreateNestedOneWithoutAnonymousAccountsInput
    ibPartner: IBPartnerCreateNestedOneWithoutAnonymousAccountsInput
  }

  export type AnonymousAccountUncheckedCreateWithoutCommissionsInput = {
    id?: string
    anonymousId: string
    userId: string
    mt5AccountNumber: string
    ibPartnerId: string
    isActive?: boolean
    registeredAt?: Date | string
  }

  export type AnonymousAccountCreateOrConnectWithoutCommissionsInput = {
    where: AnonymousAccountWhereUniqueInput
    create: XOR<AnonymousAccountCreateWithoutCommissionsInput, AnonymousAccountUncheckedCreateWithoutCommissionsInput>
  }

  export type IBPartnerUpsertWithoutCommissionsInput = {
    update: XOR<IBPartnerUpdateWithoutCommissionsInput, IBPartnerUncheckedUpdateWithoutCommissionsInput>
    create: XOR<IBPartnerCreateWithoutCommissionsInput, IBPartnerUncheckedCreateWithoutCommissionsInput>
    where?: IBPartnerWhereInput
  }

  export type IBPartnerUpdateToOneWithWhereWithoutCommissionsInput = {
    where?: IBPartnerWhereInput
    data: XOR<IBPartnerUpdateWithoutCommissionsInput, IBPartnerUncheckedUpdateWithoutCommissionsInput>
  }

  export type IBPartnerUpdateWithoutCommissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    ibCode?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    brandColor?: StringFieldUpdateOperationsInput | string
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    currentTraders?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    companyDocument?: NullableStringFieldUpdateOperationsInput | string | null
    idDocument?: NullableStringFieldUpdateOperationsInput | string | null
    kycDocument?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pricingTier?: StringFieldUpdateOperationsInput | string
    monthlyFee?: FloatFieldUpdateOperationsInput | number
    traderLimit?: IntFieldUpdateOperationsInput | number
    spreadRevShare?: FloatFieldUpdateOperationsInput | number
    totalTraders?: IntFieldUpdateOperationsInput | number
    activeTraders?: IntFieldUpdateOperationsInput | number
    monthlyRevenue?: FloatFieldUpdateOperationsInput | number
    lifetimeRevenue?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUpdateManyWithoutIbPartnerNestedInput
    anonymousAccounts?: AnonymousAccountUpdateManyWithoutIbPartnerNestedInput
    commissionRates?: IBCommissionRateUpdateManyWithoutIbPartnerNestedInput
  }

  export type IBPartnerUncheckedUpdateWithoutCommissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    ibCode?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    brandColor?: StringFieldUpdateOperationsInput | string
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    currentTraders?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    companyDocument?: NullableStringFieldUpdateOperationsInput | string | null
    idDocument?: NullableStringFieldUpdateOperationsInput | string | null
    kycDocument?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pricingTier?: StringFieldUpdateOperationsInput | string
    monthlyFee?: FloatFieldUpdateOperationsInput | number
    traderLimit?: IntFieldUpdateOperationsInput | number
    spreadRevShare?: FloatFieldUpdateOperationsInput | number
    totalTraders?: IntFieldUpdateOperationsInput | number
    activeTraders?: IntFieldUpdateOperationsInput | number
    monthlyRevenue?: FloatFieldUpdateOperationsInput | number
    lifetimeRevenue?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutIbPartnerNestedInput
    anonymousAccounts?: AnonymousAccountUncheckedUpdateManyWithoutIbPartnerNestedInput
    commissionRates?: IBCommissionRateUncheckedUpdateManyWithoutIbPartnerNestedInput
  }

  export type AnonymousAccountUpsertWithoutCommissionsInput = {
    update: XOR<AnonymousAccountUpdateWithoutCommissionsInput, AnonymousAccountUncheckedUpdateWithoutCommissionsInput>
    create: XOR<AnonymousAccountCreateWithoutCommissionsInput, AnonymousAccountUncheckedCreateWithoutCommissionsInput>
    where?: AnonymousAccountWhereInput
  }

  export type AnonymousAccountUpdateToOneWithWhereWithoutCommissionsInput = {
    where?: AnonymousAccountWhereInput
    data: XOR<AnonymousAccountUpdateWithoutCommissionsInput, AnonymousAccountUncheckedUpdateWithoutCommissionsInput>
  }

  export type AnonymousAccountUpdateWithoutCommissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: StringFieldUpdateOperationsInput | string
    mt5AccountNumber?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAnonymousAccountsNestedInput
    ibPartner?: IBPartnerUpdateOneRequiredWithoutAnonymousAccountsNestedInput
  }

  export type AnonymousAccountUncheckedUpdateWithoutCommissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mt5AccountNumber?: StringFieldUpdateOperationsInput | string
    ibPartnerId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IBPartnerCreateWithoutCommissionRatesInput = {
    id?: string
    email: string
    passwordHash: string
    companyName: string
    contactName: string
    phone: string
    ibCode: string
    domain?: string | null
    logo?: string | null
    favicon?: string | null
    brandColor?: string
    brandName?: string | null
    isActive?: boolean
    isApproved?: boolean
    currentTraders?: string | null
    message?: string | null
    companyDocument?: string | null
    idDocument?: string | null
    kycDocument?: string | null
    kycStatus?: string
    emailVerified?: boolean
    verificationCode?: string | null
    verificationExpiry?: Date | string | null
    pricingTier?: string
    monthlyFee?: number
    traderLimit?: number
    spreadRevShare?: number
    totalTraders?: number
    activeTraders?: number
    monthlyRevenue?: number
    lifetimeRevenue?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedAt?: Date | string | null
    approvedBy?: string | null
    users?: UserCreateNestedManyWithoutIbPartnerInput
    anonymousAccounts?: AnonymousAccountCreateNestedManyWithoutIbPartnerInput
    commissions?: IBCommissionCreateNestedManyWithoutIbPartnerInput
  }

  export type IBPartnerUncheckedCreateWithoutCommissionRatesInput = {
    id?: string
    email: string
    passwordHash: string
    companyName: string
    contactName: string
    phone: string
    ibCode: string
    domain?: string | null
    logo?: string | null
    favicon?: string | null
    brandColor?: string
    brandName?: string | null
    isActive?: boolean
    isApproved?: boolean
    currentTraders?: string | null
    message?: string | null
    companyDocument?: string | null
    idDocument?: string | null
    kycDocument?: string | null
    kycStatus?: string
    emailVerified?: boolean
    verificationCode?: string | null
    verificationExpiry?: Date | string | null
    pricingTier?: string
    monthlyFee?: number
    traderLimit?: number
    spreadRevShare?: number
    totalTraders?: number
    activeTraders?: number
    monthlyRevenue?: number
    lifetimeRevenue?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedAt?: Date | string | null
    approvedBy?: string | null
    users?: UserUncheckedCreateNestedManyWithoutIbPartnerInput
    anonymousAccounts?: AnonymousAccountUncheckedCreateNestedManyWithoutIbPartnerInput
    commissions?: IBCommissionUncheckedCreateNestedManyWithoutIbPartnerInput
  }

  export type IBPartnerCreateOrConnectWithoutCommissionRatesInput = {
    where: IBPartnerWhereUniqueInput
    create: XOR<IBPartnerCreateWithoutCommissionRatesInput, IBPartnerUncheckedCreateWithoutCommissionRatesInput>
  }

  export type IBPartnerUpsertWithoutCommissionRatesInput = {
    update: XOR<IBPartnerUpdateWithoutCommissionRatesInput, IBPartnerUncheckedUpdateWithoutCommissionRatesInput>
    create: XOR<IBPartnerCreateWithoutCommissionRatesInput, IBPartnerUncheckedCreateWithoutCommissionRatesInput>
    where?: IBPartnerWhereInput
  }

  export type IBPartnerUpdateToOneWithWhereWithoutCommissionRatesInput = {
    where?: IBPartnerWhereInput
    data: XOR<IBPartnerUpdateWithoutCommissionRatesInput, IBPartnerUncheckedUpdateWithoutCommissionRatesInput>
  }

  export type IBPartnerUpdateWithoutCommissionRatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    ibCode?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    brandColor?: StringFieldUpdateOperationsInput | string
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    currentTraders?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    companyDocument?: NullableStringFieldUpdateOperationsInput | string | null
    idDocument?: NullableStringFieldUpdateOperationsInput | string | null
    kycDocument?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pricingTier?: StringFieldUpdateOperationsInput | string
    monthlyFee?: FloatFieldUpdateOperationsInput | number
    traderLimit?: IntFieldUpdateOperationsInput | number
    spreadRevShare?: FloatFieldUpdateOperationsInput | number
    totalTraders?: IntFieldUpdateOperationsInput | number
    activeTraders?: IntFieldUpdateOperationsInput | number
    monthlyRevenue?: FloatFieldUpdateOperationsInput | number
    lifetimeRevenue?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUpdateManyWithoutIbPartnerNestedInput
    anonymousAccounts?: AnonymousAccountUpdateManyWithoutIbPartnerNestedInput
    commissions?: IBCommissionUpdateManyWithoutIbPartnerNestedInput
  }

  export type IBPartnerUncheckedUpdateWithoutCommissionRatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    ibCode?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    brandColor?: StringFieldUpdateOperationsInput | string
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    currentTraders?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    companyDocument?: NullableStringFieldUpdateOperationsInput | string | null
    idDocument?: NullableStringFieldUpdateOperationsInput | string | null
    kycDocument?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pricingTier?: StringFieldUpdateOperationsInput | string
    monthlyFee?: FloatFieldUpdateOperationsInput | number
    traderLimit?: IntFieldUpdateOperationsInput | number
    spreadRevShare?: FloatFieldUpdateOperationsInput | number
    totalTraders?: IntFieldUpdateOperationsInput | number
    activeTraders?: IntFieldUpdateOperationsInput | number
    monthlyRevenue?: FloatFieldUpdateOperationsInput | number
    lifetimeRevenue?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutIbPartnerNestedInput
    anonymousAccounts?: AnonymousAccountUncheckedUpdateManyWithoutIbPartnerNestedInput
    commissions?: IBCommissionUncheckedUpdateManyWithoutIbPartnerNestedInput
  }

  export type MT5AccountCreateManyUserInput = {
    id?: string
    accountNumber: string
    broker: string
    serverName: string
    login: string
    password?: string | null
    vpsIp?: string | null
    vpsPort?: number | null
    status?: $Enums.AccountStatus
    balance?: number
    equity?: number
    margin?: number
    freeMargin?: number
    isEnabledForTrading?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastSyncAt?: Date | string | null
  }

  export type EACreateManyUserInput = {
    id?: string
    mt5AccountId: string
    name: string
    version?: string | null
    magicNumber?: number | null
    status?: $Enums.EAStatus
    safetyIndicator?: $Enums.SafetyIndicator
    indicatorScore?: number
    stoppedByIndicator?: boolean
    stoppedByIndicatorAt?: Date | string | null
    maxLotSize?: number
    riskPercent?: number
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastStartAt?: Date | string | null
    lastStopAt?: Date | string | null
    uptime?: number
    totalTrades?: number
    winningTrades?: number
    totalProfit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TradeCreateManyUserInput = {
    id?: string
    mt5AccountId: string
    ticket: string
    symbol: string
    type: string
    volume: number
    openPrice: number
    openTime: Date | string
    closePrice?: number | null
    closeTime?: Date | string | null
    profit?: number
    commission?: number
    swap?: number
    magicNumber?: number | null
    comment?: string | null
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationLogCreateManyUserInput = {
    id?: string
    automationId: string
    channel: $Enums.AutomationActionType
    recipient: string
    subject?: string | null
    message: string
    status?: $Enums.NotificationStatus
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    failedAt?: Date | string | null
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AutomationCreateManyUserInput = {
    id?: string
    name: string
    description?: string | null
    triggerType: $Enums.AutomationTriggerType
    triggerValue?: number | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    actionTypes?: AutomationCreateactionTypesInput | $Enums.AutomationActionType[]
    actionData?: NullableJsonNullValueInput | InputJsonValue
    messageSubject?: string | null
    messageBody: string
    status?: $Enums.AutomationStatus
    priority?: number
    isUserEnabled?: boolean
    totalTriggered?: number
    totalSent?: number
    totalFailed?: number
    lastTriggered?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
  }

  export type LeaderboardEntryCreateManyUserInput = {
    id?: string
    period: string
    periodDate: Date | string
    trades?: number
    winningTrades?: number
    losingTrades?: number
    profit?: number
    volume?: number
    winRate?: number
    rank?: number | null
    previousRank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentCreateManyUserInput = {
    id?: string
    machineId: string
    machineName?: string | null
    isPoolAgent?: boolean
    managedAccounts?: AgentCreatemanagedAccountsInput | string[]
    maxCapacity?: number
    currentLoad?: number
    vpsName?: string | null
    vpsRegion?: string | null
    vpsIp?: string | null
    mt5AccountNumber?: string | null
    mt5Broker?: string | null
    mt5ServerName?: string | null
    mt5Version?: string | null
    status?: string
    lastHeartbeat?: Date | string | null
    connectedAt?: Date | string | null
    disconnectedAt?: Date | string | null
    eaLoaded?: boolean
    eaRunning?: boolean
    eaName?: string | null
    chartSymbol?: string | null
    chartTimeframe?: string | null
    tradeCopierActive?: boolean
    isMasterAccount?: boolean
    masterAgentId?: string | null
    totalTrades?: number
    profitableTrades?: number
    losingTrades?: number
    totalProfit?: number
    winRate?: number
    indicatorSettings?: NullableJsonNullValueInput | InputJsonValue
    aiOptimizationScore?: number
    lastOptimizedAt?: Date | string | null
    apiKey?: string | null
    osVersion?: string | null
    agentVersion?: string | null
    cpuUsage?: number | null
    memoryUsage?: number | null
    diskUsage?: number | null
    mt5InstanceCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MT5AccountAssignmentCreateManyUserInput = {
    id?: string
    agentId: string
    mt5AccountNumber: string
    mt5Broker?: string | null
    mt5ServerName?: string | null
    assignedAt?: Date | string
    isActive?: boolean
    status?: string
    eaStatus?: string
    lastHeartbeat?: Date | string | null
    balance?: number
    equity?: number
    margin?: number
    freeMargin?: number
    profit?: number
    eaLoaded?: boolean
    eaRunning?: boolean
    eaName?: string | null
    chartSymbol?: string | null
    chartTimeframe?: string | null
    totalTrades?: number
    profitableTrades?: number
    losingTrades?: number
    totalProfit?: number
    winRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnonymousAccountCreateManyUserInput = {
    id?: string
    anonymousId: string
    mt5AccountNumber: string
    ibPartnerId: string
    isActive?: boolean
    registeredAt?: Date | string
  }

  export type MT5AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    broker?: StringFieldUpdateOperationsInput | string
    serverName?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    vpsIp?: NullableStringFieldUpdateOperationsInput | string | null
    vpsPort?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    balance?: FloatFieldUpdateOperationsInput | number
    equity?: FloatFieldUpdateOperationsInput | number
    margin?: FloatFieldUpdateOperationsInput | number
    freeMargin?: FloatFieldUpdateOperationsInput | number
    isEnabledForTrading?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eas?: EAUpdateManyWithoutMt5AccountNestedInput
    trades?: TradeUpdateManyWithoutMt5AccountNestedInput
  }

  export type MT5AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    broker?: StringFieldUpdateOperationsInput | string
    serverName?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    vpsIp?: NullableStringFieldUpdateOperationsInput | string | null
    vpsPort?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    balance?: FloatFieldUpdateOperationsInput | number
    equity?: FloatFieldUpdateOperationsInput | number
    margin?: FloatFieldUpdateOperationsInput | number
    freeMargin?: FloatFieldUpdateOperationsInput | number
    isEnabledForTrading?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eas?: EAUncheckedUpdateManyWithoutMt5AccountNestedInput
    trades?: TradeUncheckedUpdateManyWithoutMt5AccountNestedInput
  }

  export type MT5AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    broker?: StringFieldUpdateOperationsInput | string
    serverName?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    vpsIp?: NullableStringFieldUpdateOperationsInput | string | null
    vpsPort?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    balance?: FloatFieldUpdateOperationsInput | number
    equity?: FloatFieldUpdateOperationsInput | number
    margin?: FloatFieldUpdateOperationsInput | number
    freeMargin?: FloatFieldUpdateOperationsInput | number
    isEnabledForTrading?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EAUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    magicNumber?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumEAStatusFieldUpdateOperationsInput | $Enums.EAStatus
    safetyIndicator?: EnumSafetyIndicatorFieldUpdateOperationsInput | $Enums.SafetyIndicator
    indicatorScore?: FloatFieldUpdateOperationsInput | number
    stoppedByIndicator?: BoolFieldUpdateOperationsInput | boolean
    stoppedByIndicatorAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxLotSize?: FloatFieldUpdateOperationsInput | number
    riskPercent?: FloatFieldUpdateOperationsInput | number
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStopAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uptime?: IntFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    winningTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mt5Account?: MT5AccountUpdateOneRequiredWithoutEasNestedInput
  }

  export type EAUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    mt5AccountId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    magicNumber?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumEAStatusFieldUpdateOperationsInput | $Enums.EAStatus
    safetyIndicator?: EnumSafetyIndicatorFieldUpdateOperationsInput | $Enums.SafetyIndicator
    indicatorScore?: FloatFieldUpdateOperationsInput | number
    stoppedByIndicator?: BoolFieldUpdateOperationsInput | boolean
    stoppedByIndicatorAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxLotSize?: FloatFieldUpdateOperationsInput | number
    riskPercent?: FloatFieldUpdateOperationsInput | number
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStopAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uptime?: IntFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    winningTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EAUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    mt5AccountId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    magicNumber?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumEAStatusFieldUpdateOperationsInput | $Enums.EAStatus
    safetyIndicator?: EnumSafetyIndicatorFieldUpdateOperationsInput | $Enums.SafetyIndicator
    indicatorScore?: FloatFieldUpdateOperationsInput | number
    stoppedByIndicator?: BoolFieldUpdateOperationsInput | boolean
    stoppedByIndicatorAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxLotSize?: FloatFieldUpdateOperationsInput | number
    riskPercent?: FloatFieldUpdateOperationsInput | number
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStopAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uptime?: IntFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    winningTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticket?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    volume?: FloatFieldUpdateOperationsInput | number
    openPrice?: FloatFieldUpdateOperationsInput | number
    openTime?: DateTimeFieldUpdateOperationsInput | Date | string
    closePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    closeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profit?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    swap?: FloatFieldUpdateOperationsInput | number
    magicNumber?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mt5Account?: MT5AccountUpdateOneRequiredWithoutTradesNestedInput
  }

  export type TradeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    mt5AccountId?: StringFieldUpdateOperationsInput | string
    ticket?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    volume?: FloatFieldUpdateOperationsInput | number
    openPrice?: FloatFieldUpdateOperationsInput | number
    openTime?: DateTimeFieldUpdateOperationsInput | Date | string
    closePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    closeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profit?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    swap?: FloatFieldUpdateOperationsInput | number
    magicNumber?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    mt5AccountId?: StringFieldUpdateOperationsInput | string
    ticket?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    volume?: FloatFieldUpdateOperationsInput | number
    openPrice?: FloatFieldUpdateOperationsInput | number
    openTime?: DateTimeFieldUpdateOperationsInput | Date | string
    closePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    closeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profit?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    swap?: FloatFieldUpdateOperationsInput | number
    magicNumber?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    channel?: EnumAutomationActionTypeFieldUpdateOperationsInput | $Enums.AutomationActionType
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    automation?: AutomationUpdateOneRequiredWithoutLogsNestedInput
  }

  export type NotificationLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    automationId?: StringFieldUpdateOperationsInput | string
    channel?: EnumAutomationActionTypeFieldUpdateOperationsInput | $Enums.AutomationActionType
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    automationId?: StringFieldUpdateOperationsInput | string
    channel?: EnumAutomationActionTypeFieldUpdateOperationsInput | $Enums.AutomationActionType
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutomationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: EnumAutomationTriggerTypeFieldUpdateOperationsInput | $Enums.AutomationTriggerType
    triggerValue?: NullableIntFieldUpdateOperationsInput | number | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    actionTypes?: AutomationUpdateactionTypesInput | $Enums.AutomationActionType[]
    actionData?: NullableJsonNullValueInput | InputJsonValue
    messageSubject?: NullableStringFieldUpdateOperationsInput | string | null
    messageBody?: StringFieldUpdateOperationsInput | string
    status?: EnumAutomationStatusFieldUpdateOperationsInput | $Enums.AutomationStatus
    priority?: IntFieldUpdateOperationsInput | number
    isUserEnabled?: BoolFieldUpdateOperationsInput | boolean
    totalTriggered?: IntFieldUpdateOperationsInput | number
    totalSent?: IntFieldUpdateOperationsInput | number
    totalFailed?: IntFieldUpdateOperationsInput | number
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    logs?: NotificationLogUpdateManyWithoutAutomationNestedInput
  }

  export type AutomationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: EnumAutomationTriggerTypeFieldUpdateOperationsInput | $Enums.AutomationTriggerType
    triggerValue?: NullableIntFieldUpdateOperationsInput | number | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    actionTypes?: AutomationUpdateactionTypesInput | $Enums.AutomationActionType[]
    actionData?: NullableJsonNullValueInput | InputJsonValue
    messageSubject?: NullableStringFieldUpdateOperationsInput | string | null
    messageBody?: StringFieldUpdateOperationsInput | string
    status?: EnumAutomationStatusFieldUpdateOperationsInput | $Enums.AutomationStatus
    priority?: IntFieldUpdateOperationsInput | number
    isUserEnabled?: BoolFieldUpdateOperationsInput | boolean
    totalTriggered?: IntFieldUpdateOperationsInput | number
    totalSent?: IntFieldUpdateOperationsInput | number
    totalFailed?: IntFieldUpdateOperationsInput | number
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    logs?: NotificationLogUncheckedUpdateManyWithoutAutomationNestedInput
  }

  export type AutomationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: EnumAutomationTriggerTypeFieldUpdateOperationsInput | $Enums.AutomationTriggerType
    triggerValue?: NullableIntFieldUpdateOperationsInput | number | null
    triggerData?: NullableJsonNullValueInput | InputJsonValue
    actionTypes?: AutomationUpdateactionTypesInput | $Enums.AutomationActionType[]
    actionData?: NullableJsonNullValueInput | InputJsonValue
    messageSubject?: NullableStringFieldUpdateOperationsInput | string | null
    messageBody?: StringFieldUpdateOperationsInput | string
    status?: EnumAutomationStatusFieldUpdateOperationsInput | $Enums.AutomationStatus
    priority?: IntFieldUpdateOperationsInput | number
    isUserEnabled?: BoolFieldUpdateOperationsInput | boolean
    totalTriggered?: IntFieldUpdateOperationsInput | number
    totalSent?: IntFieldUpdateOperationsInput | number
    totalFailed?: IntFieldUpdateOperationsInput | number
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LeaderboardEntryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trades?: IntFieldUpdateOperationsInput | number
    winningTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    profit?: FloatFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    previousRank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaderboardEntryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trades?: IntFieldUpdateOperationsInput | number
    winningTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    profit?: FloatFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    previousRank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaderboardEntryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trades?: IntFieldUpdateOperationsInput | number
    winningTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    profit?: FloatFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    previousRank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    machineId?: StringFieldUpdateOperationsInput | string
    machineName?: NullableStringFieldUpdateOperationsInput | string | null
    isPoolAgent?: BoolFieldUpdateOperationsInput | boolean
    managedAccounts?: AgentUpdatemanagedAccountsInput | string[]
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentLoad?: IntFieldUpdateOperationsInput | number
    vpsName?: NullableStringFieldUpdateOperationsInput | string | null
    vpsRegion?: NullableStringFieldUpdateOperationsInput | string | null
    vpsIp?: NullableStringFieldUpdateOperationsInput | string | null
    mt5AccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    mt5Broker?: NullableStringFieldUpdateOperationsInput | string | null
    mt5ServerName?: NullableStringFieldUpdateOperationsInput | string | null
    mt5Version?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastHeartbeat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    connectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eaLoaded?: BoolFieldUpdateOperationsInput | boolean
    eaRunning?: BoolFieldUpdateOperationsInput | boolean
    eaName?: NullableStringFieldUpdateOperationsInput | string | null
    chartSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    chartTimeframe?: NullableStringFieldUpdateOperationsInput | string | null
    tradeCopierActive?: BoolFieldUpdateOperationsInput | boolean
    isMasterAccount?: BoolFieldUpdateOperationsInput | boolean
    totalTrades?: IntFieldUpdateOperationsInput | number
    profitableTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    indicatorSettings?: NullableJsonNullValueInput | InputJsonValue
    aiOptimizationScore?: FloatFieldUpdateOperationsInput | number
    lastOptimizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    agentVersion?: NullableStringFieldUpdateOperationsInput | string | null
    cpuUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    memoryUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    diskUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    mt5InstanceCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    masterAgent?: AgentUpdateOneWithoutSlaveAgentsNestedInput
    slaveAgents?: AgentUpdateManyWithoutMasterAgentNestedInput
    accountAssignments?: MT5AccountAssignmentUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    machineId?: StringFieldUpdateOperationsInput | string
    machineName?: NullableStringFieldUpdateOperationsInput | string | null
    isPoolAgent?: BoolFieldUpdateOperationsInput | boolean
    managedAccounts?: AgentUpdatemanagedAccountsInput | string[]
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentLoad?: IntFieldUpdateOperationsInput | number
    vpsName?: NullableStringFieldUpdateOperationsInput | string | null
    vpsRegion?: NullableStringFieldUpdateOperationsInput | string | null
    vpsIp?: NullableStringFieldUpdateOperationsInput | string | null
    mt5AccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    mt5Broker?: NullableStringFieldUpdateOperationsInput | string | null
    mt5ServerName?: NullableStringFieldUpdateOperationsInput | string | null
    mt5Version?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastHeartbeat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    connectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eaLoaded?: BoolFieldUpdateOperationsInput | boolean
    eaRunning?: BoolFieldUpdateOperationsInput | boolean
    eaName?: NullableStringFieldUpdateOperationsInput | string | null
    chartSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    chartTimeframe?: NullableStringFieldUpdateOperationsInput | string | null
    tradeCopierActive?: BoolFieldUpdateOperationsInput | boolean
    isMasterAccount?: BoolFieldUpdateOperationsInput | boolean
    masterAgentId?: NullableStringFieldUpdateOperationsInput | string | null
    totalTrades?: IntFieldUpdateOperationsInput | number
    profitableTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    indicatorSettings?: NullableJsonNullValueInput | InputJsonValue
    aiOptimizationScore?: FloatFieldUpdateOperationsInput | number
    lastOptimizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    agentVersion?: NullableStringFieldUpdateOperationsInput | string | null
    cpuUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    memoryUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    diskUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    mt5InstanceCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slaveAgents?: AgentUncheckedUpdateManyWithoutMasterAgentNestedInput
    accountAssignments?: MT5AccountAssignmentUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    machineId?: StringFieldUpdateOperationsInput | string
    machineName?: NullableStringFieldUpdateOperationsInput | string | null
    isPoolAgent?: BoolFieldUpdateOperationsInput | boolean
    managedAccounts?: AgentUpdatemanagedAccountsInput | string[]
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentLoad?: IntFieldUpdateOperationsInput | number
    vpsName?: NullableStringFieldUpdateOperationsInput | string | null
    vpsRegion?: NullableStringFieldUpdateOperationsInput | string | null
    vpsIp?: NullableStringFieldUpdateOperationsInput | string | null
    mt5AccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    mt5Broker?: NullableStringFieldUpdateOperationsInput | string | null
    mt5ServerName?: NullableStringFieldUpdateOperationsInput | string | null
    mt5Version?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastHeartbeat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    connectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eaLoaded?: BoolFieldUpdateOperationsInput | boolean
    eaRunning?: BoolFieldUpdateOperationsInput | boolean
    eaName?: NullableStringFieldUpdateOperationsInput | string | null
    chartSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    chartTimeframe?: NullableStringFieldUpdateOperationsInput | string | null
    tradeCopierActive?: BoolFieldUpdateOperationsInput | boolean
    isMasterAccount?: BoolFieldUpdateOperationsInput | boolean
    masterAgentId?: NullableStringFieldUpdateOperationsInput | string | null
    totalTrades?: IntFieldUpdateOperationsInput | number
    profitableTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    indicatorSettings?: NullableJsonNullValueInput | InputJsonValue
    aiOptimizationScore?: FloatFieldUpdateOperationsInput | number
    lastOptimizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    agentVersion?: NullableStringFieldUpdateOperationsInput | string | null
    cpuUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    memoryUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    diskUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    mt5InstanceCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MT5AccountAssignmentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    mt5AccountNumber?: StringFieldUpdateOperationsInput | string
    mt5Broker?: NullableStringFieldUpdateOperationsInput | string | null
    mt5ServerName?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    eaStatus?: StringFieldUpdateOperationsInput | string
    lastHeartbeat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    equity?: FloatFieldUpdateOperationsInput | number
    margin?: FloatFieldUpdateOperationsInput | number
    freeMargin?: FloatFieldUpdateOperationsInput | number
    profit?: FloatFieldUpdateOperationsInput | number
    eaLoaded?: BoolFieldUpdateOperationsInput | boolean
    eaRunning?: BoolFieldUpdateOperationsInput | boolean
    eaName?: NullableStringFieldUpdateOperationsInput | string | null
    chartSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    chartTimeframe?: NullableStringFieldUpdateOperationsInput | string | null
    totalTrades?: IntFieldUpdateOperationsInput | number
    profitableTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutAccountAssignmentsNestedInput
  }

  export type MT5AccountAssignmentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    mt5AccountNumber?: StringFieldUpdateOperationsInput | string
    mt5Broker?: NullableStringFieldUpdateOperationsInput | string | null
    mt5ServerName?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    eaStatus?: StringFieldUpdateOperationsInput | string
    lastHeartbeat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    equity?: FloatFieldUpdateOperationsInput | number
    margin?: FloatFieldUpdateOperationsInput | number
    freeMargin?: FloatFieldUpdateOperationsInput | number
    profit?: FloatFieldUpdateOperationsInput | number
    eaLoaded?: BoolFieldUpdateOperationsInput | boolean
    eaRunning?: BoolFieldUpdateOperationsInput | boolean
    eaName?: NullableStringFieldUpdateOperationsInput | string | null
    chartSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    chartTimeframe?: NullableStringFieldUpdateOperationsInput | string | null
    totalTrades?: IntFieldUpdateOperationsInput | number
    profitableTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MT5AccountAssignmentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    mt5AccountNumber?: StringFieldUpdateOperationsInput | string
    mt5Broker?: NullableStringFieldUpdateOperationsInput | string | null
    mt5ServerName?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    eaStatus?: StringFieldUpdateOperationsInput | string
    lastHeartbeat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    equity?: FloatFieldUpdateOperationsInput | number
    margin?: FloatFieldUpdateOperationsInput | number
    freeMargin?: FloatFieldUpdateOperationsInput | number
    profit?: FloatFieldUpdateOperationsInput | number
    eaLoaded?: BoolFieldUpdateOperationsInput | boolean
    eaRunning?: BoolFieldUpdateOperationsInput | boolean
    eaName?: NullableStringFieldUpdateOperationsInput | string | null
    chartSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    chartTimeframe?: NullableStringFieldUpdateOperationsInput | string | null
    totalTrades?: IntFieldUpdateOperationsInput | number
    profitableTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnonymousAccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: StringFieldUpdateOperationsInput | string
    mt5AccountNumber?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ibPartner?: IBPartnerUpdateOneRequiredWithoutAnonymousAccountsNestedInput
    commissions?: IBCommissionUpdateManyWithoutAnonymousAccountNestedInput
  }

  export type AnonymousAccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: StringFieldUpdateOperationsInput | string
    mt5AccountNumber?: StringFieldUpdateOperationsInput | string
    ibPartnerId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commissions?: IBCommissionUncheckedUpdateManyWithoutAnonymousAccountNestedInput
  }

  export type AnonymousAccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: StringFieldUpdateOperationsInput | string
    mt5AccountNumber?: StringFieldUpdateOperationsInput | string
    ibPartnerId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EACreateManyMt5AccountInput = {
    id?: string
    userId: string
    name: string
    version?: string | null
    magicNumber?: number | null
    status?: $Enums.EAStatus
    safetyIndicator?: $Enums.SafetyIndicator
    indicatorScore?: number
    stoppedByIndicator?: boolean
    stoppedByIndicatorAt?: Date | string | null
    maxLotSize?: number
    riskPercent?: number
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastStartAt?: Date | string | null
    lastStopAt?: Date | string | null
    uptime?: number
    totalTrades?: number
    winningTrades?: number
    totalProfit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TradeCreateManyMt5AccountInput = {
    id?: string
    userId: string
    ticket: string
    symbol: string
    type: string
    volume: number
    openPrice: number
    openTime: Date | string
    closePrice?: number | null
    closeTime?: Date | string | null
    profit?: number
    commission?: number
    swap?: number
    magicNumber?: number | null
    comment?: string | null
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EAUpdateWithoutMt5AccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    magicNumber?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumEAStatusFieldUpdateOperationsInput | $Enums.EAStatus
    safetyIndicator?: EnumSafetyIndicatorFieldUpdateOperationsInput | $Enums.SafetyIndicator
    indicatorScore?: FloatFieldUpdateOperationsInput | number
    stoppedByIndicator?: BoolFieldUpdateOperationsInput | boolean
    stoppedByIndicatorAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxLotSize?: FloatFieldUpdateOperationsInput | number
    riskPercent?: FloatFieldUpdateOperationsInput | number
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStopAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uptime?: IntFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    winningTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEasNestedInput
  }

  export type EAUncheckedUpdateWithoutMt5AccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    magicNumber?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumEAStatusFieldUpdateOperationsInput | $Enums.EAStatus
    safetyIndicator?: EnumSafetyIndicatorFieldUpdateOperationsInput | $Enums.SafetyIndicator
    indicatorScore?: FloatFieldUpdateOperationsInput | number
    stoppedByIndicator?: BoolFieldUpdateOperationsInput | boolean
    stoppedByIndicatorAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxLotSize?: FloatFieldUpdateOperationsInput | number
    riskPercent?: FloatFieldUpdateOperationsInput | number
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStopAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uptime?: IntFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    winningTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EAUncheckedUpdateManyWithoutMt5AccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    magicNumber?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumEAStatusFieldUpdateOperationsInput | $Enums.EAStatus
    safetyIndicator?: EnumSafetyIndicatorFieldUpdateOperationsInput | $Enums.SafetyIndicator
    indicatorScore?: FloatFieldUpdateOperationsInput | number
    stoppedByIndicator?: BoolFieldUpdateOperationsInput | boolean
    stoppedByIndicatorAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxLotSize?: FloatFieldUpdateOperationsInput | number
    riskPercent?: FloatFieldUpdateOperationsInput | number
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStopAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uptime?: IntFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    winningTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradeUpdateWithoutMt5AccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticket?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    volume?: FloatFieldUpdateOperationsInput | number
    openPrice?: FloatFieldUpdateOperationsInput | number
    openTime?: DateTimeFieldUpdateOperationsInput | Date | string
    closePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    closeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profit?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    swap?: FloatFieldUpdateOperationsInput | number
    magicNumber?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTradesNestedInput
  }

  export type TradeUncheckedUpdateWithoutMt5AccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    ticket?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    volume?: FloatFieldUpdateOperationsInput | number
    openPrice?: FloatFieldUpdateOperationsInput | number
    openTime?: DateTimeFieldUpdateOperationsInput | Date | string
    closePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    closeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profit?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    swap?: FloatFieldUpdateOperationsInput | number
    magicNumber?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradeUncheckedUpdateManyWithoutMt5AccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    ticket?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    volume?: FloatFieldUpdateOperationsInput | number
    openPrice?: FloatFieldUpdateOperationsInput | number
    openTime?: DateTimeFieldUpdateOperationsInput | Date | string
    closePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    closeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profit?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    swap?: FloatFieldUpdateOperationsInput | number
    magicNumber?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationLogCreateManyAutomationInput = {
    id?: string
    userId: string
    channel: $Enums.AutomationActionType
    recipient: string
    subject?: string | null
    message: string
    status?: $Enums.NotificationStatus
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    failedAt?: Date | string | null
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationLogUpdateWithoutAutomationInput = {
    id?: StringFieldUpdateOperationsInput | string
    channel?: EnumAutomationActionTypeFieldUpdateOperationsInput | $Enums.AutomationActionType
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationLogUncheckedUpdateWithoutAutomationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    channel?: EnumAutomationActionTypeFieldUpdateOperationsInput | $Enums.AutomationActionType
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationLogUncheckedUpdateManyWithoutAutomationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    channel?: EnumAutomationActionTypeFieldUpdateOperationsInput | $Enums.AutomationActionType
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyIbPartnerInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    phone?: string | null
    ibCode?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    monthlyFee?: number
    totalTrades?: number
    winningTrades?: number
    losingTrades?: number
    totalProfit?: number
    totalVolume?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    lastActiveAt?: Date | string | null
    isActive?: boolean
    status?: $Enums.AccountStatus
    emailVerified?: boolean
    verificationCode?: string | null
    verificationExpiry?: Date | string | null
  }

  export type AnonymousAccountCreateManyIbPartnerInput = {
    id?: string
    anonymousId: string
    userId: string
    mt5AccountNumber: string
    isActive?: boolean
    registeredAt?: Date | string
  }

  export type IBCommissionCreateManyIbPartnerInput = {
    id?: string
    anonymousAccountId: string
    period: Date | string
    periodEnd: Date | string
    tradingVolume?: number
    numberOfTrades?: number
    averageSpread?: number
    commissionRate: number
    grossCommission?: number
    platformFee?: number
    netCommission?: number
    isPaid?: boolean
    paidAt?: Date | string | null
    paymentReference?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IBCommissionRateCreateManyIbPartnerInput = {
    id?: string
    commissionRate?: number
    minVolume?: number
    maxVolume?: number | null
    effectiveFrom?: Date | string
    effectiveTo?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutIbPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ibCode?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyFee?: FloatFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    winningTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mt5Accounts?: MT5AccountUpdateManyWithoutUserNestedInput
    eas?: EAUpdateManyWithoutUserNestedInput
    trades?: TradeUpdateManyWithoutUserNestedInput
    notifications?: NotificationLogUpdateManyWithoutUserNestedInput
    insights?: UserInsightUpdateOneWithoutUserNestedInput
    automations?: AutomationUpdateManyWithoutUserNestedInput
    leaderboardStats?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    agents?: AgentUpdateManyWithoutUserNestedInput
    accountAssignments?: MT5AccountAssignmentUpdateManyWithoutUserNestedInput
    anonymousAccounts?: AnonymousAccountUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutIbPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ibCode?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyFee?: FloatFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    winningTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mt5Accounts?: MT5AccountUncheckedUpdateManyWithoutUserNestedInput
    eas?: EAUncheckedUpdateManyWithoutUserNestedInput
    trades?: TradeUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationLogUncheckedUpdateManyWithoutUserNestedInput
    insights?: UserInsightUncheckedUpdateOneWithoutUserNestedInput
    automations?: AutomationUncheckedUpdateManyWithoutUserNestedInput
    leaderboardStats?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    agents?: AgentUncheckedUpdateManyWithoutUserNestedInput
    accountAssignments?: MT5AccountAssignmentUncheckedUpdateManyWithoutUserNestedInput
    anonymousAccounts?: AnonymousAccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutIbPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ibCode?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyFee?: FloatFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    winningTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AnonymousAccountUpdateWithoutIbPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: StringFieldUpdateOperationsInput | string
    mt5AccountNumber?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAnonymousAccountsNestedInput
    commissions?: IBCommissionUpdateManyWithoutAnonymousAccountNestedInput
  }

  export type AnonymousAccountUncheckedUpdateWithoutIbPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mt5AccountNumber?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commissions?: IBCommissionUncheckedUpdateManyWithoutAnonymousAccountNestedInput
  }

  export type AnonymousAccountUncheckedUpdateManyWithoutIbPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mt5AccountNumber?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IBCommissionUpdateWithoutIbPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    tradingVolume?: FloatFieldUpdateOperationsInput | number
    numberOfTrades?: IntFieldUpdateOperationsInput | number
    averageSpread?: FloatFieldUpdateOperationsInput | number
    commissionRate?: FloatFieldUpdateOperationsInput | number
    grossCommission?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    netCommission?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    anonymousAccount?: AnonymousAccountUpdateOneRequiredWithoutCommissionsNestedInput
  }

  export type IBCommissionUncheckedUpdateWithoutIbPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousAccountId?: StringFieldUpdateOperationsInput | string
    period?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    tradingVolume?: FloatFieldUpdateOperationsInput | number
    numberOfTrades?: IntFieldUpdateOperationsInput | number
    averageSpread?: FloatFieldUpdateOperationsInput | number
    commissionRate?: FloatFieldUpdateOperationsInput | number
    grossCommission?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    netCommission?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IBCommissionUncheckedUpdateManyWithoutIbPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousAccountId?: StringFieldUpdateOperationsInput | string
    period?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    tradingVolume?: FloatFieldUpdateOperationsInput | number
    numberOfTrades?: IntFieldUpdateOperationsInput | number
    averageSpread?: FloatFieldUpdateOperationsInput | number
    commissionRate?: FloatFieldUpdateOperationsInput | number
    grossCommission?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    netCommission?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IBCommissionRateUpdateWithoutIbPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    commissionRate?: FloatFieldUpdateOperationsInput | number
    minVolume?: FloatFieldUpdateOperationsInput | number
    maxVolume?: NullableFloatFieldUpdateOperationsInput | number | null
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IBCommissionRateUncheckedUpdateWithoutIbPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    commissionRate?: FloatFieldUpdateOperationsInput | number
    minVolume?: FloatFieldUpdateOperationsInput | number
    maxVolume?: NullableFloatFieldUpdateOperationsInput | number | null
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IBCommissionRateUncheckedUpdateManyWithoutIbPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    commissionRate?: FloatFieldUpdateOperationsInput | number
    minVolume?: FloatFieldUpdateOperationsInput | number
    maxVolume?: NullableFloatFieldUpdateOperationsInput | number | null
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentCreateManyMasterAgentInput = {
    id?: string
    userId?: string | null
    machineId: string
    machineName?: string | null
    isPoolAgent?: boolean
    managedAccounts?: AgentCreatemanagedAccountsInput | string[]
    maxCapacity?: number
    currentLoad?: number
    vpsName?: string | null
    vpsRegion?: string | null
    vpsIp?: string | null
    mt5AccountNumber?: string | null
    mt5Broker?: string | null
    mt5ServerName?: string | null
    mt5Version?: string | null
    status?: string
    lastHeartbeat?: Date | string | null
    connectedAt?: Date | string | null
    disconnectedAt?: Date | string | null
    eaLoaded?: boolean
    eaRunning?: boolean
    eaName?: string | null
    chartSymbol?: string | null
    chartTimeframe?: string | null
    tradeCopierActive?: boolean
    isMasterAccount?: boolean
    totalTrades?: number
    profitableTrades?: number
    losingTrades?: number
    totalProfit?: number
    winRate?: number
    indicatorSettings?: NullableJsonNullValueInput | InputJsonValue
    aiOptimizationScore?: number
    lastOptimizedAt?: Date | string | null
    apiKey?: string | null
    osVersion?: string | null
    agentVersion?: string | null
    cpuUsage?: number | null
    memoryUsage?: number | null
    diskUsage?: number | null
    mt5InstanceCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MT5AccountAssignmentCreateManyAgentInput = {
    id?: string
    userId: string
    mt5AccountNumber: string
    mt5Broker?: string | null
    mt5ServerName?: string | null
    assignedAt?: Date | string
    isActive?: boolean
    status?: string
    eaStatus?: string
    lastHeartbeat?: Date | string | null
    balance?: number
    equity?: number
    margin?: number
    freeMargin?: number
    profit?: number
    eaLoaded?: boolean
    eaRunning?: boolean
    eaName?: string | null
    chartSymbol?: string | null
    chartTimeframe?: string | null
    totalTrades?: number
    profitableTrades?: number
    losingTrades?: number
    totalProfit?: number
    winRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentUpdateWithoutMasterAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    machineId?: StringFieldUpdateOperationsInput | string
    machineName?: NullableStringFieldUpdateOperationsInput | string | null
    isPoolAgent?: BoolFieldUpdateOperationsInput | boolean
    managedAccounts?: AgentUpdatemanagedAccountsInput | string[]
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentLoad?: IntFieldUpdateOperationsInput | number
    vpsName?: NullableStringFieldUpdateOperationsInput | string | null
    vpsRegion?: NullableStringFieldUpdateOperationsInput | string | null
    vpsIp?: NullableStringFieldUpdateOperationsInput | string | null
    mt5AccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    mt5Broker?: NullableStringFieldUpdateOperationsInput | string | null
    mt5ServerName?: NullableStringFieldUpdateOperationsInput | string | null
    mt5Version?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastHeartbeat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    connectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eaLoaded?: BoolFieldUpdateOperationsInput | boolean
    eaRunning?: BoolFieldUpdateOperationsInput | boolean
    eaName?: NullableStringFieldUpdateOperationsInput | string | null
    chartSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    chartTimeframe?: NullableStringFieldUpdateOperationsInput | string | null
    tradeCopierActive?: BoolFieldUpdateOperationsInput | boolean
    isMasterAccount?: BoolFieldUpdateOperationsInput | boolean
    totalTrades?: IntFieldUpdateOperationsInput | number
    profitableTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    indicatorSettings?: NullableJsonNullValueInput | InputJsonValue
    aiOptimizationScore?: FloatFieldUpdateOperationsInput | number
    lastOptimizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    agentVersion?: NullableStringFieldUpdateOperationsInput | string | null
    cpuUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    memoryUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    diskUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    mt5InstanceCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAgentsNestedInput
    slaveAgents?: AgentUpdateManyWithoutMasterAgentNestedInput
    accountAssignments?: MT5AccountAssignmentUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutMasterAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    machineId?: StringFieldUpdateOperationsInput | string
    machineName?: NullableStringFieldUpdateOperationsInput | string | null
    isPoolAgent?: BoolFieldUpdateOperationsInput | boolean
    managedAccounts?: AgentUpdatemanagedAccountsInput | string[]
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentLoad?: IntFieldUpdateOperationsInput | number
    vpsName?: NullableStringFieldUpdateOperationsInput | string | null
    vpsRegion?: NullableStringFieldUpdateOperationsInput | string | null
    vpsIp?: NullableStringFieldUpdateOperationsInput | string | null
    mt5AccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    mt5Broker?: NullableStringFieldUpdateOperationsInput | string | null
    mt5ServerName?: NullableStringFieldUpdateOperationsInput | string | null
    mt5Version?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastHeartbeat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    connectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eaLoaded?: BoolFieldUpdateOperationsInput | boolean
    eaRunning?: BoolFieldUpdateOperationsInput | boolean
    eaName?: NullableStringFieldUpdateOperationsInput | string | null
    chartSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    chartTimeframe?: NullableStringFieldUpdateOperationsInput | string | null
    tradeCopierActive?: BoolFieldUpdateOperationsInput | boolean
    isMasterAccount?: BoolFieldUpdateOperationsInput | boolean
    totalTrades?: IntFieldUpdateOperationsInput | number
    profitableTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    indicatorSettings?: NullableJsonNullValueInput | InputJsonValue
    aiOptimizationScore?: FloatFieldUpdateOperationsInput | number
    lastOptimizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    agentVersion?: NullableStringFieldUpdateOperationsInput | string | null
    cpuUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    memoryUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    diskUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    mt5InstanceCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slaveAgents?: AgentUncheckedUpdateManyWithoutMasterAgentNestedInput
    accountAssignments?: MT5AccountAssignmentUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateManyWithoutMasterAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    machineId?: StringFieldUpdateOperationsInput | string
    machineName?: NullableStringFieldUpdateOperationsInput | string | null
    isPoolAgent?: BoolFieldUpdateOperationsInput | boolean
    managedAccounts?: AgentUpdatemanagedAccountsInput | string[]
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentLoad?: IntFieldUpdateOperationsInput | number
    vpsName?: NullableStringFieldUpdateOperationsInput | string | null
    vpsRegion?: NullableStringFieldUpdateOperationsInput | string | null
    vpsIp?: NullableStringFieldUpdateOperationsInput | string | null
    mt5AccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    mt5Broker?: NullableStringFieldUpdateOperationsInput | string | null
    mt5ServerName?: NullableStringFieldUpdateOperationsInput | string | null
    mt5Version?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastHeartbeat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    connectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eaLoaded?: BoolFieldUpdateOperationsInput | boolean
    eaRunning?: BoolFieldUpdateOperationsInput | boolean
    eaName?: NullableStringFieldUpdateOperationsInput | string | null
    chartSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    chartTimeframe?: NullableStringFieldUpdateOperationsInput | string | null
    tradeCopierActive?: BoolFieldUpdateOperationsInput | boolean
    isMasterAccount?: BoolFieldUpdateOperationsInput | boolean
    totalTrades?: IntFieldUpdateOperationsInput | number
    profitableTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    indicatorSettings?: NullableJsonNullValueInput | InputJsonValue
    aiOptimizationScore?: FloatFieldUpdateOperationsInput | number
    lastOptimizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    agentVersion?: NullableStringFieldUpdateOperationsInput | string | null
    cpuUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    memoryUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    diskUsage?: NullableFloatFieldUpdateOperationsInput | number | null
    mt5InstanceCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MT5AccountAssignmentUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    mt5AccountNumber?: StringFieldUpdateOperationsInput | string
    mt5Broker?: NullableStringFieldUpdateOperationsInput | string | null
    mt5ServerName?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    eaStatus?: StringFieldUpdateOperationsInput | string
    lastHeartbeat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    equity?: FloatFieldUpdateOperationsInput | number
    margin?: FloatFieldUpdateOperationsInput | number
    freeMargin?: FloatFieldUpdateOperationsInput | number
    profit?: FloatFieldUpdateOperationsInput | number
    eaLoaded?: BoolFieldUpdateOperationsInput | boolean
    eaRunning?: BoolFieldUpdateOperationsInput | boolean
    eaName?: NullableStringFieldUpdateOperationsInput | string | null
    chartSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    chartTimeframe?: NullableStringFieldUpdateOperationsInput | string | null
    totalTrades?: IntFieldUpdateOperationsInput | number
    profitableTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountAssignmentsNestedInput
  }

  export type MT5AccountAssignmentUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mt5AccountNumber?: StringFieldUpdateOperationsInput | string
    mt5Broker?: NullableStringFieldUpdateOperationsInput | string | null
    mt5ServerName?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    eaStatus?: StringFieldUpdateOperationsInput | string
    lastHeartbeat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    equity?: FloatFieldUpdateOperationsInput | number
    margin?: FloatFieldUpdateOperationsInput | number
    freeMargin?: FloatFieldUpdateOperationsInput | number
    profit?: FloatFieldUpdateOperationsInput | number
    eaLoaded?: BoolFieldUpdateOperationsInput | boolean
    eaRunning?: BoolFieldUpdateOperationsInput | boolean
    eaName?: NullableStringFieldUpdateOperationsInput | string | null
    chartSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    chartTimeframe?: NullableStringFieldUpdateOperationsInput | string | null
    totalTrades?: IntFieldUpdateOperationsInput | number
    profitableTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MT5AccountAssignmentUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mt5AccountNumber?: StringFieldUpdateOperationsInput | string
    mt5Broker?: NullableStringFieldUpdateOperationsInput | string | null
    mt5ServerName?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    eaStatus?: StringFieldUpdateOperationsInput | string
    lastHeartbeat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    equity?: FloatFieldUpdateOperationsInput | number
    margin?: FloatFieldUpdateOperationsInput | number
    freeMargin?: FloatFieldUpdateOperationsInput | number
    profit?: FloatFieldUpdateOperationsInput | number
    eaLoaded?: BoolFieldUpdateOperationsInput | boolean
    eaRunning?: BoolFieldUpdateOperationsInput | boolean
    eaName?: NullableStringFieldUpdateOperationsInput | string | null
    chartSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    chartTimeframe?: NullableStringFieldUpdateOperationsInput | string | null
    totalTrades?: IntFieldUpdateOperationsInput | number
    profitableTrades?: IntFieldUpdateOperationsInput | number
    losingTrades?: IntFieldUpdateOperationsInput | number
    totalProfit?: FloatFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IBCommissionCreateManyAnonymousAccountInput = {
    id?: string
    ibPartnerId: string
    period: Date | string
    periodEnd: Date | string
    tradingVolume?: number
    numberOfTrades?: number
    averageSpread?: number
    commissionRate: number
    grossCommission?: number
    platformFee?: number
    netCommission?: number
    isPaid?: boolean
    paidAt?: Date | string | null
    paymentReference?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IBCommissionUpdateWithoutAnonymousAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    tradingVolume?: FloatFieldUpdateOperationsInput | number
    numberOfTrades?: IntFieldUpdateOperationsInput | number
    averageSpread?: FloatFieldUpdateOperationsInput | number
    commissionRate?: FloatFieldUpdateOperationsInput | number
    grossCommission?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    netCommission?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ibPartner?: IBPartnerUpdateOneRequiredWithoutCommissionsNestedInput
  }

  export type IBCommissionUncheckedUpdateWithoutAnonymousAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    ibPartnerId?: StringFieldUpdateOperationsInput | string
    period?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    tradingVolume?: FloatFieldUpdateOperationsInput | number
    numberOfTrades?: IntFieldUpdateOperationsInput | number
    averageSpread?: FloatFieldUpdateOperationsInput | number
    commissionRate?: FloatFieldUpdateOperationsInput | number
    grossCommission?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    netCommission?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IBCommissionUncheckedUpdateManyWithoutAnonymousAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    ibPartnerId?: StringFieldUpdateOperationsInput | string
    period?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    tradingVolume?: FloatFieldUpdateOperationsInput | number
    numberOfTrades?: IntFieldUpdateOperationsInput | number
    averageSpread?: FloatFieldUpdateOperationsInput | number
    commissionRate?: FloatFieldUpdateOperationsInput | number
    grossCommission?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    netCommission?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentReference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MT5AccountCountOutputTypeDefaultArgs instead
     */
    export type MT5AccountCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MT5AccountCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AutomationCountOutputTypeDefaultArgs instead
     */
    export type AutomationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AutomationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IBPartnerCountOutputTypeDefaultArgs instead
     */
    export type IBPartnerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IBPartnerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AgentCountOutputTypeDefaultArgs instead
     */
    export type AgentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AgentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AnonymousAccountCountOutputTypeDefaultArgs instead
     */
    export type AnonymousAccountCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AnonymousAccountCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MT5AccountDefaultArgs instead
     */
    export type MT5AccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MT5AccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EADefaultArgs instead
     */
    export type EAArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EADefaultArgs<ExtArgs>
    /**
     * @deprecated Use TradeDefaultArgs instead
     */
    export type TradeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TradeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AutomationDefaultArgs instead
     */
    export type AutomationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AutomationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationLogDefaultArgs instead
     */
    export type NotificationLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserInsightDefaultArgs instead
     */
    export type UserInsightArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserInsightDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SystemLogDefaultArgs instead
     */
    export type SystemLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SystemLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MarketConditionDefaultArgs instead
     */
    export type MarketConditionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MarketConditionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LeaderboardEntryDefaultArgs instead
     */
    export type LeaderboardEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LeaderboardEntryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IBPartnerDefaultArgs instead
     */
    export type IBPartnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IBPartnerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AgentDefaultArgs instead
     */
    export type AgentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AgentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MT5AccountAssignmentDefaultArgs instead
     */
    export type MT5AccountAssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MT5AccountAssignmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PrizeDefaultArgs instead
     */
    export type PrizeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PrizeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GlobalSettingsDefaultArgs instead
     */
    export type GlobalSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GlobalSettingsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AnonymousAccountDefaultArgs instead
     */
    export type AnonymousAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AnonymousAccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IBCommissionDefaultArgs instead
     */
    export type IBCommissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IBCommissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IBCommissionRateDefaultArgs instead
     */
    export type IBCommissionRateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IBCommissionRateDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}